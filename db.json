{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":0},{"_id":"source/img/hexo设置.png","path":"img/hexo设置.png","modified":0,"renderable":0},{"_id":"source/img/模版设计模式UML.png","path":"img/模版设计模式UML.png","modified":0,"renderable":0},{"_id":"themes/next/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"source/img/index-page-img/blog.jpg","path":"img/index-page-img/blog.jpg","modified":0,"renderable":0},{"_id":"source/img/index-page-img/docker.jpeg","path":"img/index-page-img/docker.jpeg","modified":0,"renderable":0},{"_id":"source/img/index-page-img/java.png","path":"img/index-page-img/java.png","modified":0,"renderable":0},{"_id":"source/img/index-page-img/redis.jpg","path":"img/index-page-img/redis.jpg","modified":0,"renderable":0},{"_id":"source/img/index-page-img/spring.jpg","path":"img/index-page-img/spring.jpg","modified":0,"renderable":0},{"_id":"source/img/index-page-img/设计模式.png","path":"img/index-page-img/设计模式.png","modified":0,"renderable":0},{"_id":"source/img/创建账号.jpg","path":"img/创建账号.jpg","modified":0,"renderable":0},{"_id":"source/img/设置pages.png","path":"img/设置pages.png","modified":0,"renderable":0},{"_id":"source/img/设计模式-原型Prototype/UML_Prototype.mdj","path":"img/设计模式-原型Prototype/UML_Prototype.mdj","modified":0,"renderable":0},{"_id":"source/img/设计模式-原型Prototype/UML.png","path":"img/设计模式-原型Prototype/UML.png","modified":0,"renderable":0},{"_id":"source/img/设计模式-责任链【Chain Of Responsibility】/Untitled.mdj","path":"img/设计模式-责任链【Chain Of Responsibility】/Untitled.mdj","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.JPG","path":"images/avatar.JPG","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/img/blog-表格/blog-表格-页面.png","path":"img/blog-表格/blog-表格-页面.png","modified":0,"renderable":0},{"_id":"source/img/java CAS原理/物理机结构.jpg","path":"img/java CAS原理/物理机结构.jpg","modified":0,"renderable":0},{"_id":"source/img/设计模式-代理【Proxy】/UML.png","path":"img/设计模式-代理【Proxy】/UML.png","modified":0,"renderable":0},{"_id":"source/img/设计模式-责任链【Chain Of Responsibility】/UML.png","path":"img/设计模式-责任链【Chain Of Responsibility】/UML.png","modified":0,"renderable":0},{"_id":"source/img/设计模式-适配器Adapter/UML.png","path":"img/设计模式-适配器Adapter/UML.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/IMG_0001.JPG","path":"images/IMG_0001.JPG","modified":0,"renderable":1},{"_id":"source/img/blog-表格/blog-表格-正确.png","path":"img/blog-表格/blog-表格-正确.png","modified":0,"renderable":0},{"_id":"source/img/blog-表格/blog-表格-md源码.png","path":"img/blog-表格/blog-表格-md源码.png","modified":0,"renderable":0},{"_id":"source/img/设计模式-模版方法Template/模版设计模式UML.png","path":"img/设计模式-模版方法Template/模版设计模式UML.png","modified":0,"renderable":0},{"_id":"source/img/设计模式-组合Composite/UML.png","path":"img/设计模式-组合Composite/UML.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"source/img/blog-表格/blog-表格-正确md源码.png","path":"img/blog-表格/blog-表格-正确md源码.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"source/page/2/img/index-page-img/blog.jpg","path":"page/2/img/index-page-img/blog.jpg","modified":0,"renderable":0},{"_id":"source/page/2/img/index-page-img/docker.jpeg","path":"page/2/img/index-page-img/docker.jpeg","modified":0,"renderable":0},{"_id":"source/page/2/img/index-page-img/spring.jpg","path":"page/2/img/index-page-img/spring.jpg","modified":0,"renderable":0},{"_id":"source/page/2/img/index-page-img/redis.jpg","path":"page/2/img/index-page-img/redis.jpg","modified":0,"renderable":0},{"_id":"source/page/2/img/index-page-img/java.png","path":"page/2/img/index-page-img/java.png","modified":0,"renderable":0},{"_id":"source/page/2/img/index-page-img/设计模式.png","path":"page/2/img/index-page-img/设计模式.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"source/img/blog-表格/blog-表格-html源码.png","path":"img/blog-表格/blog-表格-html源码.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/hexo设置.png","path":"2018/06/03/Hexo、Github搭建Blog/img/hexo设置.png","modified":0,"renderable":0},{"_id":"source/2018/06/09/设计模式-模版【Tempalte Method】/img/模版设计模式UML.png","path":"2018/06/09/设计模式-模版【Tempalte Method】/img/模版设计模式UML.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/2018/07/22/img/java-CAS原理/物理机结构.jpg","path":"2018/07/22/img/java-CAS原理/物理机结构.jpg","modified":0,"renderable":0},{"_id":"source/2018/07/07/blog-表格/img/index-page-img/blog.jpg","path":"2018/07/07/blog-表格/img/index-page-img/blog.jpg","modified":0,"renderable":0},{"_id":"source/2018/07/07/java-8-stream/img/index-page-img/java.png","path":"2018/07/07/java-8-stream/img/index-page-img/java.png","modified":0,"renderable":0},{"_id":"source/2018/07/14/jvm工具-greys/img/index-page-img/java.png","path":"2018/07/14/jvm工具-greys/img/index-page-img/java.png","modified":0,"renderable":0},{"_id":"source/2018/07/22/java-CAS原理/img/index-page-img/java.png","path":"2018/07/22/java-CAS原理/img/index-page-img/java.png","modified":0,"renderable":0},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/index-page-img/blog.jpg","path":"2018/06/03/Hexo、Github搭建Blog/img/index-page-img/blog.jpg","modified":0,"renderable":0},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/创建账号.jpg","path":"2018/06/03/Hexo、Github搭建Blog/img/创建账号.jpg","modified":0,"renderable":0},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/设置pages.png","path":"2018/06/03/Hexo、Github搭建Blog/img/设置pages.png","modified":0,"renderable":0},{"_id":"source/2018/06/09/设计模式-模版【Tempalte Method】/img/设计模式-模版方法Template/模版设计模式UML.png","path":"2018/06/09/设计模式-模版【Tempalte Method】/img/设计模式-模版方法Template/模版设计模式UML.png","modified":0,"renderable":0},{"_id":"source/2018/06/09/设计模式-模版【Tempalte Method】/img/index-page-img/设计模式.png","path":"2018/06/09/设计模式-模版【Tempalte Method】/img/index-page-img/设计模式.png","modified":0,"renderable":0},{"_id":"source/2018/08/04/设计模式-原型【Prototype】/img/index-page-img/设计模式.png","path":"2018/08/04/设计模式-原型【Prototype】/img/index-page-img/设计模式.png","modified":0,"renderable":0},{"_id":"source/2018/08/04/设计模式-原型【Prototype】/img/设计模式-原型Prototype/UML.png","path":"2018/08/04/设计模式-原型【Prototype】/img/设计模式-原型Prototype/UML.png","modified":0,"renderable":0},{"_id":"source/2018/08/12/设计模式-适配器【Adapter】/img/index-page-img/设计模式.png","path":"2018/08/12/设计模式-适配器【Adapter】/img/index-page-img/设计模式.png","modified":0,"renderable":0},{"_id":"source/2018/08/18/设计模式-组合【Composite】/img/index-page-img/设计模式.png","path":"2018/08/18/设计模式-组合【Composite】/img/index-page-img/设计模式.png","modified":0,"renderable":0},{"_id":"source/2018/09/01/设计模式-代理【Proxy】/img/index-page-img/设计模式.png","path":"2018/09/01/设计模式-代理【Proxy】/img/index-page-img/设计模式.png","modified":0,"renderable":0},{"_id":"source/2018/10/02/spring验证框架/img/index-page-img/spring.jpg","path":"2018/10/02/spring验证框架/img/index-page-img/spring.jpg","modified":0,"renderable":0},{"_id":"source/2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/img/index-page-img/设计模式.png","path":"2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/img/index-page-img/设计模式.png","modified":0,"renderable":0},{"_id":"source/2018/11/12/设计模式-单例【Single】/img/index-page-img/设计模式.png","path":"2018/11/12/设计模式-单例【Single】/img/index-page-img/设计模式.png","modified":0,"renderable":0},{"_id":"source/2018/11/13/redis-持久化/img/index-page-img/redis.jpg","path":"2018/11/13/redis-持久化/img/index-page-img/redis.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-页面.png","path":"2018/07/07/blog-表格/img/blog-表格/blog-表格-页面.png","modified":0,"renderable":0},{"_id":"source/2018/07/22/java-CAS原理/img/java-CAS原理/物理机结构.jpg","path":"2018/07/22/java-CAS原理/img/java-CAS原理/物理机结构.jpg","modified":0,"renderable":0},{"_id":"source/2018/08/12/设计模式-适配器【Adapter】/img/设计模式-适配器Adapter/UML.png","path":"2018/08/12/设计模式-适配器【Adapter】/img/设计模式-适配器Adapter/UML.png","modified":0,"renderable":0},{"_id":"source/2018/09/01/设计模式-代理【Proxy】/img/设计模式-代理【Proxy】/UML.png","path":"2018/09/01/设计模式-代理【Proxy】/img/设计模式-代理【Proxy】/UML.png","modified":0,"renderable":0},{"_id":"source/2018/10/02/spring验证框架/img/ide空验证.png","path":"2018/10/02/spring验证框架/img/ide空验证.png","modified":0,"renderable":0},{"_id":"source/2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/img/设计模式-责任链【Chain Of Responsibility】/UML.png","path":"2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/img/设计模式-责任链【Chain Of Responsibility】/UML.png","modified":0,"renderable":0},{"_id":"source/2018/11/12/设计模式-单例【Single】/img/设计模式-责任链【Chain Of Responsibility】/UML.png","path":"2018/11/12/设计模式-单例【Single】/img/设计模式-责任链【Chain Of Responsibility】/UML.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-md源码.png","path":"2018/07/07/blog-表格/img/blog-表格/blog-表格-md源码.png","modified":0,"renderable":0},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-正确.png","path":"2018/07/07/blog-表格/img/blog-表格/blog-表格-正确.png","modified":0,"renderable":0},{"_id":"source/2018/08/18/设计模式-组合【Composite】/img/设计模式-组合Composite/UML.png","path":"2018/08/18/设计模式-组合【Composite】/img/设计模式-组合Composite/UML.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-正确md源码.png","path":"2018/07/07/blog-表格/img/blog-表格/blog-表格-正确md源码.png","modified":0,"renderable":0},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-html源码.png","path":"2018/07/07/blog-表格/img/blog-表格/blog-表格-html源码.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"8de1f39592e6a4abb3154f90cb246d7ebf224c88","modified":1541905752000},{"_id":"source/favicon.ico","hash":"a2e77dbcc4d4261d3da14452d62509cf5c82682a","modified":1541818817000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1541818817000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1541818817000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1541818817000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1541818817000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1541818817000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1541818817000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1541818817000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1541818817000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1541818817000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1541818817000},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1541818817000},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1541818817000},{"_id":"themes/next/_config.yml","hash":"5b27a6ae630e8dbbb460241e1eefc9d4c2ef7491","modified":1541818817000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1541818817000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1541818817000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1541818817000},{"_id":"source/2018/.DS_Store","hash":"b2882d26ea13c281183e85110d2f00bff8d88466","modified":1541864629000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1542195652000},{"_id":"source/_posts/Hexo、Github搭建Blog-站内搜索.md","hash":"cfa44fb419d296b884a25f6e01bdb2c28ec62a12","modified":1542186654000},{"_id":"source/_posts/Hexo、Github搭建Blog-表格.md","hash":"029bb7356ec437b74ccaed7bb9eb84cba18ba899","modified":1542186726000},{"_id":"source/_posts/Hexo、Github搭建Blog.md","hash":"6a3e3d8c9d3baead69a353253b4d1dcc9297b5a0","modified":1542186665000},{"_id":"source/_posts/docker-基础命令及使用.md","hash":"f347435772d9709b3c0bf041afb65a13136b9a22","modified":1542182604000},{"_id":"source/_posts/hello-world.md","hash":"b19b6ecdf10c329b21c390ea1bcd5053c4d988e4","modified":1542186636000},{"_id":"source/_posts/java-8-stream.md","hash":"08269427f357134e604ffb7d0208ae4bb38b3e8b","modified":1541903951000},{"_id":"source/_posts/java-CAS原理.md","hash":"124a09cb9d25fafc8f7d7db30dad19e65ce73bee","modified":1541903950000},{"_id":"source/_posts/jvm工具-greys.md","hash":"572a45b324ef7bb2ef8a0a4981f910552eeb2cf1","modified":1542179653000},{"_id":"source/_posts/redis-事务.md","hash":"c40e9a594312b13184c637a1b6af1c70a102b5c7","modified":1542193256000},{"_id":"source/_posts/redis-持久化.md","hash":"5661479f932aba89d0e806384ff2e3035ad011a7","modified":1542175559000},{"_id":"source/_posts/spring验证框架.md","hash":"fbc5634ae8681ba789c1bc84e398e2bbab1f3622","modified":1542025028000},{"_id":"source/_posts/设计模式-代理【Proxy】.md","hash":"37586680b816b35569eb42a48d0eeba96f3972d0","modified":1541903144000},{"_id":"source/_posts/设计模式-单例【Single】.md","hash":"b5eee60f51f3a98c7f65a7c2ab1dffe722e0d2cf","modified":1542026339000},{"_id":"source/_posts/设计模式-原型【Prototype】.md","hash":"5fdf6b3d9c73cc54fd3f967085c8b35ac6c01540","modified":1541903767000},{"_id":"source/_posts/设计模式-模版【Tempalte Method】.md","hash":"b1245e933f592a7e8b659789d8299a74302558a7","modified":1541903524000},{"_id":"source/_posts/设计模式-组合【Composite】.md","hash":"f564cb784687516c4122ad50b761ed1949eb9ecd","modified":1541903383000},{"_id":"source/_posts/设计模式-适配器【Adapter】.md","hash":"42c43c212b1d1f97a8d22f4ed4646045b48e45c0","modified":1541903217000},{"_id":"source/_posts/设计模式-责任链【Chain-Of-Responsibility】.md","hash":"c3f6b2bfefc914c83e3650ef5f2d2c969d933cea","modified":1541859145000},{"_id":"source/categories/index.md","hash":"ae4d15155d55ea87d0eba02c11458e2850d0288f","modified":1541818817000},{"_id":"source/img/favicon.ico","hash":"a2e77dbcc4d4261d3da14452d62509cf5c82682a","modified":1541818817000},{"_id":"source/img/.DS_Store","hash":"272f7befd76c97c9194ceb731384aa4faf7556eb","modified":1541858760000},{"_id":"source/img/hexo设置.png","hash":"4e63e6df55855456756d8b43d7cbff4fae601556","modified":1541818817000},{"_id":"source/img/模版设计模式UML.png","hash":"39637af921a5251af0642f51066a2f1568aefbb9","modified":1541818817000},{"_id":"source/page/.DS_Store","hash":"82e3fdbc5cf27a25b6f1e841bdfeb71d47ed7d27","modified":1541905365000},{"_id":"source/tags/index.md","hash":"ddcd874b6e87c66e83af507c2663533fab9af6a3","modified":1541818817000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1541818817000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1541818817000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1541818817000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1541818817000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1541818817000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1541818817000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1541818817000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1541818817000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1541818817000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1541818817000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1541818817000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1541818817000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1541818817000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1541818817000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1541818817000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1541818817000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1541818817000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1541818817000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1541818817000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1541818817000},{"_id":"themes/next/layout/_layout.swig","hash":"bff3fbe7573556b6a24185087e01958414e3bbe5","modified":1541818817000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1541818817000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1541818817000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1541818817000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1541818817000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1541818817000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1541818817000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1541818817000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1541818817000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1541818817000},{"_id":"themes/next/source/favicon.ico","hash":"a2e77dbcc4d4261d3da14452d62509cf5c82682a","modified":1541818817000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1541818817000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1541818817000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1541818817000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541818817000},{"_id":"source/2018/07/.DS_Store","hash":"838efefb37bf1ab49420370fcf3ceaced9e8b16d","modified":1541904002000},{"_id":"source/2018/06/.DS_Store","hash":"0c115ed418cc469eecd151986c022c07bc230379","modified":1541818817000},{"_id":"source/2018/08/.DS_Store","hash":"6342e6e3afb8a85662d80835ead189516c6577aa","modified":1541903396000},{"_id":"source/2018/10/.DS_Store","hash":"a75f3267a4363156897d4f0dd640d260640ca44e","modified":1541864646000},{"_id":"source/2018/11/.DS_Store","hash":"5a184b7f26065e4e0caf80dc3e742571f72e89fb","modified":1542167797000},{"_id":"source/img/blog-表格/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541818817000},{"_id":"source/img/index-page-img/blog.jpg","hash":"c5f8d1f7cc50af11f057fe81ba5666266384dec8","modified":1542097950000},{"_id":"source/img/index-page-img/docker.jpeg","hash":"acf2610ba107d82d02a6faf0eedacb14c5b29a1f","modified":1542178042000},{"_id":"source/img/index-page-img/java.png","hash":"7fbeac45daf0a47cc60d96cefcf2812f83547900","modified":1538983797000},{"_id":"source/img/index-page-img/redis.jpg","hash":"ba297df82e957d8589adcb72930da6249132bfa1","modified":1542168626000},{"_id":"source/img/index-page-img/spring.jpg","hash":"938af3e3bf1e48fb61aa7bddfb4bb5bcbf1a37eb","modified":1541858611000},{"_id":"source/img/index-page-img/设计模式.png","hash":"b0e95e9d76b8544868c053bb7d01f256227bab48","modified":1538983418000},{"_id":"source/img/创建账号.jpg","hash":"19e55caf5806cb68ff22bb93b783fdf39e2af553","modified":1541818817000},{"_id":"source/img/设置pages.png","hash":"34b838a6cd3ae611ff7829cb01a23e267436b17b","modified":1541818817000},{"_id":"source/img/设计模式-责任链【Chain Of Responsibility】/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541858034000},{"_id":"source/img/设计模式-原型Prototype/UML_Prototype.mdj","hash":"a95b48139700df959aa3f3449a726af10a342cf3","modified":1541818817000},{"_id":"source/img/设计模式-原型Prototype/UML.png","hash":"a37277e7fb19bc5ee21823f7aadab9123b545130","modified":1541818817000},{"_id":"source/img/设计模式-责任链【Chain Of Responsibility】/Untitled.mdj","hash":"9c13a94874d81adbb1257519cf5f3c5d0f57595c","modified":1541991090000},{"_id":"source/page/2/.DS_Store","hash":"8983992a301632f377142eb0de9b7125c7a7c97a","modified":1541904115000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541818817000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541818817000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1541818817000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1541818817000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1541818817000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1541818817000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1541818817000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1541818817000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1541818817000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1541818817000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1541818817000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1541818817000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1541818817000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1541818817000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1541818817000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1541818817000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1541818817000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1541818817000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1541818817000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1541818817000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1541818817000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1541818817000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1541818817000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1541818817000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1541818817000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1541818817000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1541818817000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1541818817000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1541818817000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1541818817000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1541818817000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1541818817000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1541818817000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1541818817000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1541818817000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1541818817000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1541818817000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1541818817000},{"_id":"themes/next/source/images/avatar.JPG","hash":"5eee179b1bcdd79821b687a9bd9ea1b6816e837c","modified":1541818817000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1541818817000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1541818817000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1541818817000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1541818817000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1541818817000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1541818817000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1541818817000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1541818817000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1541818817000},{"_id":"themes/next/source/images/favicon.ico","hash":"a2e77dbcc4d4261d3da14452d62509cf5c82682a","modified":1541818817000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541818817000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1541818817000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541818817000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1541818817000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1541818817000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1541818817000},{"_id":"source/img/blog-表格/blog-表格-页面.png","hash":"f3cb030d2bdf17433cb9b84011575d49286a9959","modified":1541818817000},{"_id":"source/img/java CAS原理/物理机结构.jpg","hash":"1da9193564a005ec0ea01d5293123eda45b97f66","modified":1541818817000},{"_id":"source/img/设计模式-代理【Proxy】/UML.png","hash":"cb7ba32f587b2c5e0ab15aa55bd10a29668ec24b","modified":1541818817000},{"_id":"source/img/设计模式-责任链【Chain Of Responsibility】/UML.png","hash":"38e1ba77f89c47b70791e339c1e1df7116dca34e","modified":1541857830000},{"_id":"source/img/设计模式-适配器Adapter/UML.png","hash":"1f5f60692c1950a29e989330572a47688ada4383","modified":1541818817000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541818817000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541818817000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541818817000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541818817000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541818817000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541818817000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541818817000},{"_id":"themes/next/source/images/IMG_0001.JPG","hash":"9a75e125564266756aeb3cbcd6eb329927705cad","modified":1541818817000},{"_id":"source/2018/07/07/.DS_Store","hash":"c5373974764ea359c08b83f87bbe4c11858fcd56","modified":1541904192000},{"_id":"source/2018/07/14/.DS_Store","hash":"883e6b29588805fcd115171c901e997896f11381","modified":1541904049000},{"_id":"source/2018/06/03/.DS_Store","hash":"a6cf0674c2fe5dcf5d120c3e3dcc7de1c62fc45a","modified":1541818817000},{"_id":"source/2018/06/09/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541818817000},{"_id":"source/2018/08/04/.DS_Store","hash":"86792bd8fc9fead8a2a58a83453327f0e050b94c","modified":1541818817000},{"_id":"source/2018/08/12/.DS_Store","hash":"35989e3234e3d12eb11f8dff71980773d9dbccab","modified":1541818817000},{"_id":"source/2018/10/02/.DS_Store","hash":"961443cff2078b4009fef781afca82bfc8e803d6","modified":1541864945000},{"_id":"source/2018/11/10/.DS_Store","hash":"f50f2dd4b58263592fc47525031a402860214d88","modified":1542025706000},{"_id":"source/2018/11/12/.DS_Store","hash":"f8d1dfce66370deb53f4aac42452860e79b45965","modified":1542025759000},{"_id":"source/2018/11/13/.DS_Store","hash":"825386a5cb950ac3429c9258a51da0569beeb6ec","modified":1542167802000},{"_id":"source/img/blog-表格/blog-表格-正确.png","hash":"a5fa861122029ba54410c6b93fc9bd2e26873343","modified":1541818817000},{"_id":"source/img/blog-表格/blog-表格-md源码.png","hash":"632d358ffdee3d0415a32fe7d3dd0a95b42151a7","modified":1541818817000},{"_id":"source/img/设计模式-模版方法Template/模版设计模式UML.png","hash":"d6c7d06b50fd9fb43979b97330c5fb16fead8d7b","modified":1541818817000},{"_id":"source/img/设计模式-组合Composite/UML.png","hash":"d6c7d06b50fd9fb43979b97330c5fb16fead8d7b","modified":1541818817000},{"_id":"source/page/2/img/.DS_Store","hash":"3851159f32803d213958d30aecef3194511c0f4b","modified":1541905747000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1541818817000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1541818817000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1541818817000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1541818817000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1541818817000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1541818817000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1541818817000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1541818817000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1541818817000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1541818817000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1541818817000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1541818817000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1541818817000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1541818817000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1541818817000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1541818817000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1541818817000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1541818817000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1541818817000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1541818817000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1541818817000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1541818817000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1541818817000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1541818817000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1541818817000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1541818817000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1541818817000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1541818817000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1541818817000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1541818817000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1541818817000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1541818817000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1541818817000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1541818817000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1541818817000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1541818817000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1541818817000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1541818817000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1541818817000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1541818817000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1541818817000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1541818817000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1541818817000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1541818817000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1541818817000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1541818817000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1541818817000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1541818817000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1541818817000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1541818817000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1541818817000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1541818817000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1541818817000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1541818817000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1541818817000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1541818817000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1541818817000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1541818817000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1541818817000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1541818817000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1541818817000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1541818817000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1541818817000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1541818817000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1541818817000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1541818817000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1541818817000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1541818817000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1541818817000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1541818817000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1541818817000},{"_id":"source/img/blog-表格/blog-表格-正确md源码.png","hash":"14405d26c48b69195a73dc94c5fa8c697ad81d47","modified":1541818817000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1541818817000},{"_id":"source/2018/07/07/blog-表格/.DS_Store","hash":"268d767d20a7cba80ca6507c81182edf65ad6e24","modified":1541818817000},{"_id":"source/2018/07/07/java-8-stream/.DS_Store","hash":"ba355d6abb1622301a188b07ab171accf83c82ec","modified":1541904194000},{"_id":"source/2018/07/14/jvm工具-greys/.DS_Store","hash":"55c871398b53bcf02eac7bfe04fd1120e9383836","modified":1541904056000},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/.DS_Store","hash":"4ce4773ae33431d8394f47dce82057e07d189793","modified":1541818817000},{"_id":"source/2018/06/09/设计模式-模版【Tempalte Method】/.DS_Store","hash":"137a7a3787fc234f2a82cd178e2bb6dc07733375","modified":1541818817000},{"_id":"source/2018/08/04/设计模式-原型【Prototype】/.DS_Store","hash":"8080ee748c6431fa8c8dd5ddfe15c6778f862dbf","modified":1541818817000},{"_id":"source/2018/08/12/设计模式-适配器【Adapter】/.DS_Store","hash":"039d079661ec2f32c4872355fd61a2f8c8d53c30","modified":1541818817000},{"_id":"source/2018/08/18/设计模式-组合【Composite】/.DS_Store","hash":"c813309f534646feaa898bd9a3e9e97a17d4875c","modified":1541818817000},{"_id":"source/2018/10/02/spring验证框架/.DS_Store","hash":"894e305793a0e65d4e9e8c9b666af77ba55775cd","modified":1541865261000},{"_id":"source/2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/.DS_Store","hash":"5835a0beee7e6fd688b4193f5eaf3219fc48714e","modified":1541839861000},{"_id":"source/2018/11/12/设计模式-单例【Single】/.DS_Store","hash":"5835a0beee7e6fd688b4193f5eaf3219fc48714e","modified":1542025773000},{"_id":"source/2018/11/13/redis-持久化/.DS_Store","hash":"8d8a690564d4d79b7e99cb173bc2c3d2194e2642","modified":1542167853000},{"_id":"source/page/2/img/index-page-img/blog.jpg","hash":"c5f8d1f7cc50af11f057fe81ba5666266384dec8","modified":1542097950000},{"_id":"source/page/2/img/index-page-img/docker.jpeg","hash":"acf2610ba107d82d02a6faf0eedacb14c5b29a1f","modified":1542178042000},{"_id":"source/page/2/img/index-page-img/spring.jpg","hash":"938af3e3bf1e48fb61aa7bddfb4bb5bcbf1a37eb","modified":1541858611000},{"_id":"source/page/2/img/index-page-img/redis.jpg","hash":"ba297df82e957d8589adcb72930da6249132bfa1","modified":1542168626000},{"_id":"source/page/2/img/index-page-img/java.png","hash":"7fbeac45daf0a47cc60d96cefcf2812f83547900","modified":1538983797000},{"_id":"source/page/2/img/index-page-img/设计模式.png","hash":"b0e95e9d76b8544868c053bb7d01f256227bab48","modified":1538983418000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1541818817000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1541818817000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1541818817000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1541818817000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1541818817000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1541818817000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1541818817000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1541818817000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1541818817000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1541818817000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1541818817000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1541818817000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1541818817000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1541818817000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1541818817000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1541818817000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1541818817000},{"_id":"source/img/blog-表格/blog-表格-html源码.png","hash":"86495eda25055fc91a0db57ef929fb3a9442cce5","modified":1541818817000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1541818817000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1541818817000},{"_id":"source/2018/07/07/blog-表格/img/.DS_Store","hash":"3851159f32803d213958d30aecef3194511c0f4b","modified":1542176885000},{"_id":"source/2018/07/07/java-8-stream/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541905132000},{"_id":"source/2018/07/14/jvm工具-greys/img/.DS_Store","hash":"3851159f32803d213958d30aecef3194511c0f4b","modified":1541904051000},{"_id":"source/2018/07/22/java-CAS原理/img/.DS_Store","hash":"3851159f32803d213958d30aecef3194511c0f4b","modified":1541903836000},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/.DS_Store","hash":"3851159f32803d213958d30aecef3194511c0f4b","modified":1542176866000},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/hexo设置.png","hash":"4e63e6df55855456756d8b43d7cbff4fae601556","modified":1541818817000},{"_id":"source/2018/06/09/设计模式-模版【Tempalte Method】/img/.DS_Store","hash":"da5f7603710d393be4df0b9221bbf2b9b46a7332","modified":1541903417000},{"_id":"source/2018/06/09/设计模式-模版【Tempalte Method】/img/模版设计模式UML.png","hash":"39637af921a5251af0642f51066a2f1568aefbb9","modified":1541818817000},{"_id":"source/2018/08/04/设计模式-原型【Prototype】/img/.DS_Store","hash":"b16a7e34ef3339e5004ac872f3a38a0c3c0d37d6","modified":1541903412000},{"_id":"source/2018/08/12/设计模式-适配器【Adapter】/img/.DS_Store","hash":"60cbd120d4cddbbfce73db8ab07a3b5071c93c33","modified":1541903262000},{"_id":"source/2018/08/18/设计模式-组合【Composite】/img/.DS_Store","hash":"3851159f32803d213958d30aecef3194511c0f4b","modified":1541903399000},{"_id":"source/2018/09/01/设计模式-代理【Proxy】/img/.DS_Store","hash":"3851159f32803d213958d30aecef3194511c0f4b","modified":1541902977000},{"_id":"source/2018/10/02/spring验证框架/img/.DS_Store","hash":"c1b236abca0fc4f3b5c47bc6042957933b734688","modified":1541865009000},{"_id":"source/2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/img/.DS_Store","hash":"ee60b96a45b8f5f669dafe7a8fddbfd4d2239253","modified":1541859247000},{"_id":"source/2018/11/12/设计模式-单例【Single】/img/.DS_Store","hash":"ee60b96a45b8f5f669dafe7a8fddbfd4d2239253","modified":1541859247000},{"_id":"source/2018/11/13/redis-持久化/img/.DS_Store","hash":"3851159f32803d213958d30aecef3194511c0f4b","modified":1542167848000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1541818817000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541818817000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541818817000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1541818817000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1541818817000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1541818817000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1541818817000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1541818817000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1541818817000},{"_id":"source/2018/07/22/img/java-CAS原理/物理机结构.jpg","hash":"1da9193564a005ec0ea01d5293123eda45b97f66","modified":1541818817000},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541818817000},{"_id":"source/2018/07/07/blog-表格/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1542176892000},{"_id":"source/2018/07/07/blog-表格/img/index-page-img/blog.jpg","hash":"c5f8d1f7cc50af11f057fe81ba5666266384dec8","modified":1542097950000},{"_id":"source/2018/07/07/java-8-stream/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541903843000},{"_id":"source/2018/07/07/java-8-stream/img/index-page-img/java.png","hash":"7fbeac45daf0a47cc60d96cefcf2812f83547900","modified":1538983797000},{"_id":"source/2018/07/14/jvm工具-greys/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541903843000},{"_id":"source/2018/07/14/jvm工具-greys/img/index-page-img/java.png","hash":"7fbeac45daf0a47cc60d96cefcf2812f83547900","modified":1538983797000},{"_id":"source/2018/07/22/java-CAS原理/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541903843000},{"_id":"source/2018/07/22/java-CAS原理/img/index-page-img/java.png","hash":"7fbeac45daf0a47cc60d96cefcf2812f83547900","modified":1538983797000},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1542176872000},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/index-page-img/blog.jpg","hash":"c5f8d1f7cc50af11f057fe81ba5666266384dec8","modified":1542097950000},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/创建账号.jpg","hash":"19e55caf5806cb68ff22bb93b783fdf39e2af553","modified":1541818817000},{"_id":"source/2018/06/03/Hexo、Github搭建Blog/img/设置pages.png","hash":"34b838a6cd3ae611ff7829cb01a23e267436b17b","modified":1541818817000},{"_id":"source/2018/06/09/设计模式-模版【Tempalte Method】/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541859256000},{"_id":"source/2018/06/09/设计模式-模版【Tempalte Method】/img/设计模式-模版方法Template/模版设计模式UML.png","hash":"39637af921a5251af0642f51066a2f1568aefbb9","modified":1541818817000},{"_id":"source/2018/06/09/设计模式-模版【Tempalte Method】/img/index-page-img/设计模式.png","hash":"b0e95e9d76b8544868c053bb7d01f256227bab48","modified":1538983418000},{"_id":"source/2018/08/04/设计模式-原型【Prototype】/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541859256000},{"_id":"source/2018/08/04/设计模式-原型【Prototype】/img/index-page-img/设计模式.png","hash":"b0e95e9d76b8544868c053bb7d01f256227bab48","modified":1538983418000},{"_id":"source/2018/08/04/设计模式-原型【Prototype】/img/设计模式-原型Prototype/UML.png","hash":"a37277e7fb19bc5ee21823f7aadab9123b545130","modified":1541818817000},{"_id":"source/2018/08/12/设计模式-适配器【Adapter】/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541859256000},{"_id":"source/2018/08/12/设计模式-适配器【Adapter】/img/index-page-img/设计模式.png","hash":"b0e95e9d76b8544868c053bb7d01f256227bab48","modified":1538983418000},{"_id":"source/2018/08/18/设计模式-组合【Composite】/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541859256000},{"_id":"source/2018/08/18/设计模式-组合【Composite】/img/index-page-img/设计模式.png","hash":"b0e95e9d76b8544868c053bb7d01f256227bab48","modified":1538983418000},{"_id":"source/2018/09/01/设计模式-代理【Proxy】/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541859256000},{"_id":"source/2018/09/01/设计模式-代理【Proxy】/img/index-page-img/设计模式.png","hash":"b0e95e9d76b8544868c053bb7d01f256227bab48","modified":1538983418000},{"_id":"source/2018/10/02/spring验证框架/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541865165000},{"_id":"source/2018/10/02/spring验证框架/img/index-page-img/spring.jpg","hash":"938af3e3bf1e48fb61aa7bddfb4bb5bcbf1a37eb","modified":1541858611000},{"_id":"source/2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541859256000},{"_id":"source/2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/img/index-page-img/设计模式.png","hash":"b0e95e9d76b8544868c053bb7d01f256227bab48","modified":1538983418000},{"_id":"source/2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/img/设计模式-责任链【Chain Of Responsibility】/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541839863000},{"_id":"source/2018/11/12/设计模式-单例【Single】/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541859256000},{"_id":"source/2018/11/12/设计模式-单例【Single】/img/index-page-img/设计模式.png","hash":"b0e95e9d76b8544868c053bb7d01f256227bab48","modified":1538983418000},{"_id":"source/2018/11/12/设计模式-单例【Single】/img/设计模式-责任链【Chain Of Responsibility】/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1541839863000},{"_id":"source/2018/11/13/redis-持久化/img/index-page-img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1542167827000},{"_id":"source/2018/11/13/redis-持久化/img/index-page-img/redis.jpg","hash":"ba297df82e957d8589adcb72930da6249132bfa1","modified":1542168626000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1541818817000},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-页面.png","hash":"f3cb030d2bdf17433cb9b84011575d49286a9959","modified":1541818817000},{"_id":"source/2018/07/22/java-CAS原理/img/java-CAS原理/物理机结构.jpg","hash":"1da9193564a005ec0ea01d5293123eda45b97f66","modified":1541818817000},{"_id":"source/2018/08/12/设计模式-适配器【Adapter】/img/设计模式-适配器Adapter/UML.png","hash":"1f5f60692c1950a29e989330572a47688ada4383","modified":1541818817000},{"_id":"source/2018/09/01/设计模式-代理【Proxy】/img/设计模式-代理【Proxy】/UML.png","hash":"cb7ba32f587b2c5e0ab15aa55bd10a29668ec24b","modified":1541818817000},{"_id":"source/2018/10/02/spring验证框架/img/ide空验证.png","hash":"685b971b1605f1336591db9e20765d7b4e74f7a8","modified":1539661362000},{"_id":"source/2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/img/设计模式-责任链【Chain Of Responsibility】/UML.png","hash":"38e1ba77f89c47b70791e339c1e1df7116dca34e","modified":1541857830000},{"_id":"source/2018/11/12/设计模式-单例【Single】/img/设计模式-责任链【Chain Of Responsibility】/UML.png","hash":"38e1ba77f89c47b70791e339c1e1df7116dca34e","modified":1541857830000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1541818817000},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-md源码.png","hash":"632d358ffdee3d0415a32fe7d3dd0a95b42151a7","modified":1541818817000},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-正确.png","hash":"a5fa861122029ba54410c6b93fc9bd2e26873343","modified":1541818817000},{"_id":"source/2018/08/18/设计模式-组合【Composite】/img/设计模式-组合Composite/UML.png","hash":"d6c7d06b50fd9fb43979b97330c5fb16fead8d7b","modified":1541818817000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1541818817000},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-正确md源码.png","hash":"14405d26c48b69195a73dc94c5fa8c697ad81d47","modified":1541818817000},{"_id":"source/2018/07/07/blog-表格/img/blog-表格/blog-表格-html源码.png","hash":"86495eda25055fc91a0db57ef929fb3a9442cce5","modified":1541818817000},{"_id":"public/search.xml","hash":"f0190efb1d1971821fb3ca38f33159ed4134352e","modified":1551447643058},{"_id":"public/categories/index.html","hash":"a473afe0eb293905fa28c3e699d18fb3e65ef6a3","modified":1551447643179},{"_id":"public/tags/index.html","hash":"2cdee84fb50eccb09c7870c068e2327222b31d4c","modified":1551447643179},{"_id":"public/2018/11/14/redis-事务/index.html","hash":"89e6fbe78f9b41e0172c7742415e585046b0939d","modified":1551447643179},{"_id":"public/2018/11/13/redis-持久化/index.html","hash":"1e60489998fea23a7b7cde1a5af2730e3f5191bf","modified":1551447643179},{"_id":"public/2018/11/12/设计模式-单例【Single】/index.html","hash":"831bc29aa29830275d37e73d9957330f4387b54e","modified":1551447643180},{"_id":"public/2018/11/10/设计模式-责任链【Chain-Of-Responsibility】/index.html","hash":"6107d5343a71c2d74d11368693357935b08cd574","modified":1551447643180},{"_id":"public/2018/10/02/spring验证框架/index.html","hash":"a2c1359bfa66f0554c771c8e184c65bb605150a4","modified":1551447643180},{"_id":"public/2018/09/14/docker-基础命令及使用/index.html","hash":"d0e98ae715e0949a070eedd977912b608e5d1c43","modified":1551447643180},{"_id":"public/2018/09/01/设计模式-代理【Proxy】/index.html","hash":"610c997e8c24394eaa1bc115f241218f638cb6aa","modified":1551447643180},{"_id":"public/2018/08/18/设计模式-组合【Composite】/index.html","hash":"e663df8130f49df87610e977455252ab608424c6","modified":1551447643180},{"_id":"public/2018/08/12/设计模式-适配器【Adapter】/index.html","hash":"7343d8feb7aed861ab6adf2a35a14a9176e6fe1b","modified":1551447643180},{"_id":"public/2018/08/04/设计模式-原型【Prototype】/index.html","hash":"199fb38bc4fd2c0c6e7ddef74dd92b58fe5d1dc9","modified":1551447643180},{"_id":"public/2018/07/22/java-CAS原理/index.html","hash":"61aa229da17d187eef26d73573f04587dc1c8c4d","modified":1551447643180},{"_id":"public/2018/07/14/jvm工具-greys/index.html","hash":"bf3f6f4432a11f0a3a31c3fc0ff884943f60e10d","modified":1551447643180},{"_id":"public/2018/07/07/java-8-stream/index.html","hash":"9055cf0b5b75f0ef18f651c66f8849c706b1f22e","modified":1551447643180},{"_id":"public/2018/06/09/设计模式-模版【Tempalte Method】/index.html","hash":"0389749e11604aecea755326c37f239e1ff75b03","modified":1551447643180},{"_id":"public/2018/03/10/Hexo、Github搭建Blog/index.html","hash":"08e98ef5bbead1ca5cdeb24f844b535fa2767917","modified":1551447643180},{"_id":"public/2018/03/07/Hexo、Github搭建Blog-表格/index.html","hash":"58f835c9c0f50900acd411ebb2527052c3303f7b","modified":1551447643180},{"_id":"public/2018/03/04/Hexo、Github搭建Blog-站内搜索/index.html","hash":"2f1f014a14ec13856f8388cf60711fd9336b6c27","modified":1551447643180},{"_id":"public/2018/02/17/hello-world/index.html","hash":"925f267eba08add43ba0687b1dc974edd1cb1d1d","modified":1551447643180},{"_id":"public/archives/index.html","hash":"abada3f758afabaedc4e179f92e464369bff3133","modified":1551447643180},{"_id":"public/archives/page/2/index.html","hash":"33ac073c52dfbeaad59a86e87852a872a8079904","modified":1551447643180},{"_id":"public/archives/2018/index.html","hash":"1214621061136ab3bf00f7813837f06fa8162357","modified":1551447643180},{"_id":"public/archives/2018/page/2/index.html","hash":"032c68f7ac1a85905fdcc3ed2dab243a45c11485","modified":1551447643180},{"_id":"public/archives/2018/02/index.html","hash":"3006475f4d8fe52a3d2c470f7bc393e1c27c877d","modified":1551447643180},{"_id":"public/archives/2018/03/index.html","hash":"10c93cf04a0335811b7a5e8901cdd89025fd987f","modified":1551447643180},{"_id":"public/archives/2018/06/index.html","hash":"fd2e3f91b74c31796c8b90a5e3794c54fe64899b","modified":1551447643180},{"_id":"public/archives/2018/07/index.html","hash":"b8fcccc80a8738358593180ae9849dbf6acebed0","modified":1551447643180},{"_id":"public/archives/2018/08/index.html","hash":"4e92389797da6f9a91566828a6d5e11b1904f12c","modified":1551447643180},{"_id":"public/archives/2018/09/index.html","hash":"9f48752367553906604d3256d8fc63c64c6afcd5","modified":1551447643180},{"_id":"public/archives/2018/10/index.html","hash":"d832d68644992c156ee99dc4340126d9504b68a8","modified":1551447643181},{"_id":"public/archives/2018/11/index.html","hash":"ece4bb7100e7c91f4ec01c844f9c0d3777dfe448","modified":1551447643181},{"_id":"public/categories/blog/index.html","hash":"47d7b05662739e4815288dc35901e4f090ec81aa","modified":1551447643181},{"_id":"public/categories/docker/index.html","hash":"e619895a35250f8880af0f10b961b89217659165","modified":1551447643181},{"_id":"public/categories/jvm/index.html","hash":"6226e7bfeb5490aab75526f5fea505f54f399c8e","modified":1551447643181},{"_id":"public/categories/java8/index.html","hash":"fc86ecbeed8dd0c794c4dfe4f382e724d6b1e25f","modified":1551447643181},{"_id":"public/categories/redis/index.html","hash":"41ac0bea7eded23bb428f51f78ae587c2d254734","modified":1551447643181},{"_id":"public/categories/spring/index.html","hash":"85e008841d64e4d6036d1642019949a76b670506","modified":1551447643181},{"_id":"public/index.html","hash":"57d0b67a0b06cdcda6db4aafb33bf273ac2d6ea3","modified":1551447643181},{"_id":"public/categories/设计模式/index.html","hash":"fe326f4e3d4c55a40a7b43bb11d86dd840698ab5","modified":1551447643181},{"_id":"public/page/2/index.html","hash":"28afda2c8a7d28aa1a2f2e011f28141bd7a927b5","modified":1551447643181},{"_id":"public/tags/blog/index.html","hash":"43f4e640a59df41bf36948d53843cab3c450cf3d","modified":1551447643181},{"_id":"public/tags/docker/index.html","hash":"733cde9ddc68f15ad0d50cfb045294227e3b1362","modified":1551447643181},{"_id":"public/tags/jvm/index.html","hash":"9a8dbdef2e7c5d218c1457623d588ea5782bf858","modified":1551447643181},{"_id":"public/tags/java8/index.html","hash":"a624dae990124919bdf689c1a5b82e417a4736cf","modified":1551447643181},{"_id":"public/tags/redis/index.html","hash":"4eeccb494db3922eed1125f12d6488bb2696bb5b","modified":1551447643181},{"_id":"public/tags/spring/index.html","hash":"d8f4d024101b6b4e5f454e3a131153a796fc4732","modified":1551447643183},{"_id":"public/tags/设计模式/index.html","hash":"3c02fc9cdb8af27b9a3a13d1fce0622cf646f572","modified":1551447643183}],"Category":[{"name":"blog","_id":"cjsq3synd000343xrmsf8xjfv"},{"name":"docker","_id":"cjsq3synz000l43xr3o53vdrk"},{"name":"jvm","_id":"cjsq3syo2000s43xrsksgenah"},{"name":"java8","_id":"cjsq3syo6000y43xrowy7lf10"},{"name":"redis","_id":"cjsq3syod001943xrlormwxrx"},{"name":"spring","_id":"cjsq3syof001i43xrf26xm6oa"},{"name":"设计模式","_id":"cjsq3syoh001n43xrwbsox0r3"}],"Data":[],"Page":[{"title":"文章分类","date":"2018-06-03T16:00:00.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-06-04 00:00:00\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-11-10T03:00:17.000Z","path":"categories/index.html","layout":"page","_id":"cjsq3syn8000143xrdzw6eykf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-06-03T16:00:00.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-06-04 00:00:00\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-11-10T03:00:17.000Z","path":"tags/index.html","layout":"page","_id":"cjsq3sysk002h43xrc39f18u1","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hexo、Github搭建Blog--站内搜索","date":"2018-03-04T14:45:51.000Z","type":"categories","_content":"\n![](img/index-page-img/blog.jpg)\n\n<!-- more -->\n\n\n### 安装\n站内搜索主要是通过集成插件的方式实现，步骤如下：\t\t\n1. 安装 hexo-generator-search\t\t\n\t在站点的根目录下执行以下命令：\t\t\n`$ npm install hexo-generator-search --save`\t\n2.\t启用搜索\t\t\n\t编辑blog 根目录_config.yaml:\t\n\t<pre class=“prettyprint”>\n\tsearch:\n\t path: search.xml\n\t field: post\n\t format: html\n\t limit: 10000\n\t</pre>","source":"_posts/Hexo、Github搭建Blog-站内搜索.md","raw":"---\ntitle: Hexo、Github搭建Blog--站内搜索\ndate: 2018-03-04 22:45:51\ntype: \"categories\"\ncategories: blog\ntags: blog\n---\n\n![](img/index-page-img/blog.jpg)\n\n<!-- more -->\n\n\n### 安装\n站内搜索主要是通过集成插件的方式实现，步骤如下：\t\t\n1. 安装 hexo-generator-search\t\t\n\t在站点的根目录下执行以下命令：\t\t\n`$ npm install hexo-generator-search --save`\t\n2.\t启用搜索\t\t\n\t编辑blog 根目录_config.yaml:\t\n\t<pre class=“prettyprint”>\n\tsearch:\n\t path: search.xml\n\t field: post\n\t format: html\n\t limit: 10000\n\t</pre>","slug":"Hexo、Github搭建Blog-站内搜索","published":1,"updated":"2018-11-14T09:10:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syn3000043xrs6cxqbv4","content":"<p><img src=\"img/index-page-img/blog.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>站内搜索主要是通过集成插件的方式实现，步骤如下：        </p>\n<ol>\n<li>安装 hexo-generator-search<br> 在站点的根目录下执行以下命令：<br><code>$ npm install hexo-generator-search --save</code>    </li>\n<li>启用搜索<br>编辑blog 根目录_config.yaml:    <pre class=\"“prettyprint”\">\nsearch:\npath: search.xml\nfield: post\nformat: html\nlimit: 10000\n</pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/blog.jpg\" alt=\"\"></p>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>站内搜索主要是通过集成插件的方式实现，步骤如下：        </p>\n<ol>\n<li>安装 hexo-generator-search<br> 在站点的根目录下执行以下命令：<br><code>$ npm install hexo-generator-search --save</code>    </li>\n<li>启用搜索<br>编辑blog 根目录_config.yaml:    <pre class=\"“prettyprint”\">\nsearch:\npath: search.xml\nfield: post\nformat: html\nlimit: 10000\n</pre></li>\n</ol>"},{"title":"Hexo、Github搭建Blog-表格","date":"2018-03-07T11:27:38.000Z","type":"categories","_content":"\n![](img/index-page-img/blog.jpg)\n\n<!-- more -->\n\n\n### blog-md表格\n\n今天写blog的时候，想写一个表格，就是网上百度了一下，md表格的语法。\n\n```\n| 水果        | 价格    |  数量  |\n| :--------: | :-----  | :----: |\n| 香蕉        | $1      |   5    |\n| 苹果        | $1      |   6    |\n| 草莓        | $1      |   7    |\n\n```\n这个是md的语法，效果是这样的。\n\n| 水果        | 价格    |  数量   |\n| :--------: | :-----  | :----: |\n| 香蕉        | $1      |   5    |\n| 苹果        | $1      |   6    |\n| 草莓        | $1      |   7    |\n\n但是我的需求是这样的需要可以合并单元格的，最后才知道md暂不支持合并单元格。但是md是支持html的，html当然是支持合并单元格的。所以想要有合并单元格需求的时候，可以使用html来写表格。但是写html的时候也需要到其他的坑。\t\t\n下图为现象\t\t\n![](img/blog-表格/blog-表格-页面.png)\t\t\n下图为html源码\t\t\n![](img/blog-表格/blog-表格-html源码.png)\t\t\n下图为md源码\t\t\n![](img/blog-表格/blog-表格-md源码.png)\n可能是md源码中有**换行符**的问题，导致解析出问题，多了好多`<br>`，我把所有的格式都去掉了，就可以了。\t\n下图为修改完的格式\t\t\n![](img/blog-表格/blog-表格-正确.png)\t\t\n下午为修改后的md源码\t\t\n![](img/blog-表格/blog-表格-正确md源码.png)\n\n\n","source":"_posts/Hexo、Github搭建Blog-表格.md","raw":"---\ntitle: Hexo、Github搭建Blog-表格\ndate: 2018-03-07 19:27:38\ntype: \"categories\"\ncategories: blog\ntags: blog\n---\n\n![](img/index-page-img/blog.jpg)\n\n<!-- more -->\n\n\n### blog-md表格\n\n今天写blog的时候，想写一个表格，就是网上百度了一下，md表格的语法。\n\n```\n| 水果        | 价格    |  数量  |\n| :--------: | :-----  | :----: |\n| 香蕉        | $1      |   5    |\n| 苹果        | $1      |   6    |\n| 草莓        | $1      |   7    |\n\n```\n这个是md的语法，效果是这样的。\n\n| 水果        | 价格    |  数量   |\n| :--------: | :-----  | :----: |\n| 香蕉        | $1      |   5    |\n| 苹果        | $1      |   6    |\n| 草莓        | $1      |   7    |\n\n但是我的需求是这样的需要可以合并单元格的，最后才知道md暂不支持合并单元格。但是md是支持html的，html当然是支持合并单元格的。所以想要有合并单元格需求的时候，可以使用html来写表格。但是写html的时候也需要到其他的坑。\t\t\n下图为现象\t\t\n![](img/blog-表格/blog-表格-页面.png)\t\t\n下图为html源码\t\t\n![](img/blog-表格/blog-表格-html源码.png)\t\t\n下图为md源码\t\t\n![](img/blog-表格/blog-表格-md源码.png)\n可能是md源码中有**换行符**的问题，导致解析出问题，多了好多`<br>`，我把所有的格式都去掉了，就可以了。\t\n下图为修改完的格式\t\t\n![](img/blog-表格/blog-表格-正确.png)\t\t\n下午为修改后的md源码\t\t\n![](img/blog-表格/blog-表格-正确md源码.png)\n\n\n","slug":"Hexo、Github搭建Blog-表格","published":1,"updated":"2018-11-14T09:12:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syna000243xrf7xqlswi","content":"<p><img src=\"img/index-page-img/blog.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"blog-md表格\"><a href=\"#blog-md表格\" class=\"headerlink\" title=\"blog-md表格\"></a>blog-md表格</h3><p>今天写blog的时候，想写一个表格，就是网上百度了一下，md表格的语法。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 水果        | 价格    |  数量  |</span><br><span class=\"line\">| <span class=\"symbol\">:--------</span>: | <span class=\"symbol\">:-----</span>  | <span class=\"symbol\">:----</span>: |</span><br><span class=\"line\">| 香蕉        | <span class=\"variable\">$1</span>      |   <span class=\"number\">5</span>    |</span><br><span class=\"line\">| 苹果        | <span class=\"variable\">$1</span>      |   <span class=\"number\">6</span>    |</span><br><span class=\"line\">| 草莓        | <span class=\"variable\">$1</span>      |   <span class=\"number\">7</span>    |</span><br></pre></td></tr></table></figure>\n<p>这个是md的语法，效果是这样的。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">水果</th>\n<th style=\"text-align:left\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">香蕉</td>\n<td style=\"text-align:left\">$1</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">苹果</td>\n<td style=\"text-align:left\">$1</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">草莓</td>\n<td style=\"text-align:left\">$1</td>\n<td style=\"text-align:center\">7</td>\n</tr>\n</tbody>\n</table>\n<p>但是我的需求是这样的需要可以合并单元格的，最后才知道md暂不支持合并单元格。但是md是支持html的，html当然是支持合并单元格的。所以想要有合并单元格需求的时候，可以使用html来写表格。但是写html的时候也需要到其他的坑。<br>下图为现象<br><img src=\"img/blog-表格/blog-表格-页面.png\" alt=\"\"><br>下图为html源码<br><img src=\"img/blog-表格/blog-表格-html源码.png\" alt=\"\"><br>下图为md源码<br><img src=\"img/blog-表格/blog-表格-md源码.png\" alt=\"\"><br>可能是md源码中有<strong>换行符</strong>的问题，导致解析出问题，多了好多<code>&lt;br&gt;</code>，我把所有的格式都去掉了，就可以了。<br>下图为修改完的格式<br><img src=\"img/blog-表格/blog-表格-正确.png\" alt=\"\"><br>下午为修改后的md源码<br><img src=\"img/blog-表格/blog-表格-正确md源码.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/blog.jpg\" alt=\"\"></p>","more":"<h3 id=\"blog-md表格\"><a href=\"#blog-md表格\" class=\"headerlink\" title=\"blog-md表格\"></a>blog-md表格</h3><p>今天写blog的时候，想写一个表格，就是网上百度了一下，md表格的语法。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 水果        | 价格    |  数量  |</span><br><span class=\"line\">| <span class=\"symbol\">:--------</span>: | <span class=\"symbol\">:-----</span>  | <span class=\"symbol\">:----</span>: |</span><br><span class=\"line\">| 香蕉        | <span class=\"variable\">$1</span>      |   <span class=\"number\">5</span>    |</span><br><span class=\"line\">| 苹果        | <span class=\"variable\">$1</span>      |   <span class=\"number\">6</span>    |</span><br><span class=\"line\">| 草莓        | <span class=\"variable\">$1</span>      |   <span class=\"number\">7</span>    |</span><br></pre></td></tr></table></figure>\n<p>这个是md的语法，效果是这样的。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">水果</th>\n<th style=\"text-align:left\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">香蕉</td>\n<td style=\"text-align:left\">$1</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">苹果</td>\n<td style=\"text-align:left\">$1</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">草莓</td>\n<td style=\"text-align:left\">$1</td>\n<td style=\"text-align:center\">7</td>\n</tr>\n</tbody>\n</table>\n<p>但是我的需求是这样的需要可以合并单元格的，最后才知道md暂不支持合并单元格。但是md是支持html的，html当然是支持合并单元格的。所以想要有合并单元格需求的时候，可以使用html来写表格。但是写html的时候也需要到其他的坑。<br>下图为现象<br><img src=\"img/blog-表格/blog-表格-页面.png\" alt=\"\"><br>下图为html源码<br><img src=\"img/blog-表格/blog-表格-html源码.png\" alt=\"\"><br>下图为md源码<br><img src=\"img/blog-表格/blog-表格-md源码.png\" alt=\"\"><br>可能是md源码中有<strong>换行符</strong>的问题，导致解析出问题，多了好多<code>&lt;br&gt;</code>，我把所有的格式都去掉了，就可以了。<br>下图为修改完的格式<br><img src=\"img/blog-表格/blog-表格-正确.png\" alt=\"\"><br>下午为修改后的md源码<br><img src=\"img/blog-表格/blog-表格-正确md源码.png\" alt=\"\"></p>"},{"title":"Hexo、Github搭建Blog","date":"2018-03-10T07:56:25.000Z","type":"categories","comments":1,"_content":"\n![](img/index-page-img/blog.jpg)\n\n<!-- more -->\n\n\n### 选择github和hexo搭建blog的原因\n\n这是我自己搭建的第一个blog,现在比较流行的有wordpess、github blog。wordpress 通过了解构建比较发杂，所以选择了使用github blog 搭建，使用的是md语法，部署直接使用的是github服务器，也不需要单独搭建服务器。wordpress我不是太了解，大神勿喷。\n\n**个人想法：现在做技术，其实在学校上学的时候是有些是时候有很多相似的地方，有些的地方有意思的地方就整理下，善于记录、积累**:\t\t\n一，能把这些好想法也好，思路也好，都能记录下来，以便于日后能用到\t\n二，书写文章对思路也是一个很好的锻炼，就好像“茶壶里煮饺子”，饺子好了一定要倒出来，才算掌握，一个新的技术只有能清晰的讲解出来，也才算真正的理解\t\t\n三，以后在面试的时候也能也可以在简历上，把自己的github、个人站点、blog写上，也会让你在面试中加分\n\t\n我也开始上路，把自己的blog刚刚弄好了，就写了这篇文章，md，之前写wiki用过，github写过简单的README.md，但是没有用md来写文章，可能文章格式不好看的地方，大神勿喷\n\n### 环境准备\n\n##### git\n我感觉，要是做开发的同学本地一定会装git的，git主要拉取github项目，和github上项目关联。\n常用的命令也不说了，日常开发中也会经常用到。\n\n##### node\n再有一个环境就是node环境，这个主要是hexo这个工具依赖node环境，node的环境的要求，这个我也\n太清楚，我的本地的**node version : v8.11.1**，之前开发用的6.x的版本，现在不做node开发，换的高一点版本。**6.x+** 肯定是够用的。没问题。\n\n##### hexo\nhexo 这是blog主要使用的工具，步骤如下：\n\n1. \t安装命令\t`npm i -g hexo`\n2.\t进入目录\t`cd /xx/xx`\n3. 执行初始化\t`hexo init`\n\n解释下生成的目录\n\n* node_modules：是依赖包\n* public：存放的是生成的页面\n* scaffolds：命令生成文章等的模板\n* source：用命令创建的各种文章\n* themes：主题\n* _config.yml：整个博客的配置\n* db.json：source解析所得到的\n* package.json：项目所需模块项目的配置信息\n\n##### 创建blog project\n1. 首先创建github项目。\n![](img/创建账号.jpg)\n\n2.\t设置项目为blog，保存\n![](img/设置pages.png)\n\n3.\t设置hexo信息，设置你的git地址，分支。\n![](img/hexo设置.png)\n\n4.\t开始小试牛刀\t\n`hexo clean`\t\t\n`hexo g`\t\t\n`hexo s`\t\n\t**hexo g** 是生成对应的文件，也就是把md编写的md文件，生成对应的html文件，可以让服务运行\n\t\n\t**hexo s** 是启动hexo 服务，执行该命令会看到 \n\t`INFO  Hexo is running at http://localhost:4000/blog/. Press Ctrl+C to stop.`\n\t也就是说hexo服务已经起来了。可以通过http://localhost:4000/blog/ 这个url访问。也可以通过**-p**命令指定端口号。\t\t\n\t\t\n\t**hexo deploy** 这个是部署github 服务的命令，就是讲本地的代码push到服务器上，其实也就是一个静态页面，推送上去。使用这个命令，在公网上使用你刚刚在github中设置pages的那块的url访问你的blog。这样别人就能看到了。\n\n\t**hexo new 'my first blog'** 可以使用new 这个参数创建md 文件，会直接生成头信息。用md编辑器编辑，再推送到服务器上就ok了。\n\t\n5.\t样式问题\n\t其实搞blog，有种当年玩qq空间的感觉，可以到网站去找自己的喜欢的样式，去设置，我也刚刚开始，也没有做的很好看，所以这块就不分享了。\n\t\n6.\t站长统计及搜索引擎\n\n\t统计留言：可以集成第三的统计插件，在自己的blog里的_config.yml 文件中设置。\t\n\t搜索引擎：可以在百度的站长工具中设置，自己要被爬的链接，把自己的blog url 贴进去，过几天百度爬过了就可以通过百度搜索自己的blog了。自己的文章也可以在百度中搜到了。\n\t\t\t\n7.\t域名问题\n\t可以自己备案一个域名，在github中blog的项目设置中，pages那块会有个域名设置，这样。github\n\t会这个域名解析到你的blog项目下，这样就可以使用自己的域名访问了。是不是很爽呐。\n\n**总结**\t\n\t我这个只是刚刚开始，也算是小试牛刀，文章中提到的好多细节，我都没有深入去搞，我下面，我会写一些技术的文章，在写作的过程中，有深入的细节，我也会更新到这个文账中。\n\n**Blog源码地址：**\thttps://github.com/wangypeng/blog-source\n","source":"_posts/Hexo、Github搭建Blog.md","raw":"---\ntitle: Hexo、Github搭建Blog\ndate: 2018-03-10 15:56:25\ntype: \"categories\"\ncategories: blog\ncomments: true\ntags: blog\n---\n\n![](img/index-page-img/blog.jpg)\n\n<!-- more -->\n\n\n### 选择github和hexo搭建blog的原因\n\n这是我自己搭建的第一个blog,现在比较流行的有wordpess、github blog。wordpress 通过了解构建比较发杂，所以选择了使用github blog 搭建，使用的是md语法，部署直接使用的是github服务器，也不需要单独搭建服务器。wordpress我不是太了解，大神勿喷。\n\n**个人想法：现在做技术，其实在学校上学的时候是有些是时候有很多相似的地方，有些的地方有意思的地方就整理下，善于记录、积累**:\t\t\n一，能把这些好想法也好，思路也好，都能记录下来，以便于日后能用到\t\n二，书写文章对思路也是一个很好的锻炼，就好像“茶壶里煮饺子”，饺子好了一定要倒出来，才算掌握，一个新的技术只有能清晰的讲解出来，也才算真正的理解\t\t\n三，以后在面试的时候也能也可以在简历上，把自己的github、个人站点、blog写上，也会让你在面试中加分\n\t\n我也开始上路，把自己的blog刚刚弄好了，就写了这篇文章，md，之前写wiki用过，github写过简单的README.md，但是没有用md来写文章，可能文章格式不好看的地方，大神勿喷\n\n### 环境准备\n\n##### git\n我感觉，要是做开发的同学本地一定会装git的，git主要拉取github项目，和github上项目关联。\n常用的命令也不说了，日常开发中也会经常用到。\n\n##### node\n再有一个环境就是node环境，这个主要是hexo这个工具依赖node环境，node的环境的要求，这个我也\n太清楚，我的本地的**node version : v8.11.1**，之前开发用的6.x的版本，现在不做node开发，换的高一点版本。**6.x+** 肯定是够用的。没问题。\n\n##### hexo\nhexo 这是blog主要使用的工具，步骤如下：\n\n1. \t安装命令\t`npm i -g hexo`\n2.\t进入目录\t`cd /xx/xx`\n3. 执行初始化\t`hexo init`\n\n解释下生成的目录\n\n* node_modules：是依赖包\n* public：存放的是生成的页面\n* scaffolds：命令生成文章等的模板\n* source：用命令创建的各种文章\n* themes：主题\n* _config.yml：整个博客的配置\n* db.json：source解析所得到的\n* package.json：项目所需模块项目的配置信息\n\n##### 创建blog project\n1. 首先创建github项目。\n![](img/创建账号.jpg)\n\n2.\t设置项目为blog，保存\n![](img/设置pages.png)\n\n3.\t设置hexo信息，设置你的git地址，分支。\n![](img/hexo设置.png)\n\n4.\t开始小试牛刀\t\n`hexo clean`\t\t\n`hexo g`\t\t\n`hexo s`\t\n\t**hexo g** 是生成对应的文件，也就是把md编写的md文件，生成对应的html文件，可以让服务运行\n\t\n\t**hexo s** 是启动hexo 服务，执行该命令会看到 \n\t`INFO  Hexo is running at http://localhost:4000/blog/. Press Ctrl+C to stop.`\n\t也就是说hexo服务已经起来了。可以通过http://localhost:4000/blog/ 这个url访问。也可以通过**-p**命令指定端口号。\t\t\n\t\t\n\t**hexo deploy** 这个是部署github 服务的命令，就是讲本地的代码push到服务器上，其实也就是一个静态页面，推送上去。使用这个命令，在公网上使用你刚刚在github中设置pages的那块的url访问你的blog。这样别人就能看到了。\n\n\t**hexo new 'my first blog'** 可以使用new 这个参数创建md 文件，会直接生成头信息。用md编辑器编辑，再推送到服务器上就ok了。\n\t\n5.\t样式问题\n\t其实搞blog，有种当年玩qq空间的感觉，可以到网站去找自己的喜欢的样式，去设置，我也刚刚开始，也没有做的很好看，所以这块就不分享了。\n\t\n6.\t站长统计及搜索引擎\n\n\t统计留言：可以集成第三的统计插件，在自己的blog里的_config.yml 文件中设置。\t\n\t搜索引擎：可以在百度的站长工具中设置，自己要被爬的链接，把自己的blog url 贴进去，过几天百度爬过了就可以通过百度搜索自己的blog了。自己的文章也可以在百度中搜到了。\n\t\t\t\n7.\t域名问题\n\t可以自己备案一个域名，在github中blog的项目设置中，pages那块会有个域名设置，这样。github\n\t会这个域名解析到你的blog项目下，这样就可以使用自己的域名访问了。是不是很爽呐。\n\n**总结**\t\n\t我这个只是刚刚开始，也算是小试牛刀，文章中提到的好多细节，我都没有深入去搞，我下面，我会写一些技术的文章，在写作的过程中，有深入的细节，我也会更新到这个文账中。\n\n**Blog源码地址：**\thttps://github.com/wangypeng/blog-source\n","slug":"Hexo、Github搭建Blog","published":1,"updated":"2018-11-14T09:11:05.000Z","layout":"post","photos":[],"link":"","_id":"cjsq3syng000543xr7f2kr9n4","content":"<p><img src=\"img/index-page-img/blog.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"选择github和hexo搭建blog的原因\"><a href=\"#选择github和hexo搭建blog的原因\" class=\"headerlink\" title=\"选择github和hexo搭建blog的原因\"></a>选择github和hexo搭建blog的原因</h3><p>这是我自己搭建的第一个blog,现在比较流行的有wordpess、github blog。wordpress 通过了解构建比较发杂，所以选择了使用github blog 搭建，使用的是md语法，部署直接使用的是github服务器，也不需要单独搭建服务器。wordpress我不是太了解，大神勿喷。</p>\n<p><strong>个人想法：现在做技术，其实在学校上学的时候是有些是时候有很多相似的地方，有些的地方有意思的地方就整理下，善于记录、积累</strong>:<br>一，能把这些好想法也好，思路也好，都能记录下来，以便于日后能用到<br>二，书写文章对思路也是一个很好的锻炼，就好像“茶壶里煮饺子”，饺子好了一定要倒出来，才算掌握，一个新的技术只有能清晰的讲解出来，也才算真正的理解<br>三，以后在面试的时候也能也可以在简历上，把自己的github、个人站点、blog写上，也会让你在面试中加分</p>\n<p>我也开始上路，把自己的blog刚刚弄好了，就写了这篇文章，md，之前写wiki用过，github写过简单的README.md，但是没有用md来写文章，可能文章格式不好看的地方，大神勿喷</p>\n<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><h5 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h5><p>我感觉，要是做开发的同学本地一定会装git的，git主要拉取github项目，和github上项目关联。<br>常用的命令也不说了，日常开发中也会经常用到。</p>\n<h5 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h5><p>再有一个环境就是node环境，这个主要是hexo这个工具依赖node环境，node的环境的要求，这个我也<br>太清楚，我的本地的<strong>node version : v8.11.1</strong>，之前开发用的6.x的版本，现在不做node开发，换的高一点版本。<strong>6.x+</strong> 肯定是够用的。没问题。</p>\n<h5 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h5><p>hexo 这是blog主要使用的工具，步骤如下：</p>\n<ol>\n<li>安装命令    <code>npm i -g hexo</code></li>\n<li>进入目录    <code>cd /xx/xx</code></li>\n<li>执行初始化    <code>hexo init</code></li>\n</ol>\n<p>解释下生成的目录</p>\n<ul>\n<li>node_modules：是依赖包</li>\n<li>public：存放的是生成的页面</li>\n<li>scaffolds：命令生成文章等的模板</li>\n<li>source：用命令创建的各种文章</li>\n<li>themes：主题</li>\n<li>_config.yml：整个博客的配置</li>\n<li>db.json：source解析所得到的</li>\n<li>package.json：项目所需模块项目的配置信息</li>\n</ul>\n<h5 id=\"创建blog-project\"><a href=\"#创建blog-project\" class=\"headerlink\" title=\"创建blog project\"></a>创建blog project</h5><ol>\n<li><p>首先创建github项目。<br><img src=\"img/创建账号.jpg\" alt=\"\"></p>\n</li>\n<li><p>设置项目为blog，保存<br><img src=\"img/设置pages.png\" alt=\"\"></p>\n</li>\n<li><p>设置hexo信息，设置你的git地址，分支。<br><img src=\"img/hexo设置.png\" alt=\"\"></p>\n</li>\n<li><p>开始小试牛刀<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo s</code><br><strong>hexo g</strong> 是生成对应的文件，也就是把md编写的md文件，生成对应的html文件，可以让服务运行</p>\n<p><strong>hexo s</strong> 是启动hexo 服务，执行该命令会看到<br><code>INFO  Hexo is running at http://localhost:4000/blog/. Press Ctrl+C to stop.</code><br>也就是说hexo服务已经起来了。可以通过<a href=\"http://localhost:4000/blog/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/blog/</a> 这个url访问。也可以通过<strong>-p</strong>命令指定端口号。        </p>\n<p><strong>hexo deploy</strong> 这个是部署github 服务的命令，就是讲本地的代码push到服务器上，其实也就是一个静态页面，推送上去。使用这个命令，在公网上使用你刚刚在github中设置pages的那块的url访问你的blog。这样别人就能看到了。</p>\n<p><strong>hexo new ‘my first blog’</strong> 可以使用new 这个参数创建md 文件，会直接生成头信息。用md编辑器编辑，再推送到服务器上就ok了。</p>\n</li>\n<li><p>样式问题<br>其实搞blog，有种当年玩qq空间的感觉，可以到网站去找自己的喜欢的样式，去设置，我也刚刚开始，也没有做的很好看，所以这块就不分享了。</p>\n</li>\n<li><p>站长统计及搜索引擎</p>\n<p>统计留言：可以集成第三的统计插件，在自己的blog里的_config.yml 文件中设置。<br>搜索引擎：可以在百度的站长工具中设置，自己要被爬的链接，把自己的blog url 贴进去，过几天百度爬过了就可以通过百度搜索自己的blog了。自己的文章也可以在百度中搜到了。</p>\n</li>\n<li><p>域名问题<br>可以自己备案一个域名，在github中blog的项目设置中，pages那块会有个域名设置，这样。github<br>会这个域名解析到你的blog项目下，这样就可以使用自己的域名访问了。是不是很爽呐。</p>\n</li>\n</ol>\n<p><strong>总结</strong><br>    我这个只是刚刚开始，也算是小试牛刀，文章中提到的好多细节，我都没有深入去搞，我下面，我会写一些技术的文章，在写作的过程中，有深入的细节，我也会更新到这个文账中。</p>\n<p><strong>Blog源码地址：</strong>    <a href=\"https://github.com/wangypeng/blog-source\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/blog-source</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/blog.jpg\" alt=\"\"></p>","more":"<h3 id=\"选择github和hexo搭建blog的原因\"><a href=\"#选择github和hexo搭建blog的原因\" class=\"headerlink\" title=\"选择github和hexo搭建blog的原因\"></a>选择github和hexo搭建blog的原因</h3><p>这是我自己搭建的第一个blog,现在比较流行的有wordpess、github blog。wordpress 通过了解构建比较发杂，所以选择了使用github blog 搭建，使用的是md语法，部署直接使用的是github服务器，也不需要单独搭建服务器。wordpress我不是太了解，大神勿喷。</p>\n<p><strong>个人想法：现在做技术，其实在学校上学的时候是有些是时候有很多相似的地方，有些的地方有意思的地方就整理下，善于记录、积累</strong>:<br>一，能把这些好想法也好，思路也好，都能记录下来，以便于日后能用到<br>二，书写文章对思路也是一个很好的锻炼，就好像“茶壶里煮饺子”，饺子好了一定要倒出来，才算掌握，一个新的技术只有能清晰的讲解出来，也才算真正的理解<br>三，以后在面试的时候也能也可以在简历上，把自己的github、个人站点、blog写上，也会让你在面试中加分</p>\n<p>我也开始上路，把自己的blog刚刚弄好了，就写了这篇文章，md，之前写wiki用过，github写过简单的README.md，但是没有用md来写文章，可能文章格式不好看的地方，大神勿喷</p>\n<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><h5 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h5><p>我感觉，要是做开发的同学本地一定会装git的，git主要拉取github项目，和github上项目关联。<br>常用的命令也不说了，日常开发中也会经常用到。</p>\n<h5 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h5><p>再有一个环境就是node环境，这个主要是hexo这个工具依赖node环境，node的环境的要求，这个我也<br>太清楚，我的本地的<strong>node version : v8.11.1</strong>，之前开发用的6.x的版本，现在不做node开发，换的高一点版本。<strong>6.x+</strong> 肯定是够用的。没问题。</p>\n<h5 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h5><p>hexo 这是blog主要使用的工具，步骤如下：</p>\n<ol>\n<li>安装命令    <code>npm i -g hexo</code></li>\n<li>进入目录    <code>cd /xx/xx</code></li>\n<li>执行初始化    <code>hexo init</code></li>\n</ol>\n<p>解释下生成的目录</p>\n<ul>\n<li>node_modules：是依赖包</li>\n<li>public：存放的是生成的页面</li>\n<li>scaffolds：命令生成文章等的模板</li>\n<li>source：用命令创建的各种文章</li>\n<li>themes：主题</li>\n<li>_config.yml：整个博客的配置</li>\n<li>db.json：source解析所得到的</li>\n<li>package.json：项目所需模块项目的配置信息</li>\n</ul>\n<h5 id=\"创建blog-project\"><a href=\"#创建blog-project\" class=\"headerlink\" title=\"创建blog project\"></a>创建blog project</h5><ol>\n<li><p>首先创建github项目。<br><img src=\"img/创建账号.jpg\" alt=\"\"></p>\n</li>\n<li><p>设置项目为blog，保存<br><img src=\"img/设置pages.png\" alt=\"\"></p>\n</li>\n<li><p>设置hexo信息，设置你的git地址，分支。<br><img src=\"img/hexo设置.png\" alt=\"\"></p>\n</li>\n<li><p>开始小试牛刀<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo s</code><br><strong>hexo g</strong> 是生成对应的文件，也就是把md编写的md文件，生成对应的html文件，可以让服务运行</p>\n<p><strong>hexo s</strong> 是启动hexo 服务，执行该命令会看到<br><code>INFO  Hexo is running at http://localhost:4000/blog/. Press Ctrl+C to stop.</code><br>也就是说hexo服务已经起来了。可以通过<a href=\"http://localhost:4000/blog/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/blog/</a> 这个url访问。也可以通过<strong>-p</strong>命令指定端口号。        </p>\n<p><strong>hexo deploy</strong> 这个是部署github 服务的命令，就是讲本地的代码push到服务器上，其实也就是一个静态页面，推送上去。使用这个命令，在公网上使用你刚刚在github中设置pages的那块的url访问你的blog。这样别人就能看到了。</p>\n<p><strong>hexo new ‘my first blog’</strong> 可以使用new 这个参数创建md 文件，会直接生成头信息。用md编辑器编辑，再推送到服务器上就ok了。</p>\n</li>\n<li><p>样式问题<br>其实搞blog，有种当年玩qq空间的感觉，可以到网站去找自己的喜欢的样式，去设置，我也刚刚开始，也没有做的很好看，所以这块就不分享了。</p>\n</li>\n<li><p>站长统计及搜索引擎</p>\n<p>统计留言：可以集成第三的统计插件，在自己的blog里的_config.yml 文件中设置。<br>搜索引擎：可以在百度的站长工具中设置，自己要被爬的链接，把自己的blog url 贴进去，过几天百度爬过了就可以通过百度搜索自己的blog了。自己的文章也可以在百度中搜到了。</p>\n</li>\n<li><p>域名问题<br>可以自己备案一个域名，在github中blog的项目设置中，pages那块会有个域名设置，这样。github<br>会这个域名解析到你的blog项目下，这样就可以使用自己的域名访问了。是不是很爽呐。</p>\n</li>\n</ol>\n<p><strong>总结</strong><br>    我这个只是刚刚开始，也算是小试牛刀，文章中提到的好多细节，我都没有深入去搞，我下面，我会写一些技术的文章，在写作的过程中，有深入的细节，我也会更新到这个文账中。</p>\n<p><strong>Blog源码地址：</strong>    <a href=\"https://github.com/wangypeng/blog-source\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/blog-source</a></p>"},{"title":"docker-基础命令及使用","date":"2018-09-14T06:58:01.000Z","type":"categories","_content":"\n![](img/index-page-img/docker.jpeg)\n\ndocker基本使用\n\n<!-- more -->\n\n### 介绍\n\ndocker最近这几年比较火，云计算，容器编排应用也越来月广，这一切的基础都是docker。所以介绍一下，docker的一些基本使用。\n\n### 安装\n\n三种方式：\n\n* 官网直接下载对应版本，但是没有vpn的小伙伴可能会很慢。\n```\nhttps://docs.docker.com/ \n```\n* cli工具\n```\n// sudo \nbrew install\n// linux \nyum install docker\n```\n* 国内阿里云，有安装包，需要登陆。\n\n### 配置\n\n#### mac\n\n我使用的版本号：17.09\ndocker默认是使用docker官网的dockerhub，没有vpn，可以使用阿里云的镜像。 \n\n##### 配置步骤\n\n1. 打开Docker->Preferences->deamon\n2. Insecure registries配置:registry.mirrors.aliyuncs.com\n3. Registry mirrors配置自己的镜像加速器地址即可.\n重启docker生效\n使用淘宝的账号就行\n\n登陆阿里的镜像库，可以直接将自己的制作的镜像push到镜像空间中\n```\nsudo docker login --username=xxxx\nregistry.cn-hangzhou.aliyuncs.com\n```\n\n#### linux \n\n修改deamon.json配置文件，这个我没有实践，就不误人子弟了。可以去网上找，有很多详细的讲解。\n\n### 使用\n\n1. docker search 搜索命令名称\n```\ndocker search ubuntu\n```\n\n  不是系统源镜像，例如java、node这样的镜像，镜像里面是有整套的环境，可以查看镜像dockerfile，查看镜像的内部环境\n\n2. docker pull  镜像名称   直接从dockerhub 拉取镜像\n```\ndocker pull ubuntu\n```\n\n 可以阿里镜像库，直接拉取镜像库的镜像，镜像需跟上url\n\n3. docker run 启动容器\n```\ndocker run option\n```\n\t参数如下:\t\t\n\n\t**-i** 以交互模式运行容器，通常与 -t 同时使用\t\t\n\t**-t** 启动容器直接进入容器CLI，进入容器的伪输入终端\t\n\t**-d** 容器后台运行\t\t\n\t**-h** 指定容器的hostname\t\t\n\t**-rm** 容器推出后直接删除容器\t\t\n\t**-v** /host_file:/container_file host_file为宿主机文件路径 /container_file为容器内部的映射的文件路\t\t\n\t**-p** host_port:container_port host_port为宿主机端口，container_port为容器内部的端口\n\t**-P** 是容器内部端口随机映射到主机的高端口，**注**：-p和-P设置完端口，可以使用docker ps -a查看容器的端口映射\t\t\t\n\t**--name** containerName 指定容器的名称\n\t\n\t资源限制参数：\n\t**-e username=\"ritchie\"** : 设置环境变量；\n\t**-m** :设置容器使用内存最大值；\t\n\t**--cpuset=\"0-2\"** : 绑定容器到指定CPU运行\t\n4. docker stop containerID/containerName 停止容器，根据容器ID或者容器的名称\n```\ndocker stop mynode1\n```\n\n5. docker rm containerID/containerName  删除容器，根据容器的ID或者容器的名称\n```\ndocker rm containerID/containerName\n```\n\t快捷操作\n\tdocker rm `docker ps -a -q` 全部删除容器\n\tdocker rm $(docker ps -a -q) 一样是先查询全部的容器id再删除\n\n6. docker rmi imagesID/imgeName 删除容器，根据镜像的ID或者镜像的名称\t\n在删除镜像的时候，要保证没有使用这个镜像的容器。会报\n image is being used by stopped container 2a248b9ad5976\n\n7. docker ps [options]查询容器状态\n   **-a** all 查看全部的镜像\n   **-l**  last 查看最后一个运行的镜像\n   **-q** 只显示容器编号\n8. docker commit 提交容器\n9. docker inspect containerID 查看容器的相关参数\n```\ndocker inspect --format '{{ .NetworkSettings.IPAddress }}' containerID\n```\n查看全部的容器的ip\n\n\n\n\n","source":"_posts/docker-基础命令及使用.md","raw":"---\ntitle: docker-基础命令及使用\ndate: 2018-09-14 14:58:01\ntype: \"categories\"\ncategories: docker\ntags: docker\n---\n\n![](img/index-page-img/docker.jpeg)\n\ndocker基本使用\n\n<!-- more -->\n\n### 介绍\n\ndocker最近这几年比较火，云计算，容器编排应用也越来月广，这一切的基础都是docker。所以介绍一下，docker的一些基本使用。\n\n### 安装\n\n三种方式：\n\n* 官网直接下载对应版本，但是没有vpn的小伙伴可能会很慢。\n```\nhttps://docs.docker.com/ \n```\n* cli工具\n```\n// sudo \nbrew install\n// linux \nyum install docker\n```\n* 国内阿里云，有安装包，需要登陆。\n\n### 配置\n\n#### mac\n\n我使用的版本号：17.09\ndocker默认是使用docker官网的dockerhub，没有vpn，可以使用阿里云的镜像。 \n\n##### 配置步骤\n\n1. 打开Docker->Preferences->deamon\n2. Insecure registries配置:registry.mirrors.aliyuncs.com\n3. Registry mirrors配置自己的镜像加速器地址即可.\n重启docker生效\n使用淘宝的账号就行\n\n登陆阿里的镜像库，可以直接将自己的制作的镜像push到镜像空间中\n```\nsudo docker login --username=xxxx\nregistry.cn-hangzhou.aliyuncs.com\n```\n\n#### linux \n\n修改deamon.json配置文件，这个我没有实践，就不误人子弟了。可以去网上找，有很多详细的讲解。\n\n### 使用\n\n1. docker search 搜索命令名称\n```\ndocker search ubuntu\n```\n\n  不是系统源镜像，例如java、node这样的镜像，镜像里面是有整套的环境，可以查看镜像dockerfile，查看镜像的内部环境\n\n2. docker pull  镜像名称   直接从dockerhub 拉取镜像\n```\ndocker pull ubuntu\n```\n\n 可以阿里镜像库，直接拉取镜像库的镜像，镜像需跟上url\n\n3. docker run 启动容器\n```\ndocker run option\n```\n\t参数如下:\t\t\n\n\t**-i** 以交互模式运行容器，通常与 -t 同时使用\t\t\n\t**-t** 启动容器直接进入容器CLI，进入容器的伪输入终端\t\n\t**-d** 容器后台运行\t\t\n\t**-h** 指定容器的hostname\t\t\n\t**-rm** 容器推出后直接删除容器\t\t\n\t**-v** /host_file:/container_file host_file为宿主机文件路径 /container_file为容器内部的映射的文件路\t\t\n\t**-p** host_port:container_port host_port为宿主机端口，container_port为容器内部的端口\n\t**-P** 是容器内部端口随机映射到主机的高端口，**注**：-p和-P设置完端口，可以使用docker ps -a查看容器的端口映射\t\t\t\n\t**--name** containerName 指定容器的名称\n\t\n\t资源限制参数：\n\t**-e username=\"ritchie\"** : 设置环境变量；\n\t**-m** :设置容器使用内存最大值；\t\n\t**--cpuset=\"0-2\"** : 绑定容器到指定CPU运行\t\n4. docker stop containerID/containerName 停止容器，根据容器ID或者容器的名称\n```\ndocker stop mynode1\n```\n\n5. docker rm containerID/containerName  删除容器，根据容器的ID或者容器的名称\n```\ndocker rm containerID/containerName\n```\n\t快捷操作\n\tdocker rm `docker ps -a -q` 全部删除容器\n\tdocker rm $(docker ps -a -q) 一样是先查询全部的容器id再删除\n\n6. docker rmi imagesID/imgeName 删除容器，根据镜像的ID或者镜像的名称\t\n在删除镜像的时候，要保证没有使用这个镜像的容器。会报\n image is being used by stopped container 2a248b9ad5976\n\n7. docker ps [options]查询容器状态\n   **-a** all 查看全部的镜像\n   **-l**  last 查看最后一个运行的镜像\n   **-q** 只显示容器编号\n8. docker commit 提交容器\n9. docker inspect containerID 查看容器的相关参数\n```\ndocker inspect --format '{{ .NetworkSettings.IPAddress }}' containerID\n```\n查看全部的容器的ip\n\n\n\n\n","slug":"docker-基础命令及使用","published":1,"updated":"2018-11-14T08:03:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3synk000643xrqika771b","content":"<p><img src=\"img/index-page-img/docker.jpeg\" alt=\"\"></p>\n<p>docker基本使用</p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>docker最近这几年比较火，云计算，容器编排应用也越来月广，这一切的基础都是docker。所以介绍一下，docker的一些基本使用。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>三种方式：</p>\n<ul>\n<li><p>官网直接下载对应版本，但是没有vpn的小伙伴可能会很慢。</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">https:</span><span class=\"comment\">//docs.docker.com/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cli工具</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sudo </span></span><br><span class=\"line\">brew install</span><br><span class=\"line\"><span class=\"comment\">// linux </span></span><br><span class=\"line\">yum install docker</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>国内阿里云，有安装包，需要登陆。</p>\n</li>\n</ul>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h4><p>我使用的版本号：17.09<br>docker默认是使用docker官网的dockerhub，没有vpn，可以使用阿里云的镜像。 </p>\n<h5 id=\"配置步骤\"><a href=\"#配置步骤\" class=\"headerlink\" title=\"配置步骤\"></a>配置步骤</h5><ol>\n<li>打开Docker-&gt;Preferences-&gt;deamon</li>\n<li>Insecure registries配置:registry.mirrors.aliyuncs.com</li>\n<li>Registry mirrors配置自己的镜像加速器地址即可.<br>重启docker生效<br>使用淘宝的账号就行</li>\n</ol>\n<p>登陆阿里的镜像库，可以直接将自己的制作的镜像push到镜像空间中<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker login --username=xxxx</span><br><span class=\"line\">registry<span class=\"selector-class\">.cn-hangzhou</span><span class=\"selector-class\">.aliyuncs</span><span class=\"selector-class\">.com</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h4><p>修改deamon.json配置文件，这个我没有实践，就不误人子弟了。可以去网上找，有很多详细的讲解。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li><p>docker search 搜索命令名称</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">docker search ubuntu</span></span><br></pre></td></tr></table></figure>\n<p>不是系统源镜像，例如java、node这样的镜像，镜像里面是有整套的环境，可以查看镜像dockerfile，查看镜像的内部环境</p>\n</li>\n<li><p>docker pull  镜像名称   直接从dockerhub 拉取镜像</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">docker pull ubuntu</span></span><br></pre></td></tr></table></figure>\n<p>可以阿里镜像库，直接拉取镜像库的镜像，镜像需跟上url</p>\n</li>\n<li><p>docker run 启动容器</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"bash\"> option</span></span><br></pre></td></tr></table></figure>\n<p> 参数如下:        </p>\n<p> <strong>-i</strong> 以交互模式运行容器，通常与 -t 同时使用<br> <strong>-t</strong> 启动容器直接进入容器CLI，进入容器的伪输入终端<br> <strong>-d</strong> 容器后台运行<br> <strong>-h</strong> 指定容器的hostname<br> <strong>-rm</strong> 容器推出后直接删除容器<br> <strong>-v</strong> /host_file:/container_file host_file为宿主机文件路径 /container_file为容器内部的映射的文件路<br> <strong>-p</strong> host_port:container_port host_port为宿主机端口，container_port为容器内部的端口<br> <strong>-P</strong> 是容器内部端口随机映射到主机的高端口，<strong>注</strong>：-p和-P设置完端口，可以使用docker ps -a查看容器的端口映射<br> <strong>–name</strong> containerName 指定容器的名称</p>\n<p> 资源限制参数：<br> <strong>-e username=”ritchie”</strong> : 设置环境变量；<br> <strong>-m</strong> :设置容器使用内存最大值；<br> <strong>–cpuset=”0-2”</strong> : 绑定容器到指定CPU运行    </p>\n</li>\n<li><p>docker stop containerID/containerName 停止容器，根据容器ID或者容器的名称</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">stop</span> mynode1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>docker rm containerID/containerName  删除容器，根据容器的ID或者容器的名称</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">docker</span> rm containerID/containerName</span><br></pre></td></tr></table></figure>\n<p> 快捷操作<br> docker rm <code>docker ps -a -q</code> 全部删除容器<br> docker rm $(docker ps -a -q) 一样是先查询全部的容器id再删除</p>\n</li>\n<li><p>docker rmi imagesID/imgeName 删除容器，根据镜像的ID或者镜像的名称<br>在删除镜像的时候，要保证没有使用这个镜像的容器。会报<br>image is being used by stopped container 2a248b9ad5976</p>\n</li>\n<li><p>docker ps [options]查询容器状态<br><strong>-a</strong> all 查看全部的镜像<br><strong>-l</strong>  last 查看最后一个运行的镜像<br><strong>-q</strong> 只显示容器编号</p>\n</li>\n<li>docker commit 提交容器</li>\n<li>docker inspect containerID 查看容器的相关参数<figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">docker </span><span class=\"string\">inspect </span><span class=\"built_in\">--format</span> <span class=\"string\">'&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;'</span> <span class=\"string\">containerID</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>查看全部的容器的ip</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/docker.jpeg\" alt=\"\"></p>\n<p>docker基本使用</p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>docker最近这几年比较火，云计算，容器编排应用也越来月广，这一切的基础都是docker。所以介绍一下，docker的一些基本使用。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>三种方式：</p>\n<ul>\n<li><p>官网直接下载对应版本，但是没有vpn的小伙伴可能会很慢。</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">https:</span><span class=\"comment\">//docs.docker.com/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cli工具</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sudo </span></span><br><span class=\"line\">brew install</span><br><span class=\"line\"><span class=\"comment\">// linux </span></span><br><span class=\"line\">yum install docker</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>国内阿里云，有安装包，需要登陆。</p>\n</li>\n</ul>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h4><p>我使用的版本号：17.09<br>docker默认是使用docker官网的dockerhub，没有vpn，可以使用阿里云的镜像。 </p>\n<h5 id=\"配置步骤\"><a href=\"#配置步骤\" class=\"headerlink\" title=\"配置步骤\"></a>配置步骤</h5><ol>\n<li>打开Docker-&gt;Preferences-&gt;deamon</li>\n<li>Insecure registries配置:registry.mirrors.aliyuncs.com</li>\n<li>Registry mirrors配置自己的镜像加速器地址即可.<br>重启docker生效<br>使用淘宝的账号就行</li>\n</ol>\n<p>登陆阿里的镜像库，可以直接将自己的制作的镜像push到镜像空间中<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker login --username=xxxx</span><br><span class=\"line\">registry<span class=\"selector-class\">.cn-hangzhou</span><span class=\"selector-class\">.aliyuncs</span><span class=\"selector-class\">.com</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h4><p>修改deamon.json配置文件，这个我没有实践，就不误人子弟了。可以去网上找，有很多详细的讲解。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li><p>docker search 搜索命令名称</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">docker search ubuntu</span></span><br></pre></td></tr></table></figure>\n<p>不是系统源镜像，例如java、node这样的镜像，镜像里面是有整套的环境，可以查看镜像dockerfile，查看镜像的内部环境</p>\n</li>\n<li><p>docker pull  镜像名称   直接从dockerhub 拉取镜像</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">docker pull ubuntu</span></span><br></pre></td></tr></table></figure>\n<p>可以阿里镜像库，直接拉取镜像库的镜像，镜像需跟上url</p>\n</li>\n<li><p>docker run 启动容器</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"bash\"> option</span></span><br></pre></td></tr></table></figure>\n<p> 参数如下:        </p>\n<p> <strong>-i</strong> 以交互模式运行容器，通常与 -t 同时使用<br> <strong>-t</strong> 启动容器直接进入容器CLI，进入容器的伪输入终端<br> <strong>-d</strong> 容器后台运行<br> <strong>-h</strong> 指定容器的hostname<br> <strong>-rm</strong> 容器推出后直接删除容器<br> <strong>-v</strong> /host_file:/container_file host_file为宿主机文件路径 /container_file为容器内部的映射的文件路<br> <strong>-p</strong> host_port:container_port host_port为宿主机端口，container_port为容器内部的端口<br> <strong>-P</strong> 是容器内部端口随机映射到主机的高端口，<strong>注</strong>：-p和-P设置完端口，可以使用docker ps -a查看容器的端口映射<br> <strong>–name</strong> containerName 指定容器的名称</p>\n<p> 资源限制参数：<br> <strong>-e username=”ritchie”</strong> : 设置环境变量；<br> <strong>-m</strong> :设置容器使用内存最大值；<br> <strong>–cpuset=”0-2”</strong> : 绑定容器到指定CPU运行    </p>\n</li>\n<li><p>docker stop containerID/containerName 停止容器，根据容器ID或者容器的名称</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">stop</span> mynode1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>docker rm containerID/containerName  删除容器，根据容器的ID或者容器的名称</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">docker</span> rm containerID/containerName</span><br></pre></td></tr></table></figure>\n<p> 快捷操作<br> docker rm <code>docker ps -a -q</code> 全部删除容器<br> docker rm $(docker ps -a -q) 一样是先查询全部的容器id再删除</p>\n</li>\n<li><p>docker rmi imagesID/imgeName 删除容器，根据镜像的ID或者镜像的名称<br>在删除镜像的时候，要保证没有使用这个镜像的容器。会报<br>image is being used by stopped container 2a248b9ad5976</p>\n</li>\n<li><p>docker ps [options]查询容器状态<br><strong>-a</strong> all 查看全部的镜像<br><strong>-l</strong>  last 查看最后一个运行的镜像<br><strong>-q</strong> 只显示容器编号</p>\n</li>\n<li>docker commit 提交容器</li>\n<li>docker inspect containerID 查看容器的相关参数<figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">docker </span><span class=\"string\">inspect </span><span class=\"built_in\">--format</span> <span class=\"string\">'&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;'</span> <span class=\"string\">containerID</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>查看全部的容器的ip</p>"},{"date":"2018-02-16T16:00:00.000Z","title":"Hello World","type":"categories","_content":"\n![](img/index-page-img/blog.jpg)\n\n<!-- more -->\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ndate: 2018-02-17\ntitle: Hello World\ntype: \"categories\"\ncategories: blog\ntags: blog\n---\n\n![](img/index-page-img/blog.jpg)\n\n<!-- more -->\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2018-11-14T09:10:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3synm000743xrd497rjsi","content":"<p><img src=\"img/index-page-img/blog.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/blog.jpg\" alt=\"\"></p>","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"java CAS原理","date":"2018-07-22T07:39:37.000Z","type":"categories","_content":"\n![](img/index-page-img/java.png)\n\nCAS 深入理解。\n\n<!-- more -->\n\n\n### 线程安全问题引发的思考\n\njava中线程之间通信的线程安全问题，已经是老生常谈了，有这么几种解决方案：\t\n1. 使用synchronized关键字，但是我们知道这种简单粗暴，但是付出的代价是惨重的，会减低很多性能，其实也是称之为重量级锁。\t\n2. concurrent包中ReentrantLock，实现读写分离，有效的提高了并发，典型的例子：ConcurrentHashMap,就是使用ReentrantLock,加上分段锁的机制，保证了线程安全的前提下，提高了并发。相较于synchronized，更佳轻量\t\t\n3. concurrent包中Atomic类，实现原理，则是使用的CAS，实现的线程安全，本文将主要介绍CAS原理及实现机制。性能相对较高些。\n\n**CAS(compare and swap)比较交换**\t\n用当前内存地址上的值和预期的值比较，若相等，内存更新为新的值，若不相等，不更新。\t\n\t\njava中实现：通过底层计算机的CAS原理，java层面，通过自旋当时方式实现，当前值和预期不一样的时候，采用自旋的方式，直到compare成功，set值，但是这种方式，会占用大量cpu时间，jvm也做了优化，在自旋时降低cpu使用率，在自旋的时候jvm会pause,减低cpu使用率。\n\n\n在自学的过程中，发现，其实java代码，比较简洁，最底层是JNDI的方法，也是多方查找，总算找到了，更低层，实现CAS的原理，下面将详细介绍：\t\n\t\njava中Atomic源码，以AtomicIntger的addAndGet为例\t\t\t\nAtomicInteger包中的addAndGet\n{% codeblock %}\npublic final int addAndGet(int delta) {\n    return unsafe.getAndAddInt(this, valueOffset, delta) + delta;\n}\n{% endcodeblock %}\nUnsfe包中getAndAddInt\n{% codeblock lang:java %}\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}\n{% endcodeblock %}\n{% codeblock %}\npublic final native boolean compareAndSwapInt(Object var1, long var2, \nint var4, int var5);\n{% endcodeblock %}\n在代码中，能看到在java语言方面，是通过自旋的方式，一直循环，直到**compareAndSwapInt**为true为true的时候返回。\t其实最重要是**compareAndSwapInt**这个方法，又干了些什么那，继续谈论。\t\t\n\n其实再底层，就是物理机上做的原子操作，也就是硬件做的优化：\t\n在多处理器环境下，**LOCK#**信号可以确保处理器独占使用某些共享内存。lock 可以被添加在下面的指令前：\t\t\nADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG.\t\t\n也就是所有的更新内存地址上数据的操作，通过在 inc 指令前添加 lock 前缀，即可让该指令具备原子性。多个核心同时执行同一条 inc 指令时，会以串行的方式进行，也就避免了上面所说的那种情况。那么这里还有一个问题，lock 前缀是怎样保证核心独占某片内存区域的呢？答案如下：\n\n在 Intel 处理器中，有两种方式保证处理器的某个核心独占某片内存区域。第一种方式是通过锁定总线，让某个核心独占使用总线，但这样代价太大。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作。第二种方式是锁定缓存，若某处内存数据被缓存在处理器缓存中。处理器发出的 LOCK# 信号不会锁定总线，而是锁定缓存行对应的内存区域。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。相对于锁定总线，锁定缓存的代价明显比较小。\t\t\n\t\n总结下：物理机的cpu发出的指令，现在市面的cpu，根据操作的内存数据的情况，使用总线锁，或者缓存锁。如果是操作的数据是在内存的单行，会使用缓存锁，其他的cpu处理器，还是可以总线和内存交互，性能较高，但是操作的数据不在一个内存的数据较大，在内存地址上的多行，或者操作比较复杂，还是会使用总线锁，其他cpu处理器无法通过总线和内存交互，也就是会影响到其他的处理器的正常工作，性能较差。\n\n再介绍下上面的**总线**，和物理机器结构，和cpu相关的工作流程。\n\n![](img/java-CAS原理/物理机结构.jpg)\n\n总线：图总的**system bus**。cpu和内存传输的桥梁，多核cpu都是通过这一个总线和主内存交互。也是cpu和其他的硬件交互的通道，所以，总线锁，锁住总线，可以实现原子操作，并且因为总线锁，只能一个cpu处理器和内存交互，所以性能也是糟糕的。\n\n参考文章：https://www.cnblogs.com/nullllun/p/9039049.html\n\n\n**CAS缺点**\n\n CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作\n\n1.\tABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n\t\n\t从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\t\n\t\n\t关于ABA问题参考文档: http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html\n\n2.\t循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。\n\n \n\n3.\t只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。\n\n","source":"_posts/java-CAS原理.md","raw":"---\ntitle: java CAS原理\ndate: 2018-07-22 15:39:37\ntype: \"categories\"\ncategories: jvm\ntags: jvm\n---\n\n![](img/index-page-img/java.png)\n\nCAS 深入理解。\n\n<!-- more -->\n\n\n### 线程安全问题引发的思考\n\njava中线程之间通信的线程安全问题，已经是老生常谈了，有这么几种解决方案：\t\n1. 使用synchronized关键字，但是我们知道这种简单粗暴，但是付出的代价是惨重的，会减低很多性能，其实也是称之为重量级锁。\t\n2. concurrent包中ReentrantLock，实现读写分离，有效的提高了并发，典型的例子：ConcurrentHashMap,就是使用ReentrantLock,加上分段锁的机制，保证了线程安全的前提下，提高了并发。相较于synchronized，更佳轻量\t\t\n3. concurrent包中Atomic类，实现原理，则是使用的CAS，实现的线程安全，本文将主要介绍CAS原理及实现机制。性能相对较高些。\n\n**CAS(compare and swap)比较交换**\t\n用当前内存地址上的值和预期的值比较，若相等，内存更新为新的值，若不相等，不更新。\t\n\t\njava中实现：通过底层计算机的CAS原理，java层面，通过自旋当时方式实现，当前值和预期不一样的时候，采用自旋的方式，直到compare成功，set值，但是这种方式，会占用大量cpu时间，jvm也做了优化，在自旋时降低cpu使用率，在自旋的时候jvm会pause,减低cpu使用率。\n\n\n在自学的过程中，发现，其实java代码，比较简洁，最底层是JNDI的方法，也是多方查找，总算找到了，更低层，实现CAS的原理，下面将详细介绍：\t\n\t\njava中Atomic源码，以AtomicIntger的addAndGet为例\t\t\t\nAtomicInteger包中的addAndGet\n{% codeblock %}\npublic final int addAndGet(int delta) {\n    return unsafe.getAndAddInt(this, valueOffset, delta) + delta;\n}\n{% endcodeblock %}\nUnsfe包中getAndAddInt\n{% codeblock lang:java %}\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}\n{% endcodeblock %}\n{% codeblock %}\npublic final native boolean compareAndSwapInt(Object var1, long var2, \nint var4, int var5);\n{% endcodeblock %}\n在代码中，能看到在java语言方面，是通过自旋的方式，一直循环，直到**compareAndSwapInt**为true为true的时候返回。\t其实最重要是**compareAndSwapInt**这个方法，又干了些什么那，继续谈论。\t\t\n\n其实再底层，就是物理机上做的原子操作，也就是硬件做的优化：\t\n在多处理器环境下，**LOCK#**信号可以确保处理器独占使用某些共享内存。lock 可以被添加在下面的指令前：\t\t\nADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG.\t\t\n也就是所有的更新内存地址上数据的操作，通过在 inc 指令前添加 lock 前缀，即可让该指令具备原子性。多个核心同时执行同一条 inc 指令时，会以串行的方式进行，也就避免了上面所说的那种情况。那么这里还有一个问题，lock 前缀是怎样保证核心独占某片内存区域的呢？答案如下：\n\n在 Intel 处理器中，有两种方式保证处理器的某个核心独占某片内存区域。第一种方式是通过锁定总线，让某个核心独占使用总线，但这样代价太大。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作。第二种方式是锁定缓存，若某处内存数据被缓存在处理器缓存中。处理器发出的 LOCK# 信号不会锁定总线，而是锁定缓存行对应的内存区域。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。相对于锁定总线，锁定缓存的代价明显比较小。\t\t\n\t\n总结下：物理机的cpu发出的指令，现在市面的cpu，根据操作的内存数据的情况，使用总线锁，或者缓存锁。如果是操作的数据是在内存的单行，会使用缓存锁，其他的cpu处理器，还是可以总线和内存交互，性能较高，但是操作的数据不在一个内存的数据较大，在内存地址上的多行，或者操作比较复杂，还是会使用总线锁，其他cpu处理器无法通过总线和内存交互，也就是会影响到其他的处理器的正常工作，性能较差。\n\n再介绍下上面的**总线**，和物理机器结构，和cpu相关的工作流程。\n\n![](img/java-CAS原理/物理机结构.jpg)\n\n总线：图总的**system bus**。cpu和内存传输的桥梁，多核cpu都是通过这一个总线和主内存交互。也是cpu和其他的硬件交互的通道，所以，总线锁，锁住总线，可以实现原子操作，并且因为总线锁，只能一个cpu处理器和内存交互，所以性能也是糟糕的。\n\n参考文章：https://www.cnblogs.com/nullllun/p/9039049.html\n\n\n**CAS缺点**\n\n CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作\n\n1.\tABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n\t\n\t从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\t\n\t\n\t关于ABA问题参考文档: http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html\n\n2.\t循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。\n\n \n\n3.\t只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。\n\n","slug":"java-CAS原理","published":1,"updated":"2018-11-11T02:39:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syns000b43xr61z2maoh","content":"<p><img src=\"img/index-page-img/java.png\" alt=\"\"></p>\n<p>CAS 深入理解。</p>\n<a id=\"more\"></a>\n<h3 id=\"线程安全问题引发的思考\"><a href=\"#线程安全问题引发的思考\" class=\"headerlink\" title=\"线程安全问题引发的思考\"></a>线程安全问题引发的思考</h3><p>java中线程之间通信的线程安全问题，已经是老生常谈了，有这么几种解决方案：    </p>\n<ol>\n<li>使用synchronized关键字，但是我们知道这种简单粗暴，但是付出的代价是惨重的，会减低很多性能，其实也是称之为重量级锁。    </li>\n<li>concurrent包中ReentrantLock，实现读写分离，有效的提高了并发，典型的例子：ConcurrentHashMap,就是使用ReentrantLock,加上分段锁的机制，保证了线程安全的前提下，提高了并发。相较于synchronized，更佳轻量        </li>\n<li>concurrent包中Atomic类，实现原理，则是使用的CAS，实现的线程安全，本文将主要介绍CAS原理及实现机制。性能相对较高些。</li>\n</ol>\n<p><strong>CAS(compare and swap)比较交换</strong><br>用当前内存地址上的值和预期的值比较，若相等，内存更新为新的值，若不相等，不更新。    </p>\n<p>java中实现：通过底层计算机的CAS原理，java层面，通过自旋当时方式实现，当前值和预期不一样的时候，采用自旋的方式，直到compare成功，set值，但是这种方式，会占用大量cpu时间，jvm也做了优化，在自旋时降低cpu使用率，在自旋的时候jvm会pause,减低cpu使用率。</p>\n<p>在自学的过程中，发现，其实java代码，比较简洁，最底层是JNDI的方法，也是多方查找，总算找到了，更低层，实现CAS的原理，下面将详细介绍：    </p>\n<p>java中Atomic源码，以AtomicIntger的addAndGet为例<br>AtomicInteger包中的addAndGet<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">addAndGet</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta) + delta;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Unsfe包中getAndAddInt<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> compareAndSwapInt(Object var1, <span class=\"keyword\">long</span> var2, </span><br><span class=\"line\"><span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5);</span><br></pre></td></tr></table></figure><br>在代码中，能看到在java语言方面，是通过自旋的方式，一直循环，直到<strong>compareAndSwapInt</strong>为true为true的时候返回。    其实最重要是<strong>compareAndSwapInt</strong>这个方法，又干了些什么那，继续谈论。        </p>\n<p>其实再底层，就是物理机上做的原子操作，也就是硬件做的优化：<br>在多处理器环境下，<strong>LOCK#</strong>信号可以确保处理器独占使用某些共享内存。lock 可以被添加在下面的指令前：<br>ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG.<br>也就是所有的更新内存地址上数据的操作，通过在 inc 指令前添加 lock 前缀，即可让该指令具备原子性。多个核心同时执行同一条 inc 指令时，会以串行的方式进行，也就避免了上面所说的那种情况。那么这里还有一个问题，lock 前缀是怎样保证核心独占某片内存区域的呢？答案如下：</p>\n<p>在 Intel 处理器中，有两种方式保证处理器的某个核心独占某片内存区域。第一种方式是通过锁定总线，让某个核心独占使用总线，但这样代价太大。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作。第二种方式是锁定缓存，若某处内存数据被缓存在处理器缓存中。处理器发出的 LOCK# 信号不会锁定总线，而是锁定缓存行对应的内存区域。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。相对于锁定总线，锁定缓存的代价明显比较小。        </p>\n<p>总结下：物理机的cpu发出的指令，现在市面的cpu，根据操作的内存数据的情况，使用总线锁，或者缓存锁。如果是操作的数据是在内存的单行，会使用缓存锁，其他的cpu处理器，还是可以总线和内存交互，性能较高，但是操作的数据不在一个内存的数据较大，在内存地址上的多行，或者操作比较复杂，还是会使用总线锁，其他cpu处理器无法通过总线和内存交互，也就是会影响到其他的处理器的正常工作，性能较差。</p>\n<p>再介绍下上面的<strong>总线</strong>，和物理机器结构，和cpu相关的工作流程。</p>\n<p><img src=\"img/java-CAS原理/物理机结构.jpg\" alt=\"\"></p>\n<p>总线：图总的<strong>system bus</strong>。cpu和内存传输的桥梁，多核cpu都是通过这一个总线和主内存交互。也是cpu和其他的硬件交互的通道，所以，总线锁，锁住总线，可以实现原子操作，并且因为总线锁，只能一个cpu处理器和内存交互，所以性能也是糟糕的。</p>\n<p>参考文章：<a href=\"https://www.cnblogs.com/nullllun/p/9039049.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/nullllun/p/9039049.html</a></p>\n<p><strong>CAS缺点</strong></p>\n<p> CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>\n<ol>\n<li><p>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p>\n<p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。    </p>\n<p>关于ABA问题参考文档: <a href=\"http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html\" target=\"_blank\" rel=\"noopener\">http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html</a></p>\n</li>\n<li><p>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/java.png\" alt=\"\"></p>\n<p>CAS 深入理解。</p>","more":"<h3 id=\"线程安全问题引发的思考\"><a href=\"#线程安全问题引发的思考\" class=\"headerlink\" title=\"线程安全问题引发的思考\"></a>线程安全问题引发的思考</h3><p>java中线程之间通信的线程安全问题，已经是老生常谈了，有这么几种解决方案：    </p>\n<ol>\n<li>使用synchronized关键字，但是我们知道这种简单粗暴，但是付出的代价是惨重的，会减低很多性能，其实也是称之为重量级锁。    </li>\n<li>concurrent包中ReentrantLock，实现读写分离，有效的提高了并发，典型的例子：ConcurrentHashMap,就是使用ReentrantLock,加上分段锁的机制，保证了线程安全的前提下，提高了并发。相较于synchronized，更佳轻量        </li>\n<li>concurrent包中Atomic类，实现原理，则是使用的CAS，实现的线程安全，本文将主要介绍CAS原理及实现机制。性能相对较高些。</li>\n</ol>\n<p><strong>CAS(compare and swap)比较交换</strong><br>用当前内存地址上的值和预期的值比较，若相等，内存更新为新的值，若不相等，不更新。    </p>\n<p>java中实现：通过底层计算机的CAS原理，java层面，通过自旋当时方式实现，当前值和预期不一样的时候，采用自旋的方式，直到compare成功，set值，但是这种方式，会占用大量cpu时间，jvm也做了优化，在自旋时降低cpu使用率，在自旋的时候jvm会pause,减低cpu使用率。</p>\n<p>在自学的过程中，发现，其实java代码，比较简洁，最底层是JNDI的方法，也是多方查找，总算找到了，更低层，实现CAS的原理，下面将详细介绍：    </p>\n<p>java中Atomic源码，以AtomicIntger的addAndGet为例<br>AtomicInteger包中的addAndGet<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">addAndGet</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta) + delta;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Unsfe包中getAndAddInt<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> compareAndSwapInt(Object var1, <span class=\"keyword\">long</span> var2, </span><br><span class=\"line\"><span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5);</span><br></pre></td></tr></table></figure><br>在代码中，能看到在java语言方面，是通过自旋的方式，一直循环，直到<strong>compareAndSwapInt</strong>为true为true的时候返回。    其实最重要是<strong>compareAndSwapInt</strong>这个方法，又干了些什么那，继续谈论。        </p>\n<p>其实再底层，就是物理机上做的原子操作，也就是硬件做的优化：<br>在多处理器环境下，<strong>LOCK#</strong>信号可以确保处理器独占使用某些共享内存。lock 可以被添加在下面的指令前：<br>ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG.<br>也就是所有的更新内存地址上数据的操作，通过在 inc 指令前添加 lock 前缀，即可让该指令具备原子性。多个核心同时执行同一条 inc 指令时，会以串行的方式进行，也就避免了上面所说的那种情况。那么这里还有一个问题，lock 前缀是怎样保证核心独占某片内存区域的呢？答案如下：</p>\n<p>在 Intel 处理器中，有两种方式保证处理器的某个核心独占某片内存区域。第一种方式是通过锁定总线，让某个核心独占使用总线，但这样代价太大。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作。第二种方式是锁定缓存，若某处内存数据被缓存在处理器缓存中。处理器发出的 LOCK# 信号不会锁定总线，而是锁定缓存行对应的内存区域。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。相对于锁定总线，锁定缓存的代价明显比较小。        </p>\n<p>总结下：物理机的cpu发出的指令，现在市面的cpu，根据操作的内存数据的情况，使用总线锁，或者缓存锁。如果是操作的数据是在内存的单行，会使用缓存锁，其他的cpu处理器，还是可以总线和内存交互，性能较高，但是操作的数据不在一个内存的数据较大，在内存地址上的多行，或者操作比较复杂，还是会使用总线锁，其他cpu处理器无法通过总线和内存交互，也就是会影响到其他的处理器的正常工作，性能较差。</p>\n<p>再介绍下上面的<strong>总线</strong>，和物理机器结构，和cpu相关的工作流程。</p>\n<p><img src=\"img/java-CAS原理/物理机结构.jpg\" alt=\"\"></p>\n<p>总线：图总的<strong>system bus</strong>。cpu和内存传输的桥梁，多核cpu都是通过这一个总线和主内存交互。也是cpu和其他的硬件交互的通道，所以，总线锁，锁住总线，可以实现原子操作，并且因为总线锁，只能一个cpu处理器和内存交互，所以性能也是糟糕的。</p>\n<p>参考文章：<a href=\"https://www.cnblogs.com/nullllun/p/9039049.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/nullllun/p/9039049.html</a></p>\n<p><strong>CAS缺点</strong></p>\n<p> CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>\n<ol>\n<li><p>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p>\n<p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。    </p>\n<p>关于ABA问题参考文档: <a href=\"http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html\" target=\"_blank\" rel=\"noopener\">http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html</a></p>\n</li>\n<li><p>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>\n</ol>"},{"title":"java 8 stream","date":"2018-07-07T08:54:47.000Z","type":"categories","comments":1,"_content":"\n![](img/index-page-img/java.png)\n\nCAS 深入理解。\n\n<!-- more -->\n\n### java 8\n\njava 8 中增加很多的新的特性：lambda,stream,函数式编程,新的api。现在java8已经很普及了。工作中也经常用java8：lambda，steam。都是开发中的利器，首先可以增加开发效率，同时也能保证代码的可读性。虽然工作中使用频率还是挺高的，但是比较片面的，最近也是看了一遍《java 8 实战》 这本书，加上自己的一些测试，现在对java 8 的一些新的特性，有了一些更深入的认识。所以，就打算写一遍博客记录下。\n\n\n### lambda\n\nlambda表达式，函数式标称。其实在之前java也是有支持的，但是并不是那么友好，举个栗子：\n<p>java 8之前的版本</p>\n<pre>\n\tRunnable a = new Runnable() {\n        @Override\n        public void run() {\n        \t\tdoSomeThing();\n        }\n    };\n</pre>\n这个是定义接口，重写没有实现的方法，java8中增加了@FunctionalInterface,这样的接口就可以直接使用lambda表达式。\n<p>java8中的lambda写法：</p>\n<pre>\n\tRunnable run = () -> doSomeThing();\n</pre>\n这样，是不是看着很简洁，在了解java8 之前，我很烦java的语法，很冗长，比较喜欢python、golang、js的语法，很简洁。\t\t\nlambda表达式各式如下：\t\t\n**格式**\t\t\n<p></p>\n<pre>\n\t// 无参数,直接用()\n\t() -> {}\n\t// 一个参数，直接指定，不需要带括号\n\t a -> {}\n\t// 多个参数，需要带括号，把所有参数包起来\n\t(a,b,x) -> {}\n\t// 方法只调用一个方法\n\t() -> doSomeThing()\n\t// 方法内部有很多逻辑\n\t() -> {\n\t\tdoSomeThing();\n\t\t// 根据接口方法定义的，是否有返回结果\n\t\treturn someThing;\n\t}\n</pre>\n**注意**\t\t\n1.函数内部调用外部变量，会默认将外部变量设置为final，所以被调用的外部变量一定不能重新覆盖。\t\n2.内存函数的return只是返回内部函数返回，和外层函数无关，在forEach中使用lambda表达式，return 只是返回这次的执行，还会继续执行后面循环。而不是整个方法返回跳出循环。\n\n\n### stream\n\nstream这个是我个人非常喜欢的新特性，一个新的迭代的方式，1.8之前的迭代方式只有两种，一个是for或者增强for，一个是iterator。相较于之前的方式，stream方式处理数据更加灵活。下面介绍下stream处理数据的方式\n<table><tr><td colspan=\"3\" align=\"center\">stream操作</td></tr><tr><td rowspan=\"2\">中间操作</td><td>无状态</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble()flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态</td><td>distinct() sorted() sorted() limit() skip()</td></tr><tr><td rowspan=\"2\">结束操作</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min()count()</td></tr><tr><td>短路操作</td><td>distinct() sorted() sorted() limit() skip()</td></tr></table>\n","source":"_posts/java-8-stream.md","raw":"---\ntitle: java 8 stream\ndate: 2018-07-07 16:54:47\ntype: \"categories\"\ncategories: java8\ncomments: true\ntags: java8\n---\n\n![](img/index-page-img/java.png)\n\nCAS 深入理解。\n\n<!-- more -->\n\n### java 8\n\njava 8 中增加很多的新的特性：lambda,stream,函数式编程,新的api。现在java8已经很普及了。工作中也经常用java8：lambda，steam。都是开发中的利器，首先可以增加开发效率，同时也能保证代码的可读性。虽然工作中使用频率还是挺高的，但是比较片面的，最近也是看了一遍《java 8 实战》 这本书，加上自己的一些测试，现在对java 8 的一些新的特性，有了一些更深入的认识。所以，就打算写一遍博客记录下。\n\n\n### lambda\n\nlambda表达式，函数式标称。其实在之前java也是有支持的，但是并不是那么友好，举个栗子：\n<p>java 8之前的版本</p>\n<pre>\n\tRunnable a = new Runnable() {\n        @Override\n        public void run() {\n        \t\tdoSomeThing();\n        }\n    };\n</pre>\n这个是定义接口，重写没有实现的方法，java8中增加了@FunctionalInterface,这样的接口就可以直接使用lambda表达式。\n<p>java8中的lambda写法：</p>\n<pre>\n\tRunnable run = () -> doSomeThing();\n</pre>\n这样，是不是看着很简洁，在了解java8 之前，我很烦java的语法，很冗长，比较喜欢python、golang、js的语法，很简洁。\t\t\nlambda表达式各式如下：\t\t\n**格式**\t\t\n<p></p>\n<pre>\n\t// 无参数,直接用()\n\t() -> {}\n\t// 一个参数，直接指定，不需要带括号\n\t a -> {}\n\t// 多个参数，需要带括号，把所有参数包起来\n\t(a,b,x) -> {}\n\t// 方法只调用一个方法\n\t() -> doSomeThing()\n\t// 方法内部有很多逻辑\n\t() -> {\n\t\tdoSomeThing();\n\t\t// 根据接口方法定义的，是否有返回结果\n\t\treturn someThing;\n\t}\n</pre>\n**注意**\t\t\n1.函数内部调用外部变量，会默认将外部变量设置为final，所以被调用的外部变量一定不能重新覆盖。\t\n2.内存函数的return只是返回内部函数返回，和外层函数无关，在forEach中使用lambda表达式，return 只是返回这次的执行，还会继续执行后面循环。而不是整个方法返回跳出循环。\n\n\n### stream\n\nstream这个是我个人非常喜欢的新特性，一个新的迭代的方式，1.8之前的迭代方式只有两种，一个是for或者增强for，一个是iterator。相较于之前的方式，stream方式处理数据更加灵活。下面介绍下stream处理数据的方式\n<table><tr><td colspan=\"3\" align=\"center\">stream操作</td></tr><tr><td rowspan=\"2\">中间操作</td><td>无状态</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble()flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态</td><td>distinct() sorted() sorted() limit() skip()</td></tr><tr><td rowspan=\"2\">结束操作</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min()count()</td></tr><tr><td>短路操作</td><td>distinct() sorted() sorted() limit() skip()</td></tr></table>\n","slug":"java-8-stream","published":1,"updated":"2018-11-11T02:39:11.000Z","layout":"post","photos":[],"link":"","_id":"cjsq3synv000d43xrfqsamcj8","content":"<p><img src=\"img/index-page-img/java.png\" alt=\"\"></p>\n<p>CAS 深入理解。</p>\n<a id=\"more\"></a>\n<h3 id=\"java-8\"><a href=\"#java-8\" class=\"headerlink\" title=\"java 8\"></a>java 8</h3><p>java 8 中增加很多的新的特性：lambda,stream,函数式编程,新的api。现在java8已经很普及了。工作中也经常用java8：lambda，steam。都是开发中的利器，首先可以增加开发效率，同时也能保证代码的可读性。虽然工作中使用频率还是挺高的，但是比较片面的，最近也是看了一遍《java 8 实战》 这本书，加上自己的一些测试，现在对java 8 的一些新的特性，有了一些更深入的认识。所以，就打算写一遍博客记录下。</p>\n<h3 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h3><p>lambda表达式，函数式标称。其实在之前java也是有支持的，但是并不是那么友好，举个栗子：</p>\n<p></p><p>java 8之前的版本</p><p></p>\n<p><pre><br>    Runnable a = new Runnable() {<br>        @Override<br>        public void run() {<br>                doSomeThing();<br>        }<br>    };<br></pre><br>这个是定义接口，重写没有实现的方法，java8中增加了@FunctionalInterface,这样的接口就可以直接使用lambda表达式。</p>\n<p></p><p>java8中的lambda写法：</p><p></p>\n<p><pre><br>    Runnable run = () -&gt; doSomeThing();<br></pre><br>这样，是不是看着很简洁，在了解java8 之前，我很烦java的语法，很冗长，比较喜欢python、golang、js的语法，很简洁。<br>lambda表达式各式如下：<br><strong>格式</strong>        </p>\n<p></p><p></p><p></p>\n<p><pre><br>    // 无参数,直接用()<br>    () -&gt; {}<br>    // 一个参数，直接指定，不需要带括号<br>     a -&gt; {}<br>    // 多个参数，需要带括号，把所有参数包起来<br>    (a,b,x) -&gt; {}<br>    // 方法只调用一个方法<br>    () -&gt; doSomeThing()<br>    // 方法内部有很多逻辑<br>    () -&gt; {<br>        doSomeThing();<br>        // 根据接口方法定义的，是否有返回结果<br>        return someThing;<br>    }<br></pre><br><strong>注意</strong><br>1.函数内部调用外部变量，会默认将外部变量设置为final，所以被调用的外部变量一定不能重新覆盖。<br>2.内存函数的return只是返回内部函数返回，和外层函数无关，在forEach中使用lambda表达式，return 只是返回这次的执行，还会继续执行后面循环。而不是整个方法返回跳出循环。</p>\n<h3 id=\"stream\"><a href=\"#stream\" class=\"headerlink\" title=\"stream\"></a>stream</h3><p>stream这个是我个人非常喜欢的新特性，一个新的迭代的方式，1.8之前的迭代方式只有两种，一个是for或者增强for，一个是iterator。相较于之前的方式，stream方式处理数据更加灵活。下面介绍下stream处理数据的方式</p>\n<table><tr><td colspan=\"3\" align=\"center\">stream操作</td></tr><tr><td rowspan=\"2\">中间操作</td><td>无状态</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble()flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态</td><td>distinct() sorted() sorted() limit() skip()</td></tr><tr><td rowspan=\"2\">结束操作</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min()count()</td></tr><tr><td>短路操作</td><td>distinct() sorted() sorted() limit() skip()</td></tr></table>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/java.png\" alt=\"\"></p>\n<p>CAS 深入理解。</p>","more":"<h3 id=\"java-8\"><a href=\"#java-8\" class=\"headerlink\" title=\"java 8\"></a>java 8</h3><p>java 8 中增加很多的新的特性：lambda,stream,函数式编程,新的api。现在java8已经很普及了。工作中也经常用java8：lambda，steam。都是开发中的利器，首先可以增加开发效率，同时也能保证代码的可读性。虽然工作中使用频率还是挺高的，但是比较片面的，最近也是看了一遍《java 8 实战》 这本书，加上自己的一些测试，现在对java 8 的一些新的特性，有了一些更深入的认识。所以，就打算写一遍博客记录下。</p>\n<h3 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h3><p>lambda表达式，函数式标称。其实在之前java也是有支持的，但是并不是那么友好，举个栗子：</p>\n<p></p><p>java 8之前的版本</p><p></p>\n<p><pre><br>    Runnable a = new Runnable() {<br>        @Override<br>        public void run() {<br>                doSomeThing();<br>        }<br>    };<br></pre><br>这个是定义接口，重写没有实现的方法，java8中增加了@FunctionalInterface,这样的接口就可以直接使用lambda表达式。</p>\n<p></p><p>java8中的lambda写法：</p><p></p>\n<p><pre><br>    Runnable run = () -&gt; doSomeThing();<br></pre><br>这样，是不是看着很简洁，在了解java8 之前，我很烦java的语法，很冗长，比较喜欢python、golang、js的语法，很简洁。<br>lambda表达式各式如下：<br><strong>格式</strong>        </p>\n<p></p><p></p><p></p>\n<p><pre><br>    // 无参数,直接用()<br>    () -&gt; {}<br>    // 一个参数，直接指定，不需要带括号<br>     a -&gt; {}<br>    // 多个参数，需要带括号，把所有参数包起来<br>    (a,b,x) -&gt; {}<br>    // 方法只调用一个方法<br>    () -&gt; doSomeThing()<br>    // 方法内部有很多逻辑<br>    () -&gt; {<br>        doSomeThing();<br>        // 根据接口方法定义的，是否有返回结果<br>        return someThing;<br>    }<br></pre><br><strong>注意</strong><br>1.函数内部调用外部变量，会默认将外部变量设置为final，所以被调用的外部变量一定不能重新覆盖。<br>2.内存函数的return只是返回内部函数返回，和外层函数无关，在forEach中使用lambda表达式，return 只是返回这次的执行，还会继续执行后面循环。而不是整个方法返回跳出循环。</p>\n<h3 id=\"stream\"><a href=\"#stream\" class=\"headerlink\" title=\"stream\"></a>stream</h3><p>stream这个是我个人非常喜欢的新特性，一个新的迭代的方式，1.8之前的迭代方式只有两种，一个是for或者增强for，一个是iterator。相较于之前的方式，stream方式处理数据更加灵活。下面介绍下stream处理数据的方式</p>\n<table><tr><td colspan=\"3\" align=\"center\">stream操作</td></tr><tr><td rowspan=\"2\">中间操作</td><td>无状态</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble()flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态</td><td>distinct() sorted() sorted() limit() skip()</td></tr><tr><td rowspan=\"2\">结束操作</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min()count()</td></tr><tr><td>短路操作</td><td>distinct() sorted() sorted() limit() skip()</td></tr></table>"},{"title":"jvm工具-greys","date":"2018-07-14T02:21:22.000Z","type":"categories","_content":"\n![](img/index-page-img/java.png)\n\n<!-- more -->\n\n### 摘要\t\n\n最近在工作中，出现了一个接口请求时间较长的情况。但是我了解的java自带的工具，并不能很好的显示整个接口耗时的具体情况。最后也是在github上找到了一个阿里大神写的sh脚本，这个脚本，是用java写的，做了很好的classloader的隔离，并且，很轻量，占用资源很少，安装简便，耗时分析更佳之直观。\n\n### 安装步骤\t\n\n1. 首先进入进入安装目录\t\t\n2. 安装\n<pre>\ncurl -sLk http://ompc.oss.aliyuncs.com/greys/install.sh|sh\n</pre>\n3. 开启greys服务\n<pre>\n./greys <PID>[@IP:PORT]\n</pre>\n4. 进入greys服务后，进行想要的操作，greys相关命令：如下\n<table><tbody><tr><td style=\"width: 20%;\">命令</td><td>说明</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#help\">help</a></td><td>查看命令的帮助文档，每个命令和参数都有很详细的说明</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#sc\">sc</a></td><td>查看JVM已加载的类信息</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#sm\">sm</a></td><td>查看已加载的方法信息</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#monitor\">monitor</a></td><td>方法执行监控</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#trace\">trace</a></td><td>渲染方法内部调用路径，并输出方法路径上的每个节点上耗时</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#ptrace\">ptrace</a></td><td>方强化版的trace命令。通过指定渲染路径，并可记录下路径中所有方法的入参、返值；与tt命令联动。</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#watch\">watch</a></td><td>方法执行数据观测</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#tt\">tt</a></td><td>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#stack\">stack</a></td><td>输出当前方法被调用的调用路径</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#version\">version</a></td><td>输出当前目标Java进程所加载的Greys版本号</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#quit\">quit</a></td><td>退出greys客户端</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#shutdown\">shutdown</a></td><td>关闭greys服务端</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#reset\">reset</a></td><td>重置增强类，将被greys增强过的类全部还原</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#jvm\">jvm</a></td><td>查看当前JVM的信息</td></tr></tbody></table>\n\n官方github:https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Started","source":"_posts/jvm工具-greys.md","raw":"---\ntitle: jvm工具-greys\ndate: 2018-07-14 10:21:22\ntype: \"categories\"\ncategories: jvm\ntags: jvm\n---\n\n![](img/index-page-img/java.png)\n\n<!-- more -->\n\n### 摘要\t\n\n最近在工作中，出现了一个接口请求时间较长的情况。但是我了解的java自带的工具，并不能很好的显示整个接口耗时的具体情况。最后也是在github上找到了一个阿里大神写的sh脚本，这个脚本，是用java写的，做了很好的classloader的隔离，并且，很轻量，占用资源很少，安装简便，耗时分析更佳之直观。\n\n### 安装步骤\t\n\n1. 首先进入进入安装目录\t\t\n2. 安装\n<pre>\ncurl -sLk http://ompc.oss.aliyuncs.com/greys/install.sh|sh\n</pre>\n3. 开启greys服务\n<pre>\n./greys <PID>[@IP:PORT]\n</pre>\n4. 进入greys服务后，进行想要的操作，greys相关命令：如下\n<table><tbody><tr><td style=\"width: 20%;\">命令</td><td>说明</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#help\">help</a></td><td>查看命令的帮助文档，每个命令和参数都有很详细的说明</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#sc\">sc</a></td><td>查看JVM已加载的类信息</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#sm\">sm</a></td><td>查看已加载的方法信息</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#monitor\">monitor</a></td><td>方法执行监控</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#trace\">trace</a></td><td>渲染方法内部调用路径，并输出方法路径上的每个节点上耗时</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#ptrace\">ptrace</a></td><td>方强化版的trace命令。通过指定渲染路径，并可记录下路径中所有方法的入参、返值；与tt命令联动。</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#watch\">watch</a></td><td>方法执行数据观测</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#tt\">tt</a></td><td>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#stack\">stack</a></td><td>输出当前方法被调用的调用路径</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#version\">version</a></td><td>输出当前目标Java进程所加载的Greys版本号</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#quit\">quit</a></td><td>退出greys客户端</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#shutdown\">shutdown</a></td><td>关闭greys服务端</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#reset\">reset</a></td><td>重置增强类，将被greys增强过的类全部还原</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#jvm\">jvm</a></td><td>查看当前JVM的信息</td></tr></tbody></table>\n\n官方github:https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Started","slug":"jvm工具-greys","published":1,"updated":"2018-11-14T07:14:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3synx000i43xrq0hb8pud","content":"<p><img src=\"img/index-page-img/java.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>最近在工作中，出现了一个接口请求时间较长的情况。但是我了解的java自带的工具，并不能很好的显示整个接口耗时的具体情况。最后也是在github上找到了一个阿里大神写的sh脚本，这个脚本，是用java写的，做了很好的classloader的隔离，并且，很轻量，占用资源很少，安装简便，耗时分析更佳之直观。</p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ol>\n<li>首先进入进入安装目录        </li>\n<li>安装<pre>\ncurl -sLk http://ompc.oss.aliyuncs.com/greys/install.sh|sh\n</pre></li>\n<li>开启greys服务<pre>\n./greys <pid>[@IP:PORT]\n</pid></pre></li>\n<li>进入greys服务后，进行想要的操作，greys相关命令：如下<table><tbody><tr><td style=\"width: 20%;\">命令</td><td>说明</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#help\" target=\"_blank\" rel=\"noopener\">help</a></td><td>查看命令的帮助文档，每个命令和参数都有很详细的说明</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#sc\" target=\"_blank\" rel=\"noopener\">sc</a></td><td>查看JVM已加载的类信息</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#sm\" target=\"_blank\" rel=\"noopener\">sm</a></td><td>查看已加载的方法信息</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#monitor\" target=\"_blank\" rel=\"noopener\">monitor</a></td><td>方法执行监控</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#trace\" target=\"_blank\" rel=\"noopener\">trace</a></td><td>渲染方法内部调用路径，并输出方法路径上的每个节点上耗时</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#ptrace\" target=\"_blank\" rel=\"noopener\">ptrace</a></td><td>方强化版的trace命令。通过指定渲染路径，并可记录下路径中所有方法的入参、返值；与tt命令联动。</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#watch\" target=\"_blank\" rel=\"noopener\">watch</a></td><td>方法执行数据观测</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#tt\" target=\"_blank\" rel=\"noopener\">tt</a></td><td>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#stack\" target=\"_blank\" rel=\"noopener\">stack</a></td><td>输出当前方法被调用的调用路径</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#version\" target=\"_blank\" rel=\"noopener\">version</a></td><td>输出当前目标Java进程所加载的Greys版本号</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#quit\" target=\"_blank\" rel=\"noopener\">quit</a></td><td>退出greys客户端</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#shutdown\" target=\"_blank\" rel=\"noopener\">shutdown</a></td><td>关闭greys服务端</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#reset\" target=\"_blank\" rel=\"noopener\">reset</a></td><td>重置增强类，将被greys增强过的类全部还原</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#jvm\" target=\"_blank\" rel=\"noopener\">jvm</a></td><td>查看当前JVM的信息</td></tr></tbody></table>\n\n</li>\n</ol>\n<p>官方github:<a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Started\" target=\"_blank\" rel=\"noopener\">https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Started</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/java.png\" alt=\"\"></p>","more":"<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>最近在工作中，出现了一个接口请求时间较长的情况。但是我了解的java自带的工具，并不能很好的显示整个接口耗时的具体情况。最后也是在github上找到了一个阿里大神写的sh脚本，这个脚本，是用java写的，做了很好的classloader的隔离，并且，很轻量，占用资源很少，安装简便，耗时分析更佳之直观。</p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ol>\n<li>首先进入进入安装目录        </li>\n<li>安装<pre>\ncurl -sLk http://ompc.oss.aliyuncs.com/greys/install.sh|sh\n</pre></li>\n<li>开启greys服务<pre>\n./greys <pid>[@IP:PORT]\n</pid></pre></li>\n<li>进入greys服务后，进行想要的操作，greys相关命令：如下<table><tbody><tr><td style=\"width: 20%;\">命令</td><td>说明</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#help\" target=\"_blank\" rel=\"noopener\">help</a></td><td>查看命令的帮助文档，每个命令和参数都有很详细的说明</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#sc\" target=\"_blank\" rel=\"noopener\">sc</a></td><td>查看JVM已加载的类信息</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#sm\" target=\"_blank\" rel=\"noopener\">sm</a></td><td>查看已加载的方法信息</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#monitor\" target=\"_blank\" rel=\"noopener\">monitor</a></td><td>方法执行监控</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#trace\" target=\"_blank\" rel=\"noopener\">trace</a></td><td>渲染方法内部调用路径，并输出方法路径上的每个节点上耗时</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#ptrace\" target=\"_blank\" rel=\"noopener\">ptrace</a></td><td>方强化版的trace命令。通过指定渲染路径，并可记录下路径中所有方法的入参、返值；与tt命令联动。</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#watch\" target=\"_blank\" rel=\"noopener\">watch</a></td><td>方法执行数据观测</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#tt\" target=\"_blank\" rel=\"noopener\">tt</a></td><td>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#stack\" target=\"_blank\" rel=\"noopener\">stack</a></td><td>输出当前方法被调用的调用路径</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#version\" target=\"_blank\" rel=\"noopener\">version</a></td><td>输出当前目标Java进程所加载的Greys版本号</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#quit\" target=\"_blank\" rel=\"noopener\">quit</a></td><td>退出greys客户端</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#shutdown\" target=\"_blank\" rel=\"noopener\">shutdown</a></td><td>关闭greys服务端</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#reset\" target=\"_blank\" rel=\"noopener\">reset</a></td><td>重置增强类，将被greys增强过的类全部还原</td></tr><tr><td><a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Commands#jvm\" target=\"_blank\" rel=\"noopener\">jvm</a></td><td>查看当前JVM的信息</td></tr></tbody></table>\n\n</li>\n</ol>\n<p>官方github:<a href=\"https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Started\" target=\"_blank\" rel=\"noopener\">https://github.com/oldmanpushcart/greys-anatomy/wiki/Getting-Started</a></p>"},{"title":"redis-事务","date":"2018-11-14T09:31:35.000Z","type":"categories","_content":"\n\n![](img/index-page-img/redis.jpg)\n\nredis两种持久化的方式，**rdb**(redis database)和**aof**(append of only)。\n\n<!-- more -->\n\n### 实现方式\n\nredis的事务，并不像mysql有那么强的事务。redis实现是通过**队列**的方式，将所有的命令打包成一个**队列**，一起执行，不可拆分。不支持回滚。\n\n### 特点\n\n1. 支持rollbakck：mysql的事务是commit和rollback，redis是不支持回滚的。执行了命令，就无法撤回了。在事务excu之前，可以使用discard撤销事务。\n2. 没有mysql负责的事务隔离机制。只有执行和未执行。\n3. 配合**watch**命令一起使用，可以某些值做监控，如果值变化了，那么在执行的时候会失败。没有变化执行成功。\n4. 开启事务后，执行的命令只会校验语法，并不会检查命令最终执行的时候是否正确，举个栗子：一个key的值是一个数组，却incr这个key，命令写入队列的时候，并不会报错，只有在excu的时候，才会报错。并且这条命令之前的命令不会回滚。\n\n### 事务的执行流程\n\n#### 开启事务\nMULTI 命令的执行标记着事务的开始：\n<pre>\nredis> MULTI\nOK\n</pre>\n#### 命令入队\n\n当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行：\n<pre>\nredis> SET msg \"hello moto\"\nOK\n\nredis> GET msg\n\"hello moto\"\n</pre>\n\n但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 QUEUED ， 表示命令已入队：\n<pre>\nredis> MULTI\nOK\n\nredis> SET msg \"hello moto\"\nQUEUED\n\nredis> GET msg\nQUEUED\n</pre>\n\n**注意**：命令入队，只会校验命令语法的准确性，不会真正的执行，所以入队的命令还是可能会执行出错的。出错之前的命令不会回滚。\n\n#### 执行事务\n\n当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。\n\n但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 EXEC 、 DISCARD 、 MULTI 和 WATCH 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：\n\nTODO：执行图片\n\n如果客户端正处于事务状态， 那么当 EXEC 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。\n\n\n#### 事务状态下的 DISCARD 、 MULTI 和 WATCH 命令\n\n除了 EXEC 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 DISCARD 、 MULTI 和 WATCH 。\n\nDISCARD 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。\n\nRedis 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 MULTI 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 MULTI 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。\n\nWATCH 只能在客户端进入事务状态之前执行， 在事务状态下发送 WATCH 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 MULTI 的情况一样）。\n\n#### 带 WATCH 的事务\n\nWATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。\n\n以下示例展示了一个执行失败的事务例子：\n<pre>\nredis> WATCH name\nOK\n\nredis> MULTI\nOK\n\nredis> SET name peter\nQUEUED\n\nredis> EXEC\n(nil)\n</pre>\n\n#### 事务的 ACID 性质\n\n##### 原子性（Atomicity)\n\n单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。\n\n如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。\n\n另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。\n\n当事务失败时，Redis 也不会进行任何的重试或者回滚动作。\n\n##### 一致性（Consistency）\n\n**入队错误**\t\n\n在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等， 那么服务器将向客户端返回一个出错信息， 并且将客户端的事务状态设为 REDIS_DIRTY_EXEC 。\n\n当客户端执行 EXEC 命令时， Redis 会拒绝执行状态为 REDIS_DIRTY_EXEC 的事务， 并返回失败信息。\n\n<pre>\nredis 127.0.0.1:6379> MULTI\nOK\n\nredis 127.0.0.1:6379> set key\n(error) ERR wrong number of arguments for 'set' command\n\nredis 127.0.0.1:6379> EXISTS key\nQUEUED\n\nredis 127.0.0.1:6379> EXEC\n(error) EXECABORT Transaction discarded because of previous errors.\n</pre>\n\n因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。\n\n**执行错误**\n\n如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作， 那么 Redis 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。\n\n**Redis 进程被终结**\n\n如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：\n\n* 内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。\n\n* RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。\n\n* AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：\n\n\t1. 如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。\n\t\n\t2. 如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。\n\n##### 隔离性（Isolation）\n\nRedis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。\n\n##### 持久性（Durability）\n\n因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：\n\n* 在单纯的内存模式下，事务肯定是不持久的。\n\n* 在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。\n\n* 在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync 或 fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。\n\n其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。\n\n**引用文章地址**：<a>https://redisbook.readthedocs.io/en/latest/feature/transaction.html#durability</a>\n\n","source":"_posts/redis-事务.md","raw":"---\ntitle: redis-事务\ndate: 2018-11-14 17:31:35\ntype: \"categories\"\ncategories: redis\ntags: redis\n---\n\n\n![](img/index-page-img/redis.jpg)\n\nredis两种持久化的方式，**rdb**(redis database)和**aof**(append of only)。\n\n<!-- more -->\n\n### 实现方式\n\nredis的事务，并不像mysql有那么强的事务。redis实现是通过**队列**的方式，将所有的命令打包成一个**队列**，一起执行，不可拆分。不支持回滚。\n\n### 特点\n\n1. 支持rollbakck：mysql的事务是commit和rollback，redis是不支持回滚的。执行了命令，就无法撤回了。在事务excu之前，可以使用discard撤销事务。\n2. 没有mysql负责的事务隔离机制。只有执行和未执行。\n3. 配合**watch**命令一起使用，可以某些值做监控，如果值变化了，那么在执行的时候会失败。没有变化执行成功。\n4. 开启事务后，执行的命令只会校验语法，并不会检查命令最终执行的时候是否正确，举个栗子：一个key的值是一个数组，却incr这个key，命令写入队列的时候，并不会报错，只有在excu的时候，才会报错。并且这条命令之前的命令不会回滚。\n\n### 事务的执行流程\n\n#### 开启事务\nMULTI 命令的执行标记着事务的开始：\n<pre>\nredis> MULTI\nOK\n</pre>\n#### 命令入队\n\n当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行：\n<pre>\nredis> SET msg \"hello moto\"\nOK\n\nredis> GET msg\n\"hello moto\"\n</pre>\n\n但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 QUEUED ， 表示命令已入队：\n<pre>\nredis> MULTI\nOK\n\nredis> SET msg \"hello moto\"\nQUEUED\n\nredis> GET msg\nQUEUED\n</pre>\n\n**注意**：命令入队，只会校验命令语法的准确性，不会真正的执行，所以入队的命令还是可能会执行出错的。出错之前的命令不会回滚。\n\n#### 执行事务\n\n当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。\n\n但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 EXEC 、 DISCARD 、 MULTI 和 WATCH 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：\n\nTODO：执行图片\n\n如果客户端正处于事务状态， 那么当 EXEC 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。\n\n\n#### 事务状态下的 DISCARD 、 MULTI 和 WATCH 命令\n\n除了 EXEC 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 DISCARD 、 MULTI 和 WATCH 。\n\nDISCARD 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。\n\nRedis 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 MULTI 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 MULTI 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。\n\nWATCH 只能在客户端进入事务状态之前执行， 在事务状态下发送 WATCH 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 MULTI 的情况一样）。\n\n#### 带 WATCH 的事务\n\nWATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。\n\n以下示例展示了一个执行失败的事务例子：\n<pre>\nredis> WATCH name\nOK\n\nredis> MULTI\nOK\n\nredis> SET name peter\nQUEUED\n\nredis> EXEC\n(nil)\n</pre>\n\n#### 事务的 ACID 性质\n\n##### 原子性（Atomicity)\n\n单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。\n\n如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。\n\n另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。\n\n当事务失败时，Redis 也不会进行任何的重试或者回滚动作。\n\n##### 一致性（Consistency）\n\n**入队错误**\t\n\n在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等， 那么服务器将向客户端返回一个出错信息， 并且将客户端的事务状态设为 REDIS_DIRTY_EXEC 。\n\n当客户端执行 EXEC 命令时， Redis 会拒绝执行状态为 REDIS_DIRTY_EXEC 的事务， 并返回失败信息。\n\n<pre>\nredis 127.0.0.1:6379> MULTI\nOK\n\nredis 127.0.0.1:6379> set key\n(error) ERR wrong number of arguments for 'set' command\n\nredis 127.0.0.1:6379> EXISTS key\nQUEUED\n\nredis 127.0.0.1:6379> EXEC\n(error) EXECABORT Transaction discarded because of previous errors.\n</pre>\n\n因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。\n\n**执行错误**\n\n如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作， 那么 Redis 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。\n\n**Redis 进程被终结**\n\n如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：\n\n* 内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。\n\n* RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。\n\n* AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：\n\n\t1. 如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。\n\t\n\t2. 如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。\n\n##### 隔离性（Isolation）\n\nRedis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。\n\n##### 持久性（Durability）\n\n因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：\n\n* 在单纯的内存模式下，事务肯定是不持久的。\n\n* 在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。\n\n* 在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync 或 fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。\n\n其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。\n\n**引用文章地址**：<a>https://redisbook.readthedocs.io/en/latest/feature/transaction.html#durability</a>\n\n","slug":"redis-事务","published":1,"updated":"2018-11-14T11:00:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syny000k43xryrqe0o2y","content":"<p><img src=\"img/index-page-img/redis.jpg\" alt=\"\"></p>\n<p>redis两种持久化的方式，<strong>rdb</strong>(redis database)和<strong>aof</strong>(append of only)。</p>\n<a id=\"more\"></a>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><p>redis的事务，并不像mysql有那么强的事务。redis实现是通过<strong>队列</strong>的方式，将所有的命令打包成一个<strong>队列</strong>，一起执行，不可拆分。不支持回滚。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>支持rollbakck：mysql的事务是commit和rollback，redis是不支持回滚的。执行了命令，就无法撤回了。在事务excu之前，可以使用discard撤销事务。</li>\n<li>没有mysql负责的事务隔离机制。只有执行和未执行。</li>\n<li>配合<strong>watch</strong>命令一起使用，可以某些值做监控，如果值变化了，那么在执行的时候会失败。没有变化执行成功。</li>\n<li>开启事务后，执行的命令只会校验语法，并不会检查命令最终执行的时候是否正确，举个栗子：一个key的值是一个数组，却incr这个key，命令写入队列的时候，并不会报错，只有在excu的时候，才会报错。并且这条命令之前的命令不会回滚。</li>\n</ol>\n<h3 id=\"事务的执行流程\"><a href=\"#事务的执行流程\" class=\"headerlink\" title=\"事务的执行流程\"></a>事务的执行流程</h3><h4 id=\"开启事务\"><a href=\"#开启事务\" class=\"headerlink\" title=\"开启事务\"></a>开启事务</h4><p>MULTI 命令的执行标记着事务的开始：</p>\n<pre>\nredis> MULTI\nOK\n</pre>\n#### 命令入队\n\n当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行：\n<pre>\nredis> SET msg \"hello moto\"\nOK\n\nredis> GET msg\n\"hello moto\"\n</pre>\n\n<p>但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 QUEUED ， 表示命令已入队：</p>\n<pre>\nredis> MULTI\nOK\n\nredis> SET msg \"hello moto\"\nQUEUED\n\nredis> GET msg\nQUEUED\n</pre>\n\n<p><strong>注意</strong>：命令入队，只会校验命令语法的准确性，不会真正的执行，所以入队的命令还是可能会执行出错的。出错之前的命令不会回滚。</p>\n<h4 id=\"执行事务\"><a href=\"#执行事务\" class=\"headerlink\" title=\"执行事务\"></a>执行事务</h4><p>当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。</p>\n<p>但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 EXEC 、 DISCARD 、 MULTI 和 WATCH 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：</p>\n<p>TODO：执行图片</p>\n<p>如果客户端正处于事务状态， 那么当 EXEC 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p>\n<h4 id=\"事务状态下的-DISCARD-、-MULTI-和-WATCH-命令\"><a href=\"#事务状态下的-DISCARD-、-MULTI-和-WATCH-命令\" class=\"headerlink\" title=\"事务状态下的 DISCARD 、 MULTI 和 WATCH 命令\"></a>事务状态下的 DISCARD 、 MULTI 和 WATCH 命令</h4><p>除了 EXEC 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 DISCARD 、 MULTI 和 WATCH 。</p>\n<p>DISCARD 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。</p>\n<p>Redis 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 MULTI 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 MULTI 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</p>\n<p>WATCH 只能在客户端进入事务状态之前执行， 在事务状态下发送 WATCH 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 MULTI 的情况一样）。</p>\n<h4 id=\"带-WATCH-的事务\"><a href=\"#带-WATCH-的事务\" class=\"headerlink\" title=\"带 WATCH 的事务\"></a>带 WATCH 的事务</h4><p>WATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。</p>\n<p>以下示例展示了一个执行失败的事务例子：</p>\n<pre>\nredis> WATCH name\nOK\n\nredis> MULTI\nOK\n\nredis> SET name peter\nQUEUED\n\nredis> EXEC\n(nil)\n</pre>\n\n<h4 id=\"事务的-ACID-性质\"><a href=\"#事务的-ACID-性质\" class=\"headerlink\" title=\"事务的 ACID 性质\"></a>事务的 ACID 性质</h4><h5 id=\"原子性（Atomicity\"><a href=\"#原子性（Atomicity\" class=\"headerlink\" title=\"原子性（Atomicity)\"></a>原子性（Atomicity)</h5><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>\n<p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p>\n<p>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。</p>\n<p>当事务失败时，Redis 也不会进行任何的重试或者回滚动作。</p>\n<h5 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h5><p><strong>入队错误</strong>    </p>\n<p>在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等， 那么服务器将向客户端返回一个出错信息， 并且将客户端的事务状态设为 REDIS_DIRTY_EXEC 。</p>\n<p>当客户端执行 EXEC 命令时， Redis 会拒绝执行状态为 REDIS_DIRTY_EXEC 的事务， 并返回失败信息。</p>\n<pre>\nredis 127.0.0.1:6379> MULTI\nOK\n\nredis 127.0.0.1:6379> set key\n(error) ERR wrong number of arguments for 'set' command\n\nredis 127.0.0.1:6379> EXISTS key\nQUEUED\n\nredis 127.0.0.1:6379> EXEC\n(error) EXECABORT Transaction discarded because of previous errors.\n</pre>\n\n<p>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</p>\n<p><strong>执行错误</strong></p>\n<p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作， 那么 Redis 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。</p>\n<p><strong>Redis 进程被终结</strong></p>\n<p>如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：</p>\n<ul>\n<li><p>内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p>\n</li>\n<li><p>RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</p>\n</li>\n<li><p>AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：</p>\n<ol>\n<li><p>如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</p>\n</li>\n<li><p>如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"隔离性（Isolation）\"><a href=\"#隔离性（Isolation）\" class=\"headerlink\" title=\"隔离性（Isolation）\"></a>隔离性（Isolation）</h5><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>\n<h5 id=\"持久性（Durability）\"><a href=\"#持久性（Durability）\" class=\"headerlink\" title=\"持久性（Durability）\"></a>持久性（Durability）</h5><p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：</p>\n<ul>\n<li><p>在单纯的内存模式下，事务肯定是不持久的。</p>\n</li>\n<li><p>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。</p>\n</li>\n<li><p>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync 或 fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</p>\n</li>\n</ul>\n<p>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</p>\n<p><strong>引用文章地址</strong>：<a><a href=\"https://redisbook.readthedocs.io/en/latest/feature/transaction.html#durability\" target=\"_blank\" rel=\"noopener\">https://redisbook.readthedocs.io/en/latest/feature/transaction.html#durability</a></a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/redis.jpg\" alt=\"\"></p>\n<p>redis两种持久化的方式，<strong>rdb</strong>(redis database)和<strong>aof</strong>(append of only)。</p>","more":"<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><p>redis的事务，并不像mysql有那么强的事务。redis实现是通过<strong>队列</strong>的方式，将所有的命令打包成一个<strong>队列</strong>，一起执行，不可拆分。不支持回滚。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>支持rollbakck：mysql的事务是commit和rollback，redis是不支持回滚的。执行了命令，就无法撤回了。在事务excu之前，可以使用discard撤销事务。</li>\n<li>没有mysql负责的事务隔离机制。只有执行和未执行。</li>\n<li>配合<strong>watch</strong>命令一起使用，可以某些值做监控，如果值变化了，那么在执行的时候会失败。没有变化执行成功。</li>\n<li>开启事务后，执行的命令只会校验语法，并不会检查命令最终执行的时候是否正确，举个栗子：一个key的值是一个数组，却incr这个key，命令写入队列的时候，并不会报错，只有在excu的时候，才会报错。并且这条命令之前的命令不会回滚。</li>\n</ol>\n<h3 id=\"事务的执行流程\"><a href=\"#事务的执行流程\" class=\"headerlink\" title=\"事务的执行流程\"></a>事务的执行流程</h3><h4 id=\"开启事务\"><a href=\"#开启事务\" class=\"headerlink\" title=\"开启事务\"></a>开启事务</h4><p>MULTI 命令的执行标记着事务的开始：</p>\n<pre>\nredis> MULTI\nOK\n</pre>\n#### 命令入队\n\n当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行：\n<pre>\nredis> SET msg \"hello moto\"\nOK\n\nredis> GET msg\n\"hello moto\"\n</pre>\n\n<p>但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 QUEUED ， 表示命令已入队：</p>\n<pre>\nredis> MULTI\nOK\n\nredis> SET msg \"hello moto\"\nQUEUED\n\nredis> GET msg\nQUEUED\n</pre>\n\n<p><strong>注意</strong>：命令入队，只会校验命令语法的准确性，不会真正的执行，所以入队的命令还是可能会执行出错的。出错之前的命令不会回滚。</p>\n<h4 id=\"执行事务\"><a href=\"#执行事务\" class=\"headerlink\" title=\"执行事务\"></a>执行事务</h4><p>当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。</p>\n<p>但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 EXEC 、 DISCARD 、 MULTI 和 WATCH 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：</p>\n<p>TODO：执行图片</p>\n<p>如果客户端正处于事务状态， 那么当 EXEC 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p>\n<h4 id=\"事务状态下的-DISCARD-、-MULTI-和-WATCH-命令\"><a href=\"#事务状态下的-DISCARD-、-MULTI-和-WATCH-命令\" class=\"headerlink\" title=\"事务状态下的 DISCARD 、 MULTI 和 WATCH 命令\"></a>事务状态下的 DISCARD 、 MULTI 和 WATCH 命令</h4><p>除了 EXEC 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 DISCARD 、 MULTI 和 WATCH 。</p>\n<p>DISCARD 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。</p>\n<p>Redis 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 MULTI 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 MULTI 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</p>\n<p>WATCH 只能在客户端进入事务状态之前执行， 在事务状态下发送 WATCH 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 MULTI 的情况一样）。</p>\n<h4 id=\"带-WATCH-的事务\"><a href=\"#带-WATCH-的事务\" class=\"headerlink\" title=\"带 WATCH 的事务\"></a>带 WATCH 的事务</h4><p>WATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。</p>\n<p>以下示例展示了一个执行失败的事务例子：</p>\n<pre>\nredis> WATCH name\nOK\n\nredis> MULTI\nOK\n\nredis> SET name peter\nQUEUED\n\nredis> EXEC\n(nil)\n</pre>\n\n<h4 id=\"事务的-ACID-性质\"><a href=\"#事务的-ACID-性质\" class=\"headerlink\" title=\"事务的 ACID 性质\"></a>事务的 ACID 性质</h4><h5 id=\"原子性（Atomicity\"><a href=\"#原子性（Atomicity\" class=\"headerlink\" title=\"原子性（Atomicity)\"></a>原子性（Atomicity)</h5><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>\n<p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p>\n<p>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。</p>\n<p>当事务失败时，Redis 也不会进行任何的重试或者回滚动作。</p>\n<h5 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h5><p><strong>入队错误</strong>    </p>\n<p>在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等， 那么服务器将向客户端返回一个出错信息， 并且将客户端的事务状态设为 REDIS_DIRTY_EXEC 。</p>\n<p>当客户端执行 EXEC 命令时， Redis 会拒绝执行状态为 REDIS_DIRTY_EXEC 的事务， 并返回失败信息。</p>\n<pre>\nredis 127.0.0.1:6379> MULTI\nOK\n\nredis 127.0.0.1:6379> set key\n(error) ERR wrong number of arguments for 'set' command\n\nredis 127.0.0.1:6379> EXISTS key\nQUEUED\n\nredis 127.0.0.1:6379> EXEC\n(error) EXECABORT Transaction discarded because of previous errors.\n</pre>\n\n<p>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</p>\n<p><strong>执行错误</strong></p>\n<p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作， 那么 Redis 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。</p>\n<p><strong>Redis 进程被终结</strong></p>\n<p>如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：</p>\n<ul>\n<li><p>内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p>\n</li>\n<li><p>RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</p>\n</li>\n<li><p>AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：</p>\n<ol>\n<li><p>如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</p>\n</li>\n<li><p>如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"隔离性（Isolation）\"><a href=\"#隔离性（Isolation）\" class=\"headerlink\" title=\"隔离性（Isolation）\"></a>隔离性（Isolation）</h5><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>\n<h5 id=\"持久性（Durability）\"><a href=\"#持久性（Durability）\" class=\"headerlink\" title=\"持久性（Durability）\"></a>持久性（Durability）</h5><p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：</p>\n<ul>\n<li><p>在单纯的内存模式下，事务肯定是不持久的。</p>\n</li>\n<li><p>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。</p>\n</li>\n<li><p>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync 或 fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</p>\n</li>\n</ul>\n<p>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</p>\n<p><strong>引用文章地址</strong>：<a><a href=\"https://redisbook.readthedocs.io/en/latest/feature/transaction.html#durability\" target=\"_blank\" rel=\"noopener\">https://redisbook.readthedocs.io/en/latest/feature/transaction.html#durability</a></a></p>"},{"title":"redis-持久化","date":"2018-11-13T08:14:31.000Z","type":"categories","_content":"\n![](img/index-page-img/redis.jpg)\n\nredis两种持久化的方式，**rdb**(redis database)和**aof**(append of only)\n\n<!-- more -->\n\n### 介绍\n\nredis 是一个键值对存储数据库,基于内存存储,相对于传统基于磁盘做持久化的数据库,操作内存速度更快。所以也用来做缓存服务器。相对于memcache,redis提供了持久化的解决方案，数据安全性更高。\nredis提供的两种持久化方案，一个rdb(redis database)，一个是aof(append of only),本文将详细介绍这两种持久化。\n\n### SNAPSHOTTING rdb(redis database)\n\n#### 介绍\n\nrdb就是将redis内存中的数据做一个**快照**，经过**压缩**，以**二进制**文件的形式，保存到磁盘中。\n\n默认情况下，Redis以**异步方式**将数据集转储到磁盘上\n\n#### 相关命令\n\n* SAVE：阻塞redis的服务器进程，直到RDB文件被创建完毕。\n* BGSAVE：派生(fork)一个子进程来创建新的RDB文件，记录接收到BGSAVE当时的数据库状态，父进程继续处理接收到的命令，子进程完成文件的创建之后，会发送信号给父进程，而与此同时，父进程处理命令的同时，通过轮询来接收子进程的信号。\n\n#### 恢复\n\n在redis启动的时候，会检查是否rdb的二进制文件。有二进制文件，直接将文件拉取到内存中。恢复速度很快。\n\n#### 配置\n\n{% codeblock %}\n################################ SNAPSHOTTING  ################################\n#\n# Save the DB on disk:\n#\n#   save <seconds> <changes>\n#\n#   Will save the DB if both the given number of seconds and the given\n#   number of write operations against the DB occurred.\n#\n#   如果同时发生了给定的秒数和针对DB的给定写入操作数，则将保存数据库。\n#\n#   In the example below the behaviour will be to save:\n#   after 900 sec (15 min) if at least 1 key changed\n#   after 300 sec (5 min) if at least 10 keys changed\n#   after 60 sec if at least 10000 keys changed\n#\n#   在下面的示例中，行为将是保存：\n#           900秒后（15分钟）1个key改变\n#           300秒后 (5分钟) 10个key改变\n#           60秒后 10000 个key改变\n#           \n#\n#   Note: you can disable saving completely by commenting out all \"save\" lines.\n#\n#   注意：您可以通过注释掉所有“保存”行来完全禁用保存。\n#\n#   It is also possible to remove all the previously configured save\n#   points by adding a save directive with a single empty string argument\n#   like in the following example:\n#\n#   save \"\"\n#\n#   也可以通过添加带有单个空字符串参数的save指令来删除所有先前配置的保存点\n\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# By default Redis will stop accepting writes if RDB snapshots are enabled\n# (at least one save point) and the latest background save failed.\n# This will make the user aware (in a hard way) that data is not persisting\n# on disk properly, otherwise chances are that no one will notice and some\n# disaster will happen.\n#\n# 默认情况下，如果启用了RDB快照（至少一个保存点）并且最新的后台保存失败，Redis将停止接受写入。\n# 这将使用户意识到（以一种困难的方式）数据没有正确地保存在磁盘上，\n# 否则很可能没有人会注意到并且会发生一些灾难。\n#\n# If the background saving process will start working again Redis will\n# automatically allow writes again.\n#\n# 如果后台保存过程将再次开始工作，Redis将自动再次允许写入。\n#\n# However if you have setup your proper monitoring of the Redis server\n# and persistence, you may want to disable this feature so that Redis will\n# continue to work as usual even if there are problems with disk,\n# permissions, and so forth.\n#\n# 但是，如果您已设置对Redis服务器和持久性的正确监视，则可能需要禁用此功能\n# 以便即使磁盘，权限等存在问题，Redis也将继续正常工作。\n\nstop-writes-on-bgsave-error yes\n\n# Compress string objects using LZF when dump .rdb databases?\n# For default that's set to 'yes' as it's almost always a win.\n# If you want to save some CPU in the saving child set it to 'no' but\n# the dataset will likely be bigger if you have compressible values or keys.\n#\n# 当备份.rdb数据库时使用LZF压缩字符串对象？默认设置为“是”，因为它几乎总是一个胜利。\n# 如果要在保存子项中保存一些CPU，请将其设置为“否”，但如果您具有可压缩值或键，则数据集可能会更大。\n\nrdbcompression yes\n\n# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.\n# This makes the format more resistant to corruption but there is a performance\n# hit to pay (around 10%) when saving and loading RDB files, so you can disable it\n# for maximum performances.\n#\n# 从RDB的第5版开始，CRC64校验和被放置在文件的末尾。这使得格式更能抵抗损坏，\n# 但在保存和加载RDB文件时需要支付性能（大约10％），因此您可以禁用它以获得最佳性能。\n#\n# RDB files created with checksum disabled have a checksum of zero that will\n# tell the loading code to skip the check.\n#\n# 禁用校验和创建的RDB文件的校验和为零，将告诉加载代码跳过检查。\n\nrdbchecksum yes\n\n# The filename where to dump the DB\n#\n#rdb dump 文件名\n\ndbfilename dump.rdb\n\n# The working directory.\n#\n# The DB will be written inside this directory, with the filename specified\n# above using the 'dbfilename' configuration directive.\n#\n# The Append Only File will also be created inside this directory.\n#\n# Note that you must specify a directory here, not a file name.\n#\n# 文件位置\n\ndir ./\n{% endcodeblock %}\n\n\n\n### APPEND ONLY MODE aof(append of only)\n\n#### 介绍\n\n\n如果rdb过程中，机器出了问题，可能会丢失几分钟的数据。\n\naof功能类似于日志，会对每一条记录做记录，三种持久化的方案：\n\n* 每条记录都记录，但是会占用大量io，会把服务器拖慢\n* 每秒钟的数据写入磁盘，将一秒钟的数据写入磁盘，可能会丢失一秒钟的数据（官方默认的方案）\n* 不写入，只有命令执行的时候，才写入，会有很好的性能，但是丢失数据的风险非常大。\n\naof每条都记录，随着一直写入request，会导致aof文件会越来越大，并且在恢复的时候，每条都会执行\n可以使用aof重写，可以多条记录逆为一条命令，减小文件大小\n\n例子：\n{% codeblock %}\n// 重写前\nset wang 100\nincr wang   \nincr wnag\n\n// 重写后,逆为key最后的状态值\nset wang 102bg\n\n{% endcodeblock %}\n\n#### 相关命令\n\n* bgrewriteao：重写aof文件\n\n#### 恢复\n\n在开启aof持久化的时候，会监测是否有aof文件，优先加载aof文件，然后在监测rdb文件。\n\n重写后的aof文件更便于恢复，不用每条都写入，直接写入最后的状态值。\n\n#### 配置\n\n{% codeblock %}\n############################## APPEND ONLY MODE ###############################\n#\n# By default Redis asynchronously dumps the dataset on disk. This mode is\n# good enough in many applications, but an issue with the Redis process or\n# a power outage may result into a few minutes of writes lost (depending on\n# the configured save points).\n#\n# 默认情况下，Redis以异步方式将数据集转储到磁盘上。\n# 此模式在许多应用程序中都足够好，\n# 但Redis进程或停电的问题可能导致几分钟的写入丢失（取决于配置的保存点）。\n#\n# The Append Only File is an alternative persistence mode that provides\n# much better durability. For instance using the default data fsync policy\n# (see later in the config file) Redis can lose just one second of writes in a\n# dramatic event like a server power outage, or a single write if something\n# wrong with the Redis process itself happens, but the operating system is\n# still running correctly.\n#\n# 仅附加文件是一种备用持久性模式，可提供更好的持久性。\n# 例如，使用默认数据fsync策略（请参阅配置文件中的后面部分）\n# Redis在服务器断电等戏剧性事件中只会丢失一秒写入，\n# 如果Redis进程本身出现问题，则会丢失一次，但是操作系统仍然正常运行。\n#\n# AOF and RDB persistence can be enabled at the same time without problems.\n# If the AOF is enabled on startup Redis will load the AOF, that is the file\n# with the better durability guarantees.\n#\n# 可以同时启用AOF和RDB持久性而不会出现问题。\n# 如果在启动时启用AOF，Redis将加载AOF，即具有更好耐久性保证的文件。\n#\n# Please check http://redis.io/topics/persistence for more information.\n\nappendonly no\n\n# The name of the append only file (default: \"appendonly.aof\")\n\nappendfilename \"appendonly.aof\"\n\n# The fsync() call tells the Operating System to actually write data on disk\n# instead of waiting for more data in the output buffer. Some OS will really flush\n# data on disk, some other OS will just try to do it ASAP.\n#\n# aof调用告诉操作系统实际在磁盘上写入数据，\n# 而不是等待输出缓冲区中的更多数据。\n# 某些操作系统会真正刷新磁盘上的数据，其他一些操作系统会尽快尝试这样做。\n#\n# Redis supports three different modes:\n#\n# no: don't fsync, just let the OS flush the data when it wants. Faster.\n# always: fsync after every write to the append only log. Slow, Safest.\n# everysec: fsync only one time every second. Compromise.\n#\n# no：不要fsync，只需让操作系统在需要时刷新数据。\n# 快点。始终：每次写入仅附加日志后的fsync。慢，最安全。\n#  everysec：fsync每秒只有一次。妥协。\n#\n# The default is \"everysec\", as that's usually the right compromise between\n# speed and data safety. It's up to you to understand if you can relax this to\n# \"no\" that will let the operating system flush the output buffer when\n# it wants, for better performances (but if you can live with the idea of\n# some data loss consider the default persistence mode that's snapshotting),\n# or on the contrary, use \"always\" that's very slow but a bit safer than\n# everysec.\n#\n# 默认值为“everysec”，因为这通常是速度和数据安全之间的正确折衷。\n# 这取决于你是否可以理解你是否可以放松这个“不”，\n# 让操作系统在需要时刷新输出缓冲区，以获得更好的性能\n# （但如果你能想到一些数据丢失的想法，请考虑默认的持久性模式这是快照），\n# 或相反，使用“总是”，这是非常慢但比每秒更安全。\n#\n# More details please check the following article:\n# http://antirez.com/post/redis-persistence-demystified.html\n#\n# If unsure, use \"everysec\".\n\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n\n# When the AOF fsync policy is set to always or everysec, and a background\n# saving process (a background save or AOF log background rewriting) is\n# performing a lot of I/O against the disk, in some Linux configurations\n# Redis may block too long on the fsync() call. Note that there is no fix for\n# this currently, as even performing fsync in a different thread will block\n# our synchronous write(2) call.\n#\n# 当AOF fsync策略设置为always或everysec，\n# 并且后台保存过程（后台保存或AOF日志后台重写）\n# 正在对磁盘执行大量I / O时，在某些Linux配置中，\n# Redis可能会阻塞太长时间fsync（）调用。\n# 请注意，目前没有对此进行修复，\n# 因为即使在不同的线程中执行fsync也会阻止我们的同步write（2）调用。\n#\n# In order to mitigate this problem it's possible to use the following option\n# that will prevent fsync() from being called in the main process while a\n# BGSAVE or BGREWRITEAOF is in progress.\n#\n# 为了缓解此问题，可以使用以下选项，\n# 以防止在BGSAVE或BGREWRITEAOF正在进行时在主进程中调用fsync（）。\n#\n# This means that while another child is saving, the durability of Redis is\n# the same as \"appendfsync none\". In practical terms, this means that it is\n# possible to lose up to 30 seconds of log in the worst scenario (with the\n# default Linux settings).\n#\n# 这意味着当另一个孩子正在保存时，Redis的持久性与“appendfsync none”相同。\n# 实际上，这意味着在最糟糕的情况下（使用默认的Linux设置）可能会丢失最多30秒的日志。\n#\n# If you have latency problems turn this to \"yes\". Otherwise leave it as\n# \"no\" that is the safest pick from the point of view of durability.\n#\n# 如果您有延迟问题，请将其转为“是”。否则，从耐用性的角度来看，它是最“最安全”的选择。\n\nno-appendfsync-on-rewrite no\n\n# Automatic rewrite of the append only file.\n# Redis is able to automatically rewrite the log file implicitly calling\n# BGREWRITEAOF when the AOF log size grows by the specified percentage.\n#\n# 自动重写仅附加文件。当AOF日志大小增长指定的百分比时，\n# Redis能够自动重写日志文件，隐式调用BGREWRITEAOF。\n#\n# This is how it works: Redis remembers the size of the AOF file after the\n# latest rewrite (if no rewrite has happened since the restart, the size of\n# the AOF at startup is used).\n#\n# 这是它的工作原理：Redis在最近的重写后记住AOF文件的大小\n# （如果重启后没有重写，则使用启动时的AOF大小）。\n#\n# This base size is compared to the current size. If the current size is\n# bigger than the specified percentage, the rewrite is triggered. Also\n# you need to specify a minimal size for the AOF file to be rewritten, this\n# is useful to avoid rewriting the AOF file even if the percentage increase\n# is reached but it is still pretty small.\n#\n# 将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则触发重写。\n# 此外，您需要指定要重写的AOF文件的最小大小，\n# 这有助于避免重写AOF文件，即使达到百分比增加但仍然非常小。\n#\n# Specify a percentage of zero in order to disable the automatic AOF\n# rewrite feature.\n#\n# 指定零的百分比以禁用自动AOF重写功能。\n\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# An AOF file may be found to be truncated at the end during the Redis\n# startup process, when the AOF data gets loaded back into memory.\n# This may happen when the system where Redis is running\n# crashes, especially when an ext4 filesystem is mounted without the\n# data=ordered option (however this can't happen when Redis itself\n# crashes or aborts but the operating system still works correctly).\n#\n# 当AOF数据加载回内存时，可能会在Redis启动过程中发现AOF文件被截断。\n# 当Redis运行崩溃的系统时，尤其是在没有data = ordered选项的情况下挂载ext4文件系统时，\n# 可能会发生这种情况（但是当Redis本身崩溃或中止但操作系统仍能正常工作时，这种情况不会发生）。\n#\n# Redis can either exit with an error when this happens, or load as much\n# data as possible (the default now) and start if the AOF file is found\n# to be truncated at the end. The following option controls this behavior.\n#\n# 发生这种情况时，Redis可以退出，或者加载尽可能多的数据（现在是默认值），\n# 如果发现AOF文件在末尾被截断，则启动。以下选项控制此行为。\n#\n# If aof-load-truncated is set to yes, a truncated AOF file is loaded and\n# the Redis server starts emitting a log to inform the user of the event.\n# Otherwise if the option is set to no, the server aborts with an error\n# and refuses to start. When the option is set to no, the user requires\n# to fix the AOF file using the \"redis-check-aof\" utility before to restart\n# the server.\n#\n# 如果将aof-load-truncated设置为yes，则会加载截断的AOF文件，\n# 并且Redis服务器会开始发出日志以通知用户该事件。\n# 否则，如果该选项设置为no，则服务器将中止并显示错误并拒绝启动。\n# 当该选项设置为no时，用户需要使用“redis-check-aof”实用程序修复AOF文件，\n# 然后才能重新启动服务器。\n#\n# Note that if the AOF file will be found to be corrupted in the middle\n# the server will still exit with an error. This option only applies when\n# Redis will try to read more data from the AOF file but not enough bytes\n# will be found.\n#\n# 请注意，如果发现AOF文件在中间被破坏，服务器仍将退出并显示错误。\n# 此选项仅在Redis尝试从AOF文件中读取更多数据但不会找到足够的字节时适用。\n\naof-load-truncated yes\n\n# When rewriting the AOF file, Redis is able to use an RDB preamble in the\n# AOF file for faster rewrites and recoveries. When this option is turned\n# on the rewritten AOF file is composed of two different stanzas:\n#\n# 重写AOF文件时，Redis能够使用AOF文件中的RDB前导码来加快重写和恢复速度。\n# 启用此选项后，重写的AOF文件由两个不同的节组成：\n#\n#   [RDB file][AOF tail]\n#\n# When loading Redis recognizes that the AOF file starts with the \"REDIS\"\n# string and loads the prefixed RDB file, and continues loading the AOF\n# tail.\n#\n# 加载时Redis识别出AOF文件以“REDIS”字符串开头并加载前缀RDB文件，并继续加载AOF尾部。\n\naof-use-rdb-preamble yes\n{% endcodeblock %}\n\n\n\n","source":"_posts/redis-持久化.md","raw":"---\ntitle: redis-持久化\ndate: 2018-11-13 16:14:31\ntype: \"categories\"\ncategories: redis\ntags: redis\n---\n\n![](img/index-page-img/redis.jpg)\n\nredis两种持久化的方式，**rdb**(redis database)和**aof**(append of only)\n\n<!-- more -->\n\n### 介绍\n\nredis 是一个键值对存储数据库,基于内存存储,相对于传统基于磁盘做持久化的数据库,操作内存速度更快。所以也用来做缓存服务器。相对于memcache,redis提供了持久化的解决方案，数据安全性更高。\nredis提供的两种持久化方案，一个rdb(redis database)，一个是aof(append of only),本文将详细介绍这两种持久化。\n\n### SNAPSHOTTING rdb(redis database)\n\n#### 介绍\n\nrdb就是将redis内存中的数据做一个**快照**，经过**压缩**，以**二进制**文件的形式，保存到磁盘中。\n\n默认情况下，Redis以**异步方式**将数据集转储到磁盘上\n\n#### 相关命令\n\n* SAVE：阻塞redis的服务器进程，直到RDB文件被创建完毕。\n* BGSAVE：派生(fork)一个子进程来创建新的RDB文件，记录接收到BGSAVE当时的数据库状态，父进程继续处理接收到的命令，子进程完成文件的创建之后，会发送信号给父进程，而与此同时，父进程处理命令的同时，通过轮询来接收子进程的信号。\n\n#### 恢复\n\n在redis启动的时候，会检查是否rdb的二进制文件。有二进制文件，直接将文件拉取到内存中。恢复速度很快。\n\n#### 配置\n\n{% codeblock %}\n################################ SNAPSHOTTING  ################################\n#\n# Save the DB on disk:\n#\n#   save <seconds> <changes>\n#\n#   Will save the DB if both the given number of seconds and the given\n#   number of write operations against the DB occurred.\n#\n#   如果同时发生了给定的秒数和针对DB的给定写入操作数，则将保存数据库。\n#\n#   In the example below the behaviour will be to save:\n#   after 900 sec (15 min) if at least 1 key changed\n#   after 300 sec (5 min) if at least 10 keys changed\n#   after 60 sec if at least 10000 keys changed\n#\n#   在下面的示例中，行为将是保存：\n#           900秒后（15分钟）1个key改变\n#           300秒后 (5分钟) 10个key改变\n#           60秒后 10000 个key改变\n#           \n#\n#   Note: you can disable saving completely by commenting out all \"save\" lines.\n#\n#   注意：您可以通过注释掉所有“保存”行来完全禁用保存。\n#\n#   It is also possible to remove all the previously configured save\n#   points by adding a save directive with a single empty string argument\n#   like in the following example:\n#\n#   save \"\"\n#\n#   也可以通过添加带有单个空字符串参数的save指令来删除所有先前配置的保存点\n\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# By default Redis will stop accepting writes if RDB snapshots are enabled\n# (at least one save point) and the latest background save failed.\n# This will make the user aware (in a hard way) that data is not persisting\n# on disk properly, otherwise chances are that no one will notice and some\n# disaster will happen.\n#\n# 默认情况下，如果启用了RDB快照（至少一个保存点）并且最新的后台保存失败，Redis将停止接受写入。\n# 这将使用户意识到（以一种困难的方式）数据没有正确地保存在磁盘上，\n# 否则很可能没有人会注意到并且会发生一些灾难。\n#\n# If the background saving process will start working again Redis will\n# automatically allow writes again.\n#\n# 如果后台保存过程将再次开始工作，Redis将自动再次允许写入。\n#\n# However if you have setup your proper monitoring of the Redis server\n# and persistence, you may want to disable this feature so that Redis will\n# continue to work as usual even if there are problems with disk,\n# permissions, and so forth.\n#\n# 但是，如果您已设置对Redis服务器和持久性的正确监视，则可能需要禁用此功能\n# 以便即使磁盘，权限等存在问题，Redis也将继续正常工作。\n\nstop-writes-on-bgsave-error yes\n\n# Compress string objects using LZF when dump .rdb databases?\n# For default that's set to 'yes' as it's almost always a win.\n# If you want to save some CPU in the saving child set it to 'no' but\n# the dataset will likely be bigger if you have compressible values or keys.\n#\n# 当备份.rdb数据库时使用LZF压缩字符串对象？默认设置为“是”，因为它几乎总是一个胜利。\n# 如果要在保存子项中保存一些CPU，请将其设置为“否”，但如果您具有可压缩值或键，则数据集可能会更大。\n\nrdbcompression yes\n\n# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.\n# This makes the format more resistant to corruption but there is a performance\n# hit to pay (around 10%) when saving and loading RDB files, so you can disable it\n# for maximum performances.\n#\n# 从RDB的第5版开始，CRC64校验和被放置在文件的末尾。这使得格式更能抵抗损坏，\n# 但在保存和加载RDB文件时需要支付性能（大约10％），因此您可以禁用它以获得最佳性能。\n#\n# RDB files created with checksum disabled have a checksum of zero that will\n# tell the loading code to skip the check.\n#\n# 禁用校验和创建的RDB文件的校验和为零，将告诉加载代码跳过检查。\n\nrdbchecksum yes\n\n# The filename where to dump the DB\n#\n#rdb dump 文件名\n\ndbfilename dump.rdb\n\n# The working directory.\n#\n# The DB will be written inside this directory, with the filename specified\n# above using the 'dbfilename' configuration directive.\n#\n# The Append Only File will also be created inside this directory.\n#\n# Note that you must specify a directory here, not a file name.\n#\n# 文件位置\n\ndir ./\n{% endcodeblock %}\n\n\n\n### APPEND ONLY MODE aof(append of only)\n\n#### 介绍\n\n\n如果rdb过程中，机器出了问题，可能会丢失几分钟的数据。\n\naof功能类似于日志，会对每一条记录做记录，三种持久化的方案：\n\n* 每条记录都记录，但是会占用大量io，会把服务器拖慢\n* 每秒钟的数据写入磁盘，将一秒钟的数据写入磁盘，可能会丢失一秒钟的数据（官方默认的方案）\n* 不写入，只有命令执行的时候，才写入，会有很好的性能，但是丢失数据的风险非常大。\n\naof每条都记录，随着一直写入request，会导致aof文件会越来越大，并且在恢复的时候，每条都会执行\n可以使用aof重写，可以多条记录逆为一条命令，减小文件大小\n\n例子：\n{% codeblock %}\n// 重写前\nset wang 100\nincr wang   \nincr wnag\n\n// 重写后,逆为key最后的状态值\nset wang 102bg\n\n{% endcodeblock %}\n\n#### 相关命令\n\n* bgrewriteao：重写aof文件\n\n#### 恢复\n\n在开启aof持久化的时候，会监测是否有aof文件，优先加载aof文件，然后在监测rdb文件。\n\n重写后的aof文件更便于恢复，不用每条都写入，直接写入最后的状态值。\n\n#### 配置\n\n{% codeblock %}\n############################## APPEND ONLY MODE ###############################\n#\n# By default Redis asynchronously dumps the dataset on disk. This mode is\n# good enough in many applications, but an issue with the Redis process or\n# a power outage may result into a few minutes of writes lost (depending on\n# the configured save points).\n#\n# 默认情况下，Redis以异步方式将数据集转储到磁盘上。\n# 此模式在许多应用程序中都足够好，\n# 但Redis进程或停电的问题可能导致几分钟的写入丢失（取决于配置的保存点）。\n#\n# The Append Only File is an alternative persistence mode that provides\n# much better durability. For instance using the default data fsync policy\n# (see later in the config file) Redis can lose just one second of writes in a\n# dramatic event like a server power outage, or a single write if something\n# wrong with the Redis process itself happens, but the operating system is\n# still running correctly.\n#\n# 仅附加文件是一种备用持久性模式，可提供更好的持久性。\n# 例如，使用默认数据fsync策略（请参阅配置文件中的后面部分）\n# Redis在服务器断电等戏剧性事件中只会丢失一秒写入，\n# 如果Redis进程本身出现问题，则会丢失一次，但是操作系统仍然正常运行。\n#\n# AOF and RDB persistence can be enabled at the same time without problems.\n# If the AOF is enabled on startup Redis will load the AOF, that is the file\n# with the better durability guarantees.\n#\n# 可以同时启用AOF和RDB持久性而不会出现问题。\n# 如果在启动时启用AOF，Redis将加载AOF，即具有更好耐久性保证的文件。\n#\n# Please check http://redis.io/topics/persistence for more information.\n\nappendonly no\n\n# The name of the append only file (default: \"appendonly.aof\")\n\nappendfilename \"appendonly.aof\"\n\n# The fsync() call tells the Operating System to actually write data on disk\n# instead of waiting for more data in the output buffer. Some OS will really flush\n# data on disk, some other OS will just try to do it ASAP.\n#\n# aof调用告诉操作系统实际在磁盘上写入数据，\n# 而不是等待输出缓冲区中的更多数据。\n# 某些操作系统会真正刷新磁盘上的数据，其他一些操作系统会尽快尝试这样做。\n#\n# Redis supports three different modes:\n#\n# no: don't fsync, just let the OS flush the data when it wants. Faster.\n# always: fsync after every write to the append only log. Slow, Safest.\n# everysec: fsync only one time every second. Compromise.\n#\n# no：不要fsync，只需让操作系统在需要时刷新数据。\n# 快点。始终：每次写入仅附加日志后的fsync。慢，最安全。\n#  everysec：fsync每秒只有一次。妥协。\n#\n# The default is \"everysec\", as that's usually the right compromise between\n# speed and data safety. It's up to you to understand if you can relax this to\n# \"no\" that will let the operating system flush the output buffer when\n# it wants, for better performances (but if you can live with the idea of\n# some data loss consider the default persistence mode that's snapshotting),\n# or on the contrary, use \"always\" that's very slow but a bit safer than\n# everysec.\n#\n# 默认值为“everysec”，因为这通常是速度和数据安全之间的正确折衷。\n# 这取决于你是否可以理解你是否可以放松这个“不”，\n# 让操作系统在需要时刷新输出缓冲区，以获得更好的性能\n# （但如果你能想到一些数据丢失的想法，请考虑默认的持久性模式这是快照），\n# 或相反，使用“总是”，这是非常慢但比每秒更安全。\n#\n# More details please check the following article:\n# http://antirez.com/post/redis-persistence-demystified.html\n#\n# If unsure, use \"everysec\".\n\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n\n# When the AOF fsync policy is set to always or everysec, and a background\n# saving process (a background save or AOF log background rewriting) is\n# performing a lot of I/O against the disk, in some Linux configurations\n# Redis may block too long on the fsync() call. Note that there is no fix for\n# this currently, as even performing fsync in a different thread will block\n# our synchronous write(2) call.\n#\n# 当AOF fsync策略设置为always或everysec，\n# 并且后台保存过程（后台保存或AOF日志后台重写）\n# 正在对磁盘执行大量I / O时，在某些Linux配置中，\n# Redis可能会阻塞太长时间fsync（）调用。\n# 请注意，目前没有对此进行修复，\n# 因为即使在不同的线程中执行fsync也会阻止我们的同步write（2）调用。\n#\n# In order to mitigate this problem it's possible to use the following option\n# that will prevent fsync() from being called in the main process while a\n# BGSAVE or BGREWRITEAOF is in progress.\n#\n# 为了缓解此问题，可以使用以下选项，\n# 以防止在BGSAVE或BGREWRITEAOF正在进行时在主进程中调用fsync（）。\n#\n# This means that while another child is saving, the durability of Redis is\n# the same as \"appendfsync none\". In practical terms, this means that it is\n# possible to lose up to 30 seconds of log in the worst scenario (with the\n# default Linux settings).\n#\n# 这意味着当另一个孩子正在保存时，Redis的持久性与“appendfsync none”相同。\n# 实际上，这意味着在最糟糕的情况下（使用默认的Linux设置）可能会丢失最多30秒的日志。\n#\n# If you have latency problems turn this to \"yes\". Otherwise leave it as\n# \"no\" that is the safest pick from the point of view of durability.\n#\n# 如果您有延迟问题，请将其转为“是”。否则，从耐用性的角度来看，它是最“最安全”的选择。\n\nno-appendfsync-on-rewrite no\n\n# Automatic rewrite of the append only file.\n# Redis is able to automatically rewrite the log file implicitly calling\n# BGREWRITEAOF when the AOF log size grows by the specified percentage.\n#\n# 自动重写仅附加文件。当AOF日志大小增长指定的百分比时，\n# Redis能够自动重写日志文件，隐式调用BGREWRITEAOF。\n#\n# This is how it works: Redis remembers the size of the AOF file after the\n# latest rewrite (if no rewrite has happened since the restart, the size of\n# the AOF at startup is used).\n#\n# 这是它的工作原理：Redis在最近的重写后记住AOF文件的大小\n# （如果重启后没有重写，则使用启动时的AOF大小）。\n#\n# This base size is compared to the current size. If the current size is\n# bigger than the specified percentage, the rewrite is triggered. Also\n# you need to specify a minimal size for the AOF file to be rewritten, this\n# is useful to avoid rewriting the AOF file even if the percentage increase\n# is reached but it is still pretty small.\n#\n# 将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则触发重写。\n# 此外，您需要指定要重写的AOF文件的最小大小，\n# 这有助于避免重写AOF文件，即使达到百分比增加但仍然非常小。\n#\n# Specify a percentage of zero in order to disable the automatic AOF\n# rewrite feature.\n#\n# 指定零的百分比以禁用自动AOF重写功能。\n\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# An AOF file may be found to be truncated at the end during the Redis\n# startup process, when the AOF data gets loaded back into memory.\n# This may happen when the system where Redis is running\n# crashes, especially when an ext4 filesystem is mounted without the\n# data=ordered option (however this can't happen when Redis itself\n# crashes or aborts but the operating system still works correctly).\n#\n# 当AOF数据加载回内存时，可能会在Redis启动过程中发现AOF文件被截断。\n# 当Redis运行崩溃的系统时，尤其是在没有data = ordered选项的情况下挂载ext4文件系统时，\n# 可能会发生这种情况（但是当Redis本身崩溃或中止但操作系统仍能正常工作时，这种情况不会发生）。\n#\n# Redis can either exit with an error when this happens, or load as much\n# data as possible (the default now) and start if the AOF file is found\n# to be truncated at the end. The following option controls this behavior.\n#\n# 发生这种情况时，Redis可以退出，或者加载尽可能多的数据（现在是默认值），\n# 如果发现AOF文件在末尾被截断，则启动。以下选项控制此行为。\n#\n# If aof-load-truncated is set to yes, a truncated AOF file is loaded and\n# the Redis server starts emitting a log to inform the user of the event.\n# Otherwise if the option is set to no, the server aborts with an error\n# and refuses to start. When the option is set to no, the user requires\n# to fix the AOF file using the \"redis-check-aof\" utility before to restart\n# the server.\n#\n# 如果将aof-load-truncated设置为yes，则会加载截断的AOF文件，\n# 并且Redis服务器会开始发出日志以通知用户该事件。\n# 否则，如果该选项设置为no，则服务器将中止并显示错误并拒绝启动。\n# 当该选项设置为no时，用户需要使用“redis-check-aof”实用程序修复AOF文件，\n# 然后才能重新启动服务器。\n#\n# Note that if the AOF file will be found to be corrupted in the middle\n# the server will still exit with an error. This option only applies when\n# Redis will try to read more data from the AOF file but not enough bytes\n# will be found.\n#\n# 请注意，如果发现AOF文件在中间被破坏，服务器仍将退出并显示错误。\n# 此选项仅在Redis尝试从AOF文件中读取更多数据但不会找到足够的字节时适用。\n\naof-load-truncated yes\n\n# When rewriting the AOF file, Redis is able to use an RDB preamble in the\n# AOF file for faster rewrites and recoveries. When this option is turned\n# on the rewritten AOF file is composed of two different stanzas:\n#\n# 重写AOF文件时，Redis能够使用AOF文件中的RDB前导码来加快重写和恢复速度。\n# 启用此选项后，重写的AOF文件由两个不同的节组成：\n#\n#   [RDB file][AOF tail]\n#\n# When loading Redis recognizes that the AOF file starts with the \"REDIS\"\n# string and loads the prefixed RDB file, and continues loading the AOF\n# tail.\n#\n# 加载时Redis识别出AOF文件以“REDIS”字符串开头并加载前缀RDB文件，并继续加载AOF尾部。\n\naof-use-rdb-preamble yes\n{% endcodeblock %}\n\n\n\n","slug":"redis-持久化","published":1,"updated":"2018-11-14T06:05:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syo0000p43xru5ecdcro","content":"<p><img src=\"img/index-page-img/redis.jpg\" alt=\"\"></p>\n<p>redis两种持久化的方式，<strong>rdb</strong>(redis database)和<strong>aof</strong>(append of only)</p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>redis 是一个键值对存储数据库,基于内存存储,相对于传统基于磁盘做持久化的数据库,操作内存速度更快。所以也用来做缓存服务器。相对于memcache,redis提供了持久化的解决方案，数据安全性更高。<br>redis提供的两种持久化方案，一个rdb(redis database)，一个是aof(append of only),本文将详细介绍这两种持久化。</p>\n<h3 id=\"SNAPSHOTTING-rdb-redis-database\"><a href=\"#SNAPSHOTTING-rdb-redis-database\" class=\"headerlink\" title=\"SNAPSHOTTING rdb(redis database)\"></a>SNAPSHOTTING rdb(redis database)</h3><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>rdb就是将redis内存中的数据做一个<strong>快照</strong>，经过<strong>压缩</strong>，以<strong>二进制</strong>文件的形式，保存到磁盘中。</p>\n<p>默认情况下，Redis以<strong>异步方式</strong>将数据集转储到磁盘上</p>\n<h4 id=\"相关命令\"><a href=\"#相关命令\" class=\"headerlink\" title=\"相关命令\"></a>相关命令</h4><ul>\n<li>SAVE：阻塞redis的服务器进程，直到RDB文件被创建完毕。</li>\n<li>BGSAVE：派生(fork)一个子进程来创建新的RDB文件，记录接收到BGSAVE当时的数据库状态，父进程继续处理接收到的命令，子进程完成文件的创建之后，会发送信号给父进程，而与此同时，父进程处理命令的同时，通过轮询来接收子进程的信号。</li>\n</ul>\n<h4 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h4><p>在redis启动的时候，会检查是否rdb的二进制文件。有二进制文件，直接将文件拉取到内存中。恢复速度很快。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">############################### SNAPSHOTTING  ################################</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Save the DB on disk:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   Will save the DB <span class=\"keyword\">if</span> both the given number of seconds and the given</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   number of write operations against the DB occurred.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   如果同时发生了给定的秒数和针对DB的给定写入操作数，则将保存数据库。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   In the example below the behaviour will be to save:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   after 900 sec (15 min) <span class=\"keyword\">if</span> at least 1 key changed</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   after 300 sec (5 min) <span class=\"keyword\">if</span> at least 10 keys changed</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   after 60 sec <span class=\"keyword\">if</span> at least 10000 keys changed</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   在下面的示例中，行为将是保存：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">           900秒后（15分钟）1个key改变</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">           300秒后 (5分钟) 10个key改变</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">           60秒后 10000 个key改变</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">           </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   Note: you can <span class=\"built_in\">disable</span> saving completely by commenting out all <span class=\"string\">\"save\"</span> lines.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   注意：您可以通过注释掉所有“保存”行来完全禁用保存。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   It is also possible to remove all the previously configured save</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   points by adding a save directive with a single empty string argument</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   like <span class=\"keyword\">in</span> the following example:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   save <span class=\"string\">\"\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   也可以通过添加带有单个空字符串参数的save指令来删除所有先前配置的保存点</span></span><br><span class=\"line\"></span><br><span class=\"line\">save 900 1</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\">save 60 10000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> By default Redis will stop accepting writes <span class=\"keyword\">if</span> RDB snapshots are enabled</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> (at least one save point) and the latest background save failed.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This will make the user aware (<span class=\"keyword\">in</span> a hard way) that data is not persisting</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> on disk properly, otherwise chances are that no one will notice and some</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> disaster will happen.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 默认情况下，如果启用了RDB快照（至少一个保存点）并且最新的后台保存失败，Redis将停止接受写入。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这将使用户意识到（以一种困难的方式）数据没有正确地保存在磁盘上，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 否则很可能没有人会注意到并且会发生一些灾难。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If the background saving process will start working again Redis will</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> automatically allow writes again.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果后台保存过程将再次开始工作，Redis将自动再次允许写入。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> However <span class=\"keyword\">if</span> you have setup your proper monitoring of the Redis server</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> and persistence, you may want to <span class=\"built_in\">disable</span> this feature so that Redis will</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">continue</span> to work as usual even <span class=\"keyword\">if</span> there are problems with disk,</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> permissions, and so forth.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 但是，如果您已设置对Redis服务器和持久性的正确监视，则可能需要禁用此功能</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以便即使磁盘，权限等存在问题，Redis也将继续正常工作。</span></span><br><span class=\"line\"></span><br><span class=\"line\">stop-writes-on-bgsave-error yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Compress string objects using LZF when dump .rdb databases?</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> For default that<span class=\"string\">'s set to '</span>yes<span class=\"string\">' as it'</span>s almost always a win.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If you want to save some CPU <span class=\"keyword\">in</span> the saving child <span class=\"built_in\">set</span> it to <span class=\"string\">'no'</span> but</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the dataset will likely be bigger <span class=\"keyword\">if</span> you have compressible values or keys.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当备份.rdb数据库时使用LZF压缩字符串对象？默认设置为“是”，因为它几乎总是一个胜利。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果要在保存子项中保存一些CPU，请将其设置为“否”，但如果您具有可压缩值或键，则数据集可能会更大。</span></span><br><span class=\"line\"></span><br><span class=\"line\">rdbcompression yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This makes the format more resistant to corruption but there is a performance</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hit to pay (around 10%) when saving and loading RDB files, so you can <span class=\"built_in\">disable</span> it</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"keyword\">for</span> maximum performances.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 从RDB的第5版开始，CRC64校验和被放置在文件的末尾。这使得格式更能抵抗损坏，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 但在保存和加载RDB文件时需要支付性能（大约10％），因此您可以禁用它以获得最佳性能。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> RDB files created with checksum disabled have a checksum of zero that will</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tell the loading code to skip the check.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 禁用校验和创建的RDB文件的校验和为零，将告诉加载代码跳过检查。</span></span><br><span class=\"line\"></span><br><span class=\"line\">rdbchecksum yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The filename <span class=\"built_in\">where</span> to dump the DB</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">rdb dump 文件名</span></span><br><span class=\"line\"></span><br><span class=\"line\">dbfilename dump.rdb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The working directory.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The DB will be written inside this directory, with the filename specified</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> above using the <span class=\"string\">'dbfilename'</span> configuration directive.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The Append Only File will also be created inside this directory.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Note that you must specify a directory here, not a file name.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 文件位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">dir ./</span><br></pre></td></tr></table></figure>\n<h3 id=\"APPEND-ONLY-MODE-aof-append-of-only\"><a href=\"#APPEND-ONLY-MODE-aof-append-of-only\" class=\"headerlink\" title=\"APPEND ONLY MODE aof(append of only)\"></a>APPEND ONLY MODE aof(append of only)</h3><h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>如果rdb过程中，机器出了问题，可能会丢失几分钟的数据。</p>\n<p>aof功能类似于日志，会对每一条记录做记录，三种持久化的方案：</p>\n<ul>\n<li>每条记录都记录，但是会占用大量io，会把服务器拖慢</li>\n<li>每秒钟的数据写入磁盘，将一秒钟的数据写入磁盘，可能会丢失一秒钟的数据（官方默认的方案）</li>\n<li>不写入，只有命令执行的时候，才写入，会有很好的性能，但是丢失数据的风险非常大。</li>\n</ul>\n<p>aof每条都记录，随着一直写入request，会导致aof文件会越来越大，并且在恢复的时候，每条都会执行<br>可以使用aof重写，可以多条记录逆为一条命令，减小文件大小</p>\n<p>例子：<br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重写前</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> wang <span class=\"comment\">100</span></span><br><span class=\"line\">incr <span class=\"comment\">wang</span>   </span><br><span class=\"line\">incr <span class=\"comment\">wnag</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写后,逆为key最后的状态值</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"comment\">wang 102bg</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"相关命令-1\"><a href=\"#相关命令-1\" class=\"headerlink\" title=\"相关命令\"></a>相关命令</h4><ul>\n<li>bgrewriteao：重写aof文件</li>\n</ul>\n<h4 id=\"恢复-1\"><a href=\"#恢复-1\" class=\"headerlink\" title=\"恢复\"></a>恢复</h4><p>在开启aof持久化的时候，会监测是否有aof文件，优先加载aof文件，然后在监测rdb文件。</p>\n<p>重写后的aof文件更便于恢复，不用每条都写入，直接写入最后的状态值。</p>\n<h4 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">############################# APPEND ONLY MODE ###############################</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> By default Redis asynchronously dumps the dataset on disk. This mode is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> good enough <span class=\"keyword\">in</span> many applications, but an issue with the Redis process or</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> a power outage may result into a few minutes of writes lost (depending on</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the configured save points).</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 默认情况下，Redis以异步方式将数据集转储到磁盘上。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 此模式在许多应用程序中都足够好，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 但Redis进程或停电的问题可能导致几分钟的写入丢失（取决于配置的保存点）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The Append Only File is an alternative persistence mode that provides</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> much better durability. For instance using the default data fsync policy</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> (see later <span class=\"keyword\">in</span> the config file) Redis can lose just one second of writes <span class=\"keyword\">in</span> a</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dramatic event like a server power outage, or a single write <span class=\"keyword\">if</span> something</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> wrong with the Redis process itself happens, but the operating system is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> still running correctly.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 仅附加文件是一种备用持久性模式，可提供更好的持久性。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例如，使用默认数据fsync策略（请参阅配置文件中的后面部分）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis在服务器断电等戏剧性事件中只会丢失一秒写入，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果Redis进程本身出现问题，则会丢失一次，但是操作系统仍然正常运行。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> with the better durability guarantees.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 可以同时启用AOF和RDB持久性而不会出现问题。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果在启动时启用AOF，Redis将加载AOF，即具有更好耐久性保证的文件。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Please check http://redis.io/topics/persistence <span class=\"keyword\">for</span> more information.</span></span><br><span class=\"line\"></span><br><span class=\"line\">appendonly no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The name of the append only file (default: <span class=\"string\">\"appendonly.aof\"</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">appendfilename \"appendonly.aof\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The fsync() call tells the Operating System to actually write data on disk</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> instead of waiting <span class=\"keyword\">for</span> more data <span class=\"keyword\">in</span> the output buffer. Some OS will really flush</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> data on disk, some other OS will just try to <span class=\"keyword\">do</span> it ASAP.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aof调用告诉操作系统实际在磁盘上写入数据，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 而不是等待输出缓冲区中的更多数据。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 某些操作系统会真正刷新磁盘上的数据，其他一些操作系统会尽快尝试这样做。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis supports three different modes:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> no: don<span class=\"string\">'t fsync, just let the OS flush the data when it wants. Faster.</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> always: fsync after every write to the append only <span class=\"built_in\">log</span>. Slow, Safest.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> everysec: fsync only one time every second. Compromise.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> no：不要fsync，只需让操作系统在需要时刷新数据。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 快点。始终：每次写入仅附加日志后的fsync。慢，最安全。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">  everysec：fsync每秒只有一次。妥协。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The default is <span class=\"string\">\"everysec\"</span>, as that<span class=\"string\">'s usually the right compromise between</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> speed and data safety. It<span class=\"string\">'s up to you to understand if you can relax this to</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"string\">\"no\"</span> that will <span class=\"built_in\">let</span> the operating system flush the output buffer when</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> it wants, <span class=\"keyword\">for</span> better performances (but <span class=\"keyword\">if</span> you can live with the idea of</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> some data loss consider the default persistence mode that<span class=\"string\">'s snapshotting),</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> or on the contrary, use <span class=\"string\">\"always\"</span> that<span class=\"string\">'s very slow but a bit safer than</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> everysec.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 默认值为“everysec”，因为这通常是速度和数据安全之间的正确折衷。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这取决于你是否可以理解你是否可以放松这个“不”，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 让操作系统在需要时刷新输出缓冲区，以获得更好的性能</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> （但如果你能想到一些数据丢失的想法，请考虑默认的持久性模式这是快照），</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 或相反，使用“总是”，这是非常慢但比每秒更安全。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> More details please check the following article:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If unsure, use <span class=\"string\">\"everysec\"</span>.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> appendfsync always</span></span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> appendfsync no</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> When the AOF fsync policy is <span class=\"built_in\">set</span> to always or everysec, and a background</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> saving process (a background save or AOF <span class=\"built_in\">log</span> background rewriting) is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> performing a lot of I/O against the disk, <span class=\"keyword\">in</span> some Linux configurations</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis may block too long on the fsync() call. Note that there is no fix <span class=\"keyword\">for</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> this currently, as even performing fsync <span class=\"keyword\">in</span> a different thread will block</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> our synchronous write(2) call.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当AOF fsync策略设置为always或everysec，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 并且后台保存过程（后台保存或AOF日志后台重写）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 正在对磁盘执行大量I / O时，在某些Linux配置中，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis可能会阻塞太长时间fsync（）调用。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 请注意，目前没有对此进行修复，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 因为即使在不同的线程中执行fsync也会阻止我们的同步write（2）调用。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> In order to mitigate this problem it<span class=\"string\">'s possible to use the following option</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> that will prevent fsync() from being called <span class=\"keyword\">in</span> the main process <span class=\"keyword\">while</span> a</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> BGSAVE or BGREWRITEAOF is <span class=\"keyword\">in</span> progress.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 为了缓解此问题，可以使用以下选项，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以防止在BGSAVE或BGREWRITEAOF正在进行时在主进程中调用fsync（）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This means that <span class=\"keyword\">while</span> another child is saving, the durability of Redis is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the same as <span class=\"string\">\"appendfsync none\"</span>. In practical terms, this means that it is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> possible to lose up to 30 seconds of <span class=\"built_in\">log</span> <span class=\"keyword\">in</span> the worst scenario (with the</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> default Linux settings).</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这意味着当另一个孩子正在保存时，Redis的持久性与“appendfsync none”相同。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 实际上，这意味着在最糟糕的情况下（使用默认的Linux设置）可能会丢失最多30秒的日志。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If you have latency problems turn this to <span class=\"string\">\"yes\"</span>. Otherwise leave it as</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"string\">\"no\"</span> that is the safest pick from the point of view of durability.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果您有延迟问题，请将其转为“是”。否则，从耐用性的角度来看，它是最“最安全”的选择。</span></span><br><span class=\"line\"></span><br><span class=\"line\">no-appendfsync-on-rewrite no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Automatic rewrite of the append only file.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis is able to automatically rewrite the <span class=\"built_in\">log</span> file implicitly calling</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> BGREWRITEAOF when the AOF <span class=\"built_in\">log</span> size grows by the specified percentage.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 自动重写仅附加文件。当AOF日志大小增长指定的百分比时，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis能够自动重写日志文件，隐式调用BGREWRITEAOF。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This is how it works: Redis remembers the size of the AOF file after the</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> latest rewrite (<span class=\"keyword\">if</span> no rewrite has happened since the restart, the size of</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the AOF at startup is used).</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是它的工作原理：Redis在最近的重写后记住AOF文件的大小</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> （如果重启后没有重写，则使用启动时的AOF大小）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This base size is compared to the current size. If the current size is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> you need to specify a minimal size <span class=\"keyword\">for</span> the AOF file to be rewritten, this</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> is useful to avoid rewriting the AOF file even <span class=\"keyword\">if</span> the percentage increase</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> is reached but it is still pretty small.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则触发重写。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 此外，您需要指定要重写的AOF文件的最小大小，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这有助于避免重写AOF文件，即使达到百分比增加但仍然非常小。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Specify a percentage of zero <span class=\"keyword\">in</span> order to <span class=\"built_in\">disable</span> the automatic AOF</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rewrite feature.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定零的百分比以禁用自动AOF重写功能。</span></span><br><span class=\"line\"></span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> An AOF file may be found to be truncated at the end during the Redis</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> startup process, when the AOF data gets loaded back into memory.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This may happen when the system <span class=\"built_in\">where</span> Redis is running</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> crashes, especially when an ext4 filesystem is mounted without the</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> data=ordered option (however this can<span class=\"string\">'t happen when Redis itself</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> crashes or aborts but the operating system still works correctly).</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当AOF数据加载回内存时，可能会在Redis启动过程中发现AOF文件被截断。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当Redis运行崩溃的系统时，尤其是在没有data = ordered选项的情况下挂载ext4文件系统时，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 可能会发生这种情况（但是当Redis本身崩溃或中止但操作系统仍能正常工作时，这种情况不会发生）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis can either <span class=\"built_in\">exit</span> with an error when this happens, or load as much</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> data as possible (the default now) and start <span class=\"keyword\">if</span> the AOF file is found</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> to be truncated at the end. The following option controls this behavior.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 发生这种情况时，Redis可以退出，或者加载尽可能多的数据（现在是默认值），</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果发现AOF文件在末尾被截断，则启动。以下选项控制此行为。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If aof-load-truncated is <span class=\"built_in\">set</span> to yes, a truncated AOF file is loaded and</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the Redis server starts emitting a <span class=\"built_in\">log</span> to inform the user of the event.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Otherwise <span class=\"keyword\">if</span> the option is <span class=\"built_in\">set</span> to no, the server aborts with an error</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> and refuses to start. When the option is <span class=\"built_in\">set</span> to no, the user requires</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> to fix the AOF file using the <span class=\"string\">\"redis-check-aof\"</span> utility before to restart</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the server.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果将aof-load-truncated设置为yes，则会加载截断的AOF文件，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 并且Redis服务器会开始发出日志以通知用户该事件。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 否则，如果该选项设置为no，则服务器将中止并显示错误并拒绝启动。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当该选项设置为no时，用户需要使用“redis-check-aof”实用程序修复AOF文件，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 然后才能重新启动服务器。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Note that <span class=\"keyword\">if</span> the AOF file will be found to be corrupted <span class=\"keyword\">in</span> the middle</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the server will still <span class=\"built_in\">exit</span> with an error. This option only applies when</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis will try to <span class=\"built_in\">read</span> more data from the AOF file but not enough bytes</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> will be found.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 请注意，如果发现AOF文件在中间被破坏，服务器仍将退出并显示错误。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 此选项仅在Redis尝试从AOF文件中读取更多数据但不会找到足够的字节时适用。</span></span><br><span class=\"line\"></span><br><span class=\"line\">aof-load-truncated yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> When rewriting the AOF file, Redis is able to use an RDB preamble <span class=\"keyword\">in</span> the</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> AOF file <span class=\"keyword\">for</span> faster rewrites and recoveries. When this option is turned</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> on the rewritten AOF file is composed of two different stanzas:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重写AOF文件时，Redis能够使用AOF文件中的RDB前导码来加快重写和恢复速度。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 启用此选项后，重写的AOF文件由两个不同的节组成：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   [RDB file][AOF tail]</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> When loading Redis recognizes that the AOF file starts with the <span class=\"string\">\"REDIS\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> string and loads the prefixed RDB file, and continues loading the AOF</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tail.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 加载时Redis识别出AOF文件以“REDIS”字符串开头并加载前缀RDB文件，并继续加载AOF尾部。</span></span><br><span class=\"line\"></span><br><span class=\"line\">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/redis.jpg\" alt=\"\"></p>\n<p>redis两种持久化的方式，<strong>rdb</strong>(redis database)和<strong>aof</strong>(append of only)</p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>redis 是一个键值对存储数据库,基于内存存储,相对于传统基于磁盘做持久化的数据库,操作内存速度更快。所以也用来做缓存服务器。相对于memcache,redis提供了持久化的解决方案，数据安全性更高。<br>redis提供的两种持久化方案，一个rdb(redis database)，一个是aof(append of only),本文将详细介绍这两种持久化。</p>\n<h3 id=\"SNAPSHOTTING-rdb-redis-database\"><a href=\"#SNAPSHOTTING-rdb-redis-database\" class=\"headerlink\" title=\"SNAPSHOTTING rdb(redis database)\"></a>SNAPSHOTTING rdb(redis database)</h3><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>rdb就是将redis内存中的数据做一个<strong>快照</strong>，经过<strong>压缩</strong>，以<strong>二进制</strong>文件的形式，保存到磁盘中。</p>\n<p>默认情况下，Redis以<strong>异步方式</strong>将数据集转储到磁盘上</p>\n<h4 id=\"相关命令\"><a href=\"#相关命令\" class=\"headerlink\" title=\"相关命令\"></a>相关命令</h4><ul>\n<li>SAVE：阻塞redis的服务器进程，直到RDB文件被创建完毕。</li>\n<li>BGSAVE：派生(fork)一个子进程来创建新的RDB文件，记录接收到BGSAVE当时的数据库状态，父进程继续处理接收到的命令，子进程完成文件的创建之后，会发送信号给父进程，而与此同时，父进程处理命令的同时，通过轮询来接收子进程的信号。</li>\n</ul>\n<h4 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h4><p>在redis启动的时候，会检查是否rdb的二进制文件。有二进制文件，直接将文件拉取到内存中。恢复速度很快。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">############################### SNAPSHOTTING  ################################</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Save the DB on disk:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   Will save the DB <span class=\"keyword\">if</span> both the given number of seconds and the given</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   number of write operations against the DB occurred.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   如果同时发生了给定的秒数和针对DB的给定写入操作数，则将保存数据库。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   In the example below the behaviour will be to save:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   after 900 sec (15 min) <span class=\"keyword\">if</span> at least 1 key changed</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   after 300 sec (5 min) <span class=\"keyword\">if</span> at least 10 keys changed</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   after 60 sec <span class=\"keyword\">if</span> at least 10000 keys changed</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   在下面的示例中，行为将是保存：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">           900秒后（15分钟）1个key改变</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">           300秒后 (5分钟) 10个key改变</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">           60秒后 10000 个key改变</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">           </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   Note: you can <span class=\"built_in\">disable</span> saving completely by commenting out all <span class=\"string\">\"save\"</span> lines.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   注意：您可以通过注释掉所有“保存”行来完全禁用保存。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   It is also possible to remove all the previously configured save</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   points by adding a save directive with a single empty string argument</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   like <span class=\"keyword\">in</span> the following example:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   save <span class=\"string\">\"\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   也可以通过添加带有单个空字符串参数的save指令来删除所有先前配置的保存点</span></span><br><span class=\"line\"></span><br><span class=\"line\">save 900 1</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\">save 60 10000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> By default Redis will stop accepting writes <span class=\"keyword\">if</span> RDB snapshots are enabled</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> (at least one save point) and the latest background save failed.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This will make the user aware (<span class=\"keyword\">in</span> a hard way) that data is not persisting</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> on disk properly, otherwise chances are that no one will notice and some</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> disaster will happen.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 默认情况下，如果启用了RDB快照（至少一个保存点）并且最新的后台保存失败，Redis将停止接受写入。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这将使用户意识到（以一种困难的方式）数据没有正确地保存在磁盘上，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 否则很可能没有人会注意到并且会发生一些灾难。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If the background saving process will start working again Redis will</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> automatically allow writes again.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果后台保存过程将再次开始工作，Redis将自动再次允许写入。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> However <span class=\"keyword\">if</span> you have setup your proper monitoring of the Redis server</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> and persistence, you may want to <span class=\"built_in\">disable</span> this feature so that Redis will</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">continue</span> to work as usual even <span class=\"keyword\">if</span> there are problems with disk,</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> permissions, and so forth.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 但是，如果您已设置对Redis服务器和持久性的正确监视，则可能需要禁用此功能</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以便即使磁盘，权限等存在问题，Redis也将继续正常工作。</span></span><br><span class=\"line\"></span><br><span class=\"line\">stop-writes-on-bgsave-error yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Compress string objects using LZF when dump .rdb databases?</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> For default that<span class=\"string\">'s set to '</span>yes<span class=\"string\">' as it'</span>s almost always a win.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If you want to save some CPU <span class=\"keyword\">in</span> the saving child <span class=\"built_in\">set</span> it to <span class=\"string\">'no'</span> but</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the dataset will likely be bigger <span class=\"keyword\">if</span> you have compressible values or keys.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当备份.rdb数据库时使用LZF压缩字符串对象？默认设置为“是”，因为它几乎总是一个胜利。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果要在保存子项中保存一些CPU，请将其设置为“否”，但如果您具有可压缩值或键，则数据集可能会更大。</span></span><br><span class=\"line\"></span><br><span class=\"line\">rdbcompression yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This makes the format more resistant to corruption but there is a performance</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hit to pay (around 10%) when saving and loading RDB files, so you can <span class=\"built_in\">disable</span> it</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"keyword\">for</span> maximum performances.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 从RDB的第5版开始，CRC64校验和被放置在文件的末尾。这使得格式更能抵抗损坏，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 但在保存和加载RDB文件时需要支付性能（大约10％），因此您可以禁用它以获得最佳性能。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> RDB files created with checksum disabled have a checksum of zero that will</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tell the loading code to skip the check.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 禁用校验和创建的RDB文件的校验和为零，将告诉加载代码跳过检查。</span></span><br><span class=\"line\"></span><br><span class=\"line\">rdbchecksum yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The filename <span class=\"built_in\">where</span> to dump the DB</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">rdb dump 文件名</span></span><br><span class=\"line\"></span><br><span class=\"line\">dbfilename dump.rdb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The working directory.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The DB will be written inside this directory, with the filename specified</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> above using the <span class=\"string\">'dbfilename'</span> configuration directive.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The Append Only File will also be created inside this directory.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Note that you must specify a directory here, not a file name.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 文件位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">dir ./</span><br></pre></td></tr></table></figure>\n<h3 id=\"APPEND-ONLY-MODE-aof-append-of-only\"><a href=\"#APPEND-ONLY-MODE-aof-append-of-only\" class=\"headerlink\" title=\"APPEND ONLY MODE aof(append of only)\"></a>APPEND ONLY MODE aof(append of only)</h3><h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>如果rdb过程中，机器出了问题，可能会丢失几分钟的数据。</p>\n<p>aof功能类似于日志，会对每一条记录做记录，三种持久化的方案：</p>\n<ul>\n<li>每条记录都记录，但是会占用大量io，会把服务器拖慢</li>\n<li>每秒钟的数据写入磁盘，将一秒钟的数据写入磁盘，可能会丢失一秒钟的数据（官方默认的方案）</li>\n<li>不写入，只有命令执行的时候，才写入，会有很好的性能，但是丢失数据的风险非常大。</li>\n</ul>\n<p>aof每条都记录，随着一直写入request，会导致aof文件会越来越大，并且在恢复的时候，每条都会执行<br>可以使用aof重写，可以多条记录逆为一条命令，减小文件大小</p>\n<p>例子：<br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重写前</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> wang <span class=\"comment\">100</span></span><br><span class=\"line\">incr <span class=\"comment\">wang</span>   </span><br><span class=\"line\">incr <span class=\"comment\">wnag</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写后,逆为key最后的状态值</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"comment\">wang 102bg</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"相关命令-1\"><a href=\"#相关命令-1\" class=\"headerlink\" title=\"相关命令\"></a>相关命令</h4><ul>\n<li>bgrewriteao：重写aof文件</li>\n</ul>\n<h4 id=\"恢复-1\"><a href=\"#恢复-1\" class=\"headerlink\" title=\"恢复\"></a>恢复</h4><p>在开启aof持久化的时候，会监测是否有aof文件，优先加载aof文件，然后在监测rdb文件。</p>\n<p>重写后的aof文件更便于恢复，不用每条都写入，直接写入最后的状态值。</p>\n<h4 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">############################# APPEND ONLY MODE ###############################</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> By default Redis asynchronously dumps the dataset on disk. This mode is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> good enough <span class=\"keyword\">in</span> many applications, but an issue with the Redis process or</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> a power outage may result into a few minutes of writes lost (depending on</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the configured save points).</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 默认情况下，Redis以异步方式将数据集转储到磁盘上。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 此模式在许多应用程序中都足够好，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 但Redis进程或停电的问题可能导致几分钟的写入丢失（取决于配置的保存点）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The Append Only File is an alternative persistence mode that provides</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> much better durability. For instance using the default data fsync policy</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> (see later <span class=\"keyword\">in</span> the config file) Redis can lose just one second of writes <span class=\"keyword\">in</span> a</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> dramatic event like a server power outage, or a single write <span class=\"keyword\">if</span> something</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> wrong with the Redis process itself happens, but the operating system is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> still running correctly.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 仅附加文件是一种备用持久性模式，可提供更好的持久性。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例如，使用默认数据fsync策略（请参阅配置文件中的后面部分）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis在服务器断电等戏剧性事件中只会丢失一秒写入，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果Redis进程本身出现问题，则会丢失一次，但是操作系统仍然正常运行。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> with the better durability guarantees.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 可以同时启用AOF和RDB持久性而不会出现问题。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果在启动时启用AOF，Redis将加载AOF，即具有更好耐久性保证的文件。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Please check http://redis.io/topics/persistence <span class=\"keyword\">for</span> more information.</span></span><br><span class=\"line\"></span><br><span class=\"line\">appendonly no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The name of the append only file (default: <span class=\"string\">\"appendonly.aof\"</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">appendfilename \"appendonly.aof\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The fsync() call tells the Operating System to actually write data on disk</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> instead of waiting <span class=\"keyword\">for</span> more data <span class=\"keyword\">in</span> the output buffer. Some OS will really flush</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> data on disk, some other OS will just try to <span class=\"keyword\">do</span> it ASAP.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aof调用告诉操作系统实际在磁盘上写入数据，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 而不是等待输出缓冲区中的更多数据。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 某些操作系统会真正刷新磁盘上的数据，其他一些操作系统会尽快尝试这样做。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis supports three different modes:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> no: don<span class=\"string\">'t fsync, just let the OS flush the data when it wants. Faster.</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> always: fsync after every write to the append only <span class=\"built_in\">log</span>. Slow, Safest.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> everysec: fsync only one time every second. Compromise.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> no：不要fsync，只需让操作系统在需要时刷新数据。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 快点。始终：每次写入仅附加日志后的fsync。慢，最安全。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">  everysec：fsync每秒只有一次。妥协。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> The default is <span class=\"string\">\"everysec\"</span>, as that<span class=\"string\">'s usually the right compromise between</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> speed and data safety. It<span class=\"string\">'s up to you to understand if you can relax this to</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"string\">\"no\"</span> that will <span class=\"built_in\">let</span> the operating system flush the output buffer when</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> it wants, <span class=\"keyword\">for</span> better performances (but <span class=\"keyword\">if</span> you can live with the idea of</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> some data loss consider the default persistence mode that<span class=\"string\">'s snapshotting),</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> or on the contrary, use <span class=\"string\">\"always\"</span> that<span class=\"string\">'s very slow but a bit safer than</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> everysec.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 默认值为“everysec”，因为这通常是速度和数据安全之间的正确折衷。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这取决于你是否可以理解你是否可以放松这个“不”，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 让操作系统在需要时刷新输出缓冲区，以获得更好的性能</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> （但如果你能想到一些数据丢失的想法，请考虑默认的持久性模式这是快照），</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 或相反，使用“总是”，这是非常慢但比每秒更安全。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> More details please check the following article:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If unsure, use <span class=\"string\">\"everysec\"</span>.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> appendfsync always</span></span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> appendfsync no</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> When the AOF fsync policy is <span class=\"built_in\">set</span> to always or everysec, and a background</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> saving process (a background save or AOF <span class=\"built_in\">log</span> background rewriting) is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> performing a lot of I/O against the disk, <span class=\"keyword\">in</span> some Linux configurations</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis may block too long on the fsync() call. Note that there is no fix <span class=\"keyword\">for</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> this currently, as even performing fsync <span class=\"keyword\">in</span> a different thread will block</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> our synchronous write(2) call.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当AOF fsync策略设置为always或everysec，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 并且后台保存过程（后台保存或AOF日志后台重写）</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 正在对磁盘执行大量I / O时，在某些Linux配置中，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis可能会阻塞太长时间fsync（）调用。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 请注意，目前没有对此进行修复，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 因为即使在不同的线程中执行fsync也会阻止我们的同步write（2）调用。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> In order to mitigate this problem it<span class=\"string\">'s possible to use the following option</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> that will prevent fsync() from being called <span class=\"keyword\">in</span> the main process <span class=\"keyword\">while</span> a</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> BGSAVE or BGREWRITEAOF is <span class=\"keyword\">in</span> progress.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 为了缓解此问题，可以使用以下选项，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 以防止在BGSAVE或BGREWRITEAOF正在进行时在主进程中调用fsync（）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This means that <span class=\"keyword\">while</span> another child is saving, the durability of Redis is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the same as <span class=\"string\">\"appendfsync none\"</span>. In practical terms, this means that it is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> possible to lose up to 30 seconds of <span class=\"built_in\">log</span> <span class=\"keyword\">in</span> the worst scenario (with the</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> default Linux settings).</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这意味着当另一个孩子正在保存时，Redis的持久性与“appendfsync none”相同。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 实际上，这意味着在最糟糕的情况下（使用默认的Linux设置）可能会丢失最多30秒的日志。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If you have latency problems turn this to <span class=\"string\">\"yes\"</span>. Otherwise leave it as</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"string\">\"no\"</span> that is the safest pick from the point of view of durability.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果您有延迟问题，请将其转为“是”。否则，从耐用性的角度来看，它是最“最安全”的选择。</span></span><br><span class=\"line\"></span><br><span class=\"line\">no-appendfsync-on-rewrite no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Automatic rewrite of the append only file.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis is able to automatically rewrite the <span class=\"built_in\">log</span> file implicitly calling</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> BGREWRITEAOF when the AOF <span class=\"built_in\">log</span> size grows by the specified percentage.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 自动重写仅附加文件。当AOF日志大小增长指定的百分比时，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis能够自动重写日志文件，隐式调用BGREWRITEAOF。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This is how it works: Redis remembers the size of the AOF file after the</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> latest rewrite (<span class=\"keyword\">if</span> no rewrite has happened since the restart, the size of</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the AOF at startup is used).</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是它的工作原理：Redis在最近的重写后记住AOF文件的大小</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> （如果重启后没有重写，则使用启动时的AOF大小）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This base size is compared to the current size. If the current size is</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> you need to specify a minimal size <span class=\"keyword\">for</span> the AOF file to be rewritten, this</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> is useful to avoid rewriting the AOF file even <span class=\"keyword\">if</span> the percentage increase</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> is reached but it is still pretty small.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则触发重写。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 此外，您需要指定要重写的AOF文件的最小大小，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这有助于避免重写AOF文件，即使达到百分比增加但仍然非常小。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Specify a percentage of zero <span class=\"keyword\">in</span> order to <span class=\"built_in\">disable</span> the automatic AOF</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> rewrite feature.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 指定零的百分比以禁用自动AOF重写功能。</span></span><br><span class=\"line\"></span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> An AOF file may be found to be truncated at the end during the Redis</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> startup process, when the AOF data gets loaded back into memory.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This may happen when the system <span class=\"built_in\">where</span> Redis is running</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> crashes, especially when an ext4 filesystem is mounted without the</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> data=ordered option (however this can<span class=\"string\">'t happen when Redis itself</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> crashes or aborts but the operating system still works correctly).</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当AOF数据加载回内存时，可能会在Redis启动过程中发现AOF文件被截断。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当Redis运行崩溃的系统时，尤其是在没有data = ordered选项的情况下挂载ext4文件系统时，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 可能会发生这种情况（但是当Redis本身崩溃或中止但操作系统仍能正常工作时，这种情况不会发生）。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis can either <span class=\"built_in\">exit</span> with an error when this happens, or load as much</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> data as possible (the default now) and start <span class=\"keyword\">if</span> the AOF file is found</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> to be truncated at the end. The following option controls this behavior.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 发生这种情况时，Redis可以退出，或者加载尽可能多的数据（现在是默认值），</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果发现AOF文件在末尾被截断，则启动。以下选项控制此行为。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If aof-load-truncated is <span class=\"built_in\">set</span> to yes, a truncated AOF file is loaded and</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the Redis server starts emitting a <span class=\"built_in\">log</span> to inform the user of the event.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Otherwise <span class=\"keyword\">if</span> the option is <span class=\"built_in\">set</span> to no, the server aborts with an error</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> and refuses to start. When the option is <span class=\"built_in\">set</span> to no, the user requires</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> to fix the AOF file using the <span class=\"string\">\"redis-check-aof\"</span> utility before to restart</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the server.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果将aof-load-truncated设置为yes，则会加载截断的AOF文件，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 并且Redis服务器会开始发出日志以通知用户该事件。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 否则，如果该选项设置为no，则服务器将中止并显示错误并拒绝启动。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 当该选项设置为no时，用户需要使用“redis-check-aof”实用程序修复AOF文件，</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 然后才能重新启动服务器。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Note that <span class=\"keyword\">if</span> the AOF file will be found to be corrupted <span class=\"keyword\">in</span> the middle</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> the server will still <span class=\"built_in\">exit</span> with an error. This option only applies when</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Redis will try to <span class=\"built_in\">read</span> more data from the AOF file but not enough bytes</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> will be found.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 请注意，如果发现AOF文件在中间被破坏，服务器仍将退出并显示错误。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 此选项仅在Redis尝试从AOF文件中读取更多数据但不会找到足够的字节时适用。</span></span><br><span class=\"line\"></span><br><span class=\"line\">aof-load-truncated yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> When rewriting the AOF file, Redis is able to use an RDB preamble <span class=\"keyword\">in</span> the</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> AOF file <span class=\"keyword\">for</span> faster rewrites and recoveries. When this option is turned</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> on the rewritten AOF file is composed of two different stanzas:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重写AOF文件时，Redis能够使用AOF文件中的RDB前导码来加快重写和恢复速度。</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 启用此选项后，重写的AOF文件由两个不同的节组成：</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">   [RDB file][AOF tail]</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> When loading Redis recognizes that the AOF file starts with the <span class=\"string\">\"REDIS\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> string and loads the prefixed RDB file, and continues loading the AOF</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> tail.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 加载时Redis识别出AOF文件以“REDIS”字符串开头并加载前缀RDB文件，并继续加载AOF尾部。</span></span><br><span class=\"line\"></span><br><span class=\"line\">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>"},{"title":"spring验证框架","date":"2018-10-02T13:55:17.000Z","type":"categories","_content":"\n![](img/index-page-img/spring.jpg)\n\n基础标准JSR-303规范验证框架@Valid和@Validated,风骚的操作\n\n<!-- more -->\n\n### 为什么要引入验证框架\n\n日常开发中，在Controller中校验参数，可能是日常编码编码中比较烦的一件事，大段的验证代码，没有任何业务意义，在参数校验较多的时候，会导致controller方法非常的臃肿，并且也不好维护，需要大量的注释维护语义。这可能是我开发中的一个痛点了。但是在后来，接触到了Validation框架，真的是击中了我的痛点，所以详细的整理了一下。写了这篇文章。\n\n### 介绍\n\njava很早就有了标准JSR-303，javax提供了@Valid（标准JSR-303规范），Spring Validation验证框架对参数的验证机制提供了@Validated（Spring’s JSR-303规范，是标准JSR-303的一个变种）。\n\n### API\n\n#### 对象验证\n\n##### bean中增加验证标签\n\n| 标签                 |   功能            |\n|:-------------------:|:------------------:|\n| @Null         |            限制只能为null        |\n| @NotNull       |      限制必须不为null              |\n| @AssertFalse     |    限制必须为false                |\n| @AssertTrue             |   限制必须为true      |\n| @DecimalMax(value)   | 限制必须为一个不大于指定值的数字       |\n| @DecimalMin(value)       |  限制必须为一个不小于指定值的数字           |\n| @Digits(integer,fraction) |  限制必须为一个小数，且整数部分的位数不能超过integer，小数部 分的位数不能超过fraction    |\n| @Future       |        限制必须是一个将来的日期        |\n| @Max(value)      |    限制必须为一个不大于指定值的数字            |\n| @Min(value)\t   |   限制必须为一个不小于指定值的数字            |\n| @Pattern(value)         |   限制必须符合指定的正则表达式      |\n| @Size(max,min)  | 限制字符长度必须在min到max之间   |\n| @NotEmpty     |  验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不 为0）          |\n|@NotBlank |验证注解的元素值不为空（不为null、去除首位空格后长度为0） ,不同于@NotEmpty ，@NotBlank只应用于字符串且在比较时会去除字符串的空格|\n|@Email\t|验证注解的元素值是Email，也可以通过正则表达式和flag指定自定 义的email格式|\n\n##### 分组\n上述注解标签都支持，group属性，新写一个接口类，在填写注解接口类型\n\n##### 嵌套\n\n在日常开发中，会碰到嵌套对象的情况，嵌套对象的需要验证，可以在验证的域上增加@Valid，当且仅当只有@Valid支持对象嵌套验证。\n\n##### 补充其他功能注解\n\n\n* @DateTimeFormat(pattern=”yyyy-MM-ddHH:mm:ss”) 时间格式标签\n* @JsonFormat(pattern=”yyyy-MM-ddHH:mm:ss”) json格式化标签\n\n##### 使用\n\nController方法参数签字中对象，增加@Validated/@Valid，在方法上最好使用 @Validated，这个注解支持分组验证。\n\n##### 单个签字域校验\n\n需要使用@Validated，这个注解支持类验证，即可对单个域进行验证。\n\n##### 自定义注解及处理器\n\ndemo:\n\n{% codeblock %}\n\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Constraint(validatedBy = {EmailValidator.class})\npublic @interface ValidEmail {\n    boolean required() default true;\n    String message() default \"邮箱不合法\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\n{% endcodeblock %}\n\n描述：@Constraint(validatedBy = {EmailValidator.class}) 通过这个注解定义它的处理验证器\n\n{% codeblock %}\n\npublic class EmailValidator implements ConstraintValidator<ValidEmail, String> {\n    private boolean required = false;\n    //初始化方法\n    @Override\n    public void initialize(ValidEmail constraintAnnotation) {\n        required = constraintAnnotation.required();\n    }\n    //校验方法\n    @Override\n    public boolean isValid(String value, ConstraintValidatorContext context) {\n    \t\tdoSomething();\n    }\n}\n\n{% endcodeblock %}\n\n\n描述：ConstraintValidator 实现接口重写方法\n\n\n##### 定义消息体\n\n必须指定这个路径和文件名：resource/ValidationMessages.properties\n文件的编码为ASCII\n\n### 验证异常处理\n\n两种：\n\n* 方法中增加BindException\n* 定义全局异常处理器，单域验证ConstraintViolationException，对象验证BindException，resquestBody对象验证MethodArgumentNotValidException\n\n\n### ide验证\n\n![](img/ide空验证.png)\n\n配置使用**@NotNull**和**@Nullable**注解，通过上下文进行校验。\n\n\n#### 源码地址:\n<a>https://github.com/wangypeng/spring-boot-validator</a>","source":"_posts/spring验证框架.md","raw":"---\ntitle: spring验证框架\ndate: 2018-10-02 21:55:17\ntype: \"categories\"\ncategories: spring\ntags: spring\n\n---\n\n![](img/index-page-img/spring.jpg)\n\n基础标准JSR-303规范验证框架@Valid和@Validated,风骚的操作\n\n<!-- more -->\n\n### 为什么要引入验证框架\n\n日常开发中，在Controller中校验参数，可能是日常编码编码中比较烦的一件事，大段的验证代码，没有任何业务意义，在参数校验较多的时候，会导致controller方法非常的臃肿，并且也不好维护，需要大量的注释维护语义。这可能是我开发中的一个痛点了。但是在后来，接触到了Validation框架，真的是击中了我的痛点，所以详细的整理了一下。写了这篇文章。\n\n### 介绍\n\njava很早就有了标准JSR-303，javax提供了@Valid（标准JSR-303规范），Spring Validation验证框架对参数的验证机制提供了@Validated（Spring’s JSR-303规范，是标准JSR-303的一个变种）。\n\n### API\n\n#### 对象验证\n\n##### bean中增加验证标签\n\n| 标签                 |   功能            |\n|:-------------------:|:------------------:|\n| @Null         |            限制只能为null        |\n| @NotNull       |      限制必须不为null              |\n| @AssertFalse     |    限制必须为false                |\n| @AssertTrue             |   限制必须为true      |\n| @DecimalMax(value)   | 限制必须为一个不大于指定值的数字       |\n| @DecimalMin(value)       |  限制必须为一个不小于指定值的数字           |\n| @Digits(integer,fraction) |  限制必须为一个小数，且整数部分的位数不能超过integer，小数部 分的位数不能超过fraction    |\n| @Future       |        限制必须是一个将来的日期        |\n| @Max(value)      |    限制必须为一个不大于指定值的数字            |\n| @Min(value)\t   |   限制必须为一个不小于指定值的数字            |\n| @Pattern(value)         |   限制必须符合指定的正则表达式      |\n| @Size(max,min)  | 限制字符长度必须在min到max之间   |\n| @NotEmpty     |  验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不 为0）          |\n|@NotBlank |验证注解的元素值不为空（不为null、去除首位空格后长度为0） ,不同于@NotEmpty ，@NotBlank只应用于字符串且在比较时会去除字符串的空格|\n|@Email\t|验证注解的元素值是Email，也可以通过正则表达式和flag指定自定 义的email格式|\n\n##### 分组\n上述注解标签都支持，group属性，新写一个接口类，在填写注解接口类型\n\n##### 嵌套\n\n在日常开发中，会碰到嵌套对象的情况，嵌套对象的需要验证，可以在验证的域上增加@Valid，当且仅当只有@Valid支持对象嵌套验证。\n\n##### 补充其他功能注解\n\n\n* @DateTimeFormat(pattern=”yyyy-MM-ddHH:mm:ss”) 时间格式标签\n* @JsonFormat(pattern=”yyyy-MM-ddHH:mm:ss”) json格式化标签\n\n##### 使用\n\nController方法参数签字中对象，增加@Validated/@Valid，在方法上最好使用 @Validated，这个注解支持分组验证。\n\n##### 单个签字域校验\n\n需要使用@Validated，这个注解支持类验证，即可对单个域进行验证。\n\n##### 自定义注解及处理器\n\ndemo:\n\n{% codeblock %}\n\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Constraint(validatedBy = {EmailValidator.class})\npublic @interface ValidEmail {\n    boolean required() default true;\n    String message() default \"邮箱不合法\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\n{% endcodeblock %}\n\n描述：@Constraint(validatedBy = {EmailValidator.class}) 通过这个注解定义它的处理验证器\n\n{% codeblock %}\n\npublic class EmailValidator implements ConstraintValidator<ValidEmail, String> {\n    private boolean required = false;\n    //初始化方法\n    @Override\n    public void initialize(ValidEmail constraintAnnotation) {\n        required = constraintAnnotation.required();\n    }\n    //校验方法\n    @Override\n    public boolean isValid(String value, ConstraintValidatorContext context) {\n    \t\tdoSomething();\n    }\n}\n\n{% endcodeblock %}\n\n\n描述：ConstraintValidator 实现接口重写方法\n\n\n##### 定义消息体\n\n必须指定这个路径和文件名：resource/ValidationMessages.properties\n文件的编码为ASCII\n\n### 验证异常处理\n\n两种：\n\n* 方法中增加BindException\n* 定义全局异常处理器，单域验证ConstraintViolationException，对象验证BindException，resquestBody对象验证MethodArgumentNotValidException\n\n\n### ide验证\n\n![](img/ide空验证.png)\n\n配置使用**@NotNull**和**@Nullable**注解，通过上下文进行校验。\n\n\n#### 源码地址:\n<a>https://github.com/wangypeng/spring-boot-validator</a>","slug":"spring验证框架","published":1,"updated":"2018-11-12T12:17:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syo1000q43xrol77ebj7","content":"<p><img src=\"img/index-page-img/spring.jpg\" alt=\"\"></p>\n<p>基础标准JSR-303规范验证框架@Valid和@Validated,风骚的操作</p>\n<a id=\"more\"></a>\n<h3 id=\"为什么要引入验证框架\"><a href=\"#为什么要引入验证框架\" class=\"headerlink\" title=\"为什么要引入验证框架\"></a>为什么要引入验证框架</h3><p>日常开发中，在Controller中校验参数，可能是日常编码编码中比较烦的一件事，大段的验证代码，没有任何业务意义，在参数校验较多的时候，会导致controller方法非常的臃肿，并且也不好维护，需要大量的注释维护语义。这可能是我开发中的一个痛点了。但是在后来，接触到了Validation框架，真的是击中了我的痛点，所以详细的整理了一下。写了这篇文章。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>java很早就有了标准JSR-303，javax提供了@Valid（标准JSR-303规范），Spring Validation验证框架对参数的验证机制提供了@Validated（Spring’s JSR-303规范，是标准JSR-303的一个变种）。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><h4 id=\"对象验证\"><a href=\"#对象验证\" class=\"headerlink\" title=\"对象验证\"></a>对象验证</h4><h5 id=\"bean中增加验证标签\"><a href=\"#bean中增加验证标签\" class=\"headerlink\" title=\"bean中增加验证标签\"></a>bean中增加验证标签</h5><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">标签</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">@Null</td>\n<td style=\"text-align:center\">限制只能为null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@NotNull</td>\n<td style=\"text-align:center\">限制必须不为null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@AssertFalse</td>\n<td style=\"text-align:center\">限制必须为false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@AssertTrue</td>\n<td style=\"text-align:center\">限制必须为true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@DecimalMax(value)</td>\n<td style=\"text-align:center\">限制必须为一个不大于指定值的数字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@DecimalMin(value)</td>\n<td style=\"text-align:center\">限制必须为一个不小于指定值的数字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Digits(integer,fraction)</td>\n<td style=\"text-align:center\">限制必须为一个小数，且整数部分的位数不能超过integer，小数部 分的位数不能超过fraction</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Future</td>\n<td style=\"text-align:center\">限制必须是一个将来的日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Max(value)</td>\n<td style=\"text-align:center\">限制必须为一个不大于指定值的数字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Min(value)</td>\n<td style=\"text-align:center\">限制必须为一个不小于指定值的数字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Pattern(value)</td>\n<td style=\"text-align:center\">限制必须符合指定的正则表达式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Size(max,min)</td>\n<td style=\"text-align:center\">限制字符长度必须在min到max之间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@NotEmpty</td>\n<td style=\"text-align:center\">验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不 为0）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@NotBlank</td>\n<td style=\"text-align:center\">验证注解的元素值不为空（不为null、去除首位空格后长度为0） ,不同于@NotEmpty ，@NotBlank只应用于字符串且在比较时会去除字符串的空格</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Email</td>\n<td style=\"text-align:center\">验证注解的元素值是Email，也可以通过正则表达式和flag指定自定 义的email格式</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h5><p>上述注解标签都支持，group属性，新写一个接口类，在填写注解接口类型</p>\n<h5 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h5><p>在日常开发中，会碰到嵌套对象的情况，嵌套对象的需要验证，可以在验证的域上增加@Valid，当且仅当只有@Valid支持对象嵌套验证。</p>\n<h5 id=\"补充其他功能注解\"><a href=\"#补充其他功能注解\" class=\"headerlink\" title=\"补充其他功能注解\"></a>补充其他功能注解</h5><ul>\n<li>@DateTimeFormat(pattern=”yyyy-MM-ddHH:mm:ss”) 时间格式标签</li>\n<li>@JsonFormat(pattern=”yyyy-MM-ddHH:mm:ss”) json格式化标签</li>\n</ul>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p>Controller方法参数签字中对象，增加@Validated/@Valid，在方法上最好使用 @Validated，这个注解支持分组验证。</p>\n<h5 id=\"单个签字域校验\"><a href=\"#单个签字域校验\" class=\"headerlink\" title=\"单个签字域校验\"></a>单个签字域校验</h5><p>需要使用@Validated，这个注解支持类验证，即可对单个域进行验证。</p>\n<h5 id=\"自定义注解及处理器\"><a href=\"#自定义注解及处理器\" class=\"headerlink\" title=\"自定义注解及处理器\"></a>自定义注解及处理器</h5><p>demo:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">Target</span>(&#123;<span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.TYPE</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.METHOD</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.FIELD</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.ANNOTATION_TYPE</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.CONSTRUCTOR</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.PARAMETER</span>&#125;)</span><br><span class=\"line\">@<span class=\"keyword\">Retention</span>(<span class=\"keyword\">RetentionPolicy</span>.<span class=\"keyword\">RUNTIME</span>)</span><br><span class=\"line\">@<span class=\"keyword\">Documented</span></span><br><span class=\"line\">@<span class=\"keyword\">Constraint</span>(<span class=\"keyword\">validatedBy</span> = &#123;<span class=\"selector-tag\">EmailValidator</span><span class=\"selector-class\">.class</span>&#125;)</span><br><span class=\"line\"><span class=\"selector-tag\">public</span> @<span class=\"keyword\">interface</span> ValidEmail &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">boolean</span> <span class=\"selector-tag\">required</span>() <span class=\"selector-tag\">default</span> <span class=\"selector-tag\">true</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">String</span> <span class=\"selector-tag\">message</span>() <span class=\"selector-tag\">default</span> \"邮箱不合法\";</span><br><span class=\"line\">    <span class=\"selector-tag\">Class</span>&lt;?&gt;<span class=\"selector-attr\">[]</span> <span class=\"selector-tag\">groups</span>() <span class=\"selector-tag\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"selector-tag\">Class</span>&lt;? <span class=\"selector-tag\">extends</span> <span class=\"selector-tag\">Payload</span>&gt;<span class=\"selector-attr\">[]</span> <span class=\"selector-tag\">payload</span>() <span class=\"selector-tag\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>描述：@Constraint(validatedBy = {EmailValidator.class}) 通过这个注解定义它的处理验证器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmailValidator</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConstraintValidator</span>&lt;<span class=\"title\">ValidEmail</span>, <span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> required = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//初始化方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(ValidEmail constraintAnnotation)</span> </span>&#123;</span><br><span class=\"line\">        required = constraintAnnotation.required();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//校验方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class=\"line\">    \t\tdoSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>描述：ConstraintValidator 实现接口重写方法</p>\n<h5 id=\"定义消息体\"><a href=\"#定义消息体\" class=\"headerlink\" title=\"定义消息体\"></a>定义消息体</h5><p>必须指定这个路径和文件名：resource/ValidationMessages.properties<br>文件的编码为ASCII</p>\n<h3 id=\"验证异常处理\"><a href=\"#验证异常处理\" class=\"headerlink\" title=\"验证异常处理\"></a>验证异常处理</h3><p>两种：</p>\n<ul>\n<li>方法中增加BindException</li>\n<li>定义全局异常处理器，单域验证ConstraintViolationException，对象验证BindException，resquestBody对象验证MethodArgumentNotValidException</li>\n</ul>\n<h3 id=\"ide验证\"><a href=\"#ide验证\" class=\"headerlink\" title=\"ide验证\"></a>ide验证</h3><p><img src=\"img/ide空验证.png\" alt=\"\"></p>\n<p>配置使用<strong>@NotNull</strong>和<strong>@Nullable</strong>注解，通过上下文进行校验。</p>\n<h4 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址:\"></a>源码地址:</h4><p><a><a href=\"https://github.com/wangypeng/spring-boot-validator\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/spring-boot-validator</a></a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/spring.jpg\" alt=\"\"></p>\n<p>基础标准JSR-303规范验证框架@Valid和@Validated,风骚的操作</p>","more":"<h3 id=\"为什么要引入验证框架\"><a href=\"#为什么要引入验证框架\" class=\"headerlink\" title=\"为什么要引入验证框架\"></a>为什么要引入验证框架</h3><p>日常开发中，在Controller中校验参数，可能是日常编码编码中比较烦的一件事，大段的验证代码，没有任何业务意义，在参数校验较多的时候，会导致controller方法非常的臃肿，并且也不好维护，需要大量的注释维护语义。这可能是我开发中的一个痛点了。但是在后来，接触到了Validation框架，真的是击中了我的痛点，所以详细的整理了一下。写了这篇文章。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>java很早就有了标准JSR-303，javax提供了@Valid（标准JSR-303规范），Spring Validation验证框架对参数的验证机制提供了@Validated（Spring’s JSR-303规范，是标准JSR-303的一个变种）。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><h4 id=\"对象验证\"><a href=\"#对象验证\" class=\"headerlink\" title=\"对象验证\"></a>对象验证</h4><h5 id=\"bean中增加验证标签\"><a href=\"#bean中增加验证标签\" class=\"headerlink\" title=\"bean中增加验证标签\"></a>bean中增加验证标签</h5><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">标签</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">@Null</td>\n<td style=\"text-align:center\">限制只能为null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@NotNull</td>\n<td style=\"text-align:center\">限制必须不为null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@AssertFalse</td>\n<td style=\"text-align:center\">限制必须为false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@AssertTrue</td>\n<td style=\"text-align:center\">限制必须为true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@DecimalMax(value)</td>\n<td style=\"text-align:center\">限制必须为一个不大于指定值的数字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@DecimalMin(value)</td>\n<td style=\"text-align:center\">限制必须为一个不小于指定值的数字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Digits(integer,fraction)</td>\n<td style=\"text-align:center\">限制必须为一个小数，且整数部分的位数不能超过integer，小数部 分的位数不能超过fraction</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Future</td>\n<td style=\"text-align:center\">限制必须是一个将来的日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Max(value)</td>\n<td style=\"text-align:center\">限制必须为一个不大于指定值的数字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Min(value)</td>\n<td style=\"text-align:center\">限制必须为一个不小于指定值的数字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Pattern(value)</td>\n<td style=\"text-align:center\">限制必须符合指定的正则表达式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Size(max,min)</td>\n<td style=\"text-align:center\">限制字符长度必须在min到max之间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@NotEmpty</td>\n<td style=\"text-align:center\">验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不 为0）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@NotBlank</td>\n<td style=\"text-align:center\">验证注解的元素值不为空（不为null、去除首位空格后长度为0） ,不同于@NotEmpty ，@NotBlank只应用于字符串且在比较时会去除字符串的空格</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Email</td>\n<td style=\"text-align:center\">验证注解的元素值是Email，也可以通过正则表达式和flag指定自定 义的email格式</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h5><p>上述注解标签都支持，group属性，新写一个接口类，在填写注解接口类型</p>\n<h5 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h5><p>在日常开发中，会碰到嵌套对象的情况，嵌套对象的需要验证，可以在验证的域上增加@Valid，当且仅当只有@Valid支持对象嵌套验证。</p>\n<h5 id=\"补充其他功能注解\"><a href=\"#补充其他功能注解\" class=\"headerlink\" title=\"补充其他功能注解\"></a>补充其他功能注解</h5><ul>\n<li>@DateTimeFormat(pattern=”yyyy-MM-ddHH:mm:ss”) 时间格式标签</li>\n<li>@JsonFormat(pattern=”yyyy-MM-ddHH:mm:ss”) json格式化标签</li>\n</ul>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p>Controller方法参数签字中对象，增加@Validated/@Valid，在方法上最好使用 @Validated，这个注解支持分组验证。</p>\n<h5 id=\"单个签字域校验\"><a href=\"#单个签字域校验\" class=\"headerlink\" title=\"单个签字域校验\"></a>单个签字域校验</h5><p>需要使用@Validated，这个注解支持类验证，即可对单个域进行验证。</p>\n<h5 id=\"自定义注解及处理器\"><a href=\"#自定义注解及处理器\" class=\"headerlink\" title=\"自定义注解及处理器\"></a>自定义注解及处理器</h5><p>demo:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">Target</span>(&#123;<span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.TYPE</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.METHOD</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.FIELD</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.ANNOTATION_TYPE</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.CONSTRUCTOR</span>, <span class=\"selector-tag\">ElementType</span><span class=\"selector-class\">.PARAMETER</span>&#125;)</span><br><span class=\"line\">@<span class=\"keyword\">Retention</span>(<span class=\"keyword\">RetentionPolicy</span>.<span class=\"keyword\">RUNTIME</span>)</span><br><span class=\"line\">@<span class=\"keyword\">Documented</span></span><br><span class=\"line\">@<span class=\"keyword\">Constraint</span>(<span class=\"keyword\">validatedBy</span> = &#123;<span class=\"selector-tag\">EmailValidator</span><span class=\"selector-class\">.class</span>&#125;)</span><br><span class=\"line\"><span class=\"selector-tag\">public</span> @<span class=\"keyword\">interface</span> ValidEmail &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">boolean</span> <span class=\"selector-tag\">required</span>() <span class=\"selector-tag\">default</span> <span class=\"selector-tag\">true</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">String</span> <span class=\"selector-tag\">message</span>() <span class=\"selector-tag\">default</span> \"邮箱不合法\";</span><br><span class=\"line\">    <span class=\"selector-tag\">Class</span>&lt;?&gt;<span class=\"selector-attr\">[]</span> <span class=\"selector-tag\">groups</span>() <span class=\"selector-tag\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"selector-tag\">Class</span>&lt;? <span class=\"selector-tag\">extends</span> <span class=\"selector-tag\">Payload</span>&gt;<span class=\"selector-attr\">[]</span> <span class=\"selector-tag\">payload</span>() <span class=\"selector-tag\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>描述：@Constraint(validatedBy = {EmailValidator.class}) 通过这个注解定义它的处理验证器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmailValidator</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConstraintValidator</span>&lt;<span class=\"title\">ValidEmail</span>, <span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> required = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//初始化方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(ValidEmail constraintAnnotation)</span> </span>&#123;</span><br><span class=\"line\">        required = constraintAnnotation.required();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//校验方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class=\"line\">    \t\tdoSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>描述：ConstraintValidator 实现接口重写方法</p>\n<h5 id=\"定义消息体\"><a href=\"#定义消息体\" class=\"headerlink\" title=\"定义消息体\"></a>定义消息体</h5><p>必须指定这个路径和文件名：resource/ValidationMessages.properties<br>文件的编码为ASCII</p>\n<h3 id=\"验证异常处理\"><a href=\"#验证异常处理\" class=\"headerlink\" title=\"验证异常处理\"></a>验证异常处理</h3><p>两种：</p>\n<ul>\n<li>方法中增加BindException</li>\n<li>定义全局异常处理器，单域验证ConstraintViolationException，对象验证BindException，resquestBody对象验证MethodArgumentNotValidException</li>\n</ul>\n<h3 id=\"ide验证\"><a href=\"#ide验证\" class=\"headerlink\" title=\"ide验证\"></a>ide验证</h3><p><img src=\"img/ide空验证.png\" alt=\"\"></p>\n<p>配置使用<strong>@NotNull</strong>和<strong>@Nullable</strong>注解，通过上下文进行校验。</p>\n<h4 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址:\"></a>源码地址:</h4><p><a><a href=\"https://github.com/wangypeng/spring-boot-validator\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/spring-boot-validator</a></a></p>"},{"title":"设计模式-代理【Proxy】","date":"2018-09-01T03:24:59.000Z","type":"categories","_content":"![](img/index-page-img/设计模式.png)\n\n代理设计模式，代理目标，代替直接操作目标对象。\n\n<!-- more -->\n\n\n### 介绍\n\n代理设计模式，在日常开发中，还是很常用的。主要是代理一个类的方法，在代理类做一些其他的逻辑。也可以说是为目标类分担一部分工作。\n\n\n### UML\n\n![](img/设计模式-代理【Proxy】/UML.png)\n\n### 方法说明\n\n* Client:调用方，调用目标的方法的类。\n* Subject:主体，目标类和代理对象的实现的接口，为**Proxy**和**RealSubject**定义一致性接口。\n* Proxy:代理对象，**持有目标类的对象实例**，通过调用**proxy**持有的目标类对象间接调用**RealSubject**中的方法，在代理方法中做一些其他的逻辑，或者分担一些目标方法的任务。\n* RealSubject:真正调用被调用，被代理的对象。\n\n\n### Spring 中的两种代理方式\n\nspring的aop就是通过代理的方式实现方法的织入的，aop的实现方式有两种：\n\n* jdk原生代理：jdk原生包中提供的功能。原生代理只能代理**接口**的实现类，通过反射的方式调用。\n* cglib代理：第三方的代理方式，这是一个生成代码的工具包，主要是通过**继承**的方式，**生成**目标对象的子类，从而代理目标方法，通过继承的方式实现。所以因为通过**继承**的方式实现，也就不能使用代理**final class**，其他的类都是能通过这种方式代理。\n\n\n**源码地址**：\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/proxy</a>","source":"_posts/设计模式-代理【Proxy】.md","raw":"---\ntitle: 设计模式-代理【Proxy】\ndate: 2018-09-01 11:24:59\ntype: \"categories\"\ncategories: 设计模式\ntags: 设计模式\n---\n![](img/index-page-img/设计模式.png)\n\n代理设计模式，代理目标，代替直接操作目标对象。\n\n<!-- more -->\n\n\n### 介绍\n\n代理设计模式，在日常开发中，还是很常用的。主要是代理一个类的方法，在代理类做一些其他的逻辑。也可以说是为目标类分担一部分工作。\n\n\n### UML\n\n![](img/设计模式-代理【Proxy】/UML.png)\n\n### 方法说明\n\n* Client:调用方，调用目标的方法的类。\n* Subject:主体，目标类和代理对象的实现的接口，为**Proxy**和**RealSubject**定义一致性接口。\n* Proxy:代理对象，**持有目标类的对象实例**，通过调用**proxy**持有的目标类对象间接调用**RealSubject**中的方法，在代理方法中做一些其他的逻辑，或者分担一些目标方法的任务。\n* RealSubject:真正调用被调用，被代理的对象。\n\n\n### Spring 中的两种代理方式\n\nspring的aop就是通过代理的方式实现方法的织入的，aop的实现方式有两种：\n\n* jdk原生代理：jdk原生包中提供的功能。原生代理只能代理**接口**的实现类，通过反射的方式调用。\n* cglib代理：第三方的代理方式，这是一个生成代码的工具包，主要是通过**继承**的方式，**生成**目标对象的子类，从而代理目标方法，通过继承的方式实现。所以因为通过**继承**的方式实现，也就不能使用代理**final class**，其他的类都是能通过这种方式代理。\n\n\n**源码地址**：\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/proxy</a>","slug":"设计模式-代理【Proxy】","published":1,"updated":"2018-11-11T02:25:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syo2000u43xri0yb647b","content":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>代理设计模式，代理目标，代替直接操作目标对象。</p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>代理设计模式，在日常开发中，还是很常用的。主要是代理一个类的方法，在代理类做一些其他的逻辑。也可以说是为目标类分担一部分工作。</p>\n<h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-代理【Proxy】/UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><ul>\n<li>Client:调用方，调用目标的方法的类。</li>\n<li>Subject:主体，目标类和代理对象的实现的接口，为<strong>Proxy</strong>和<strong>RealSubject</strong>定义一致性接口。</li>\n<li>Proxy:代理对象，<strong>持有目标类的对象实例</strong>，通过调用<strong>proxy</strong>持有的目标类对象间接调用<strong>RealSubject</strong>中的方法，在代理方法中做一些其他的逻辑，或者分担一些目标方法的任务。</li>\n<li>RealSubject:真正调用被调用，被代理的对象。</li>\n</ul>\n<h3 id=\"Spring-中的两种代理方式\"><a href=\"#Spring-中的两种代理方式\" class=\"headerlink\" title=\"Spring 中的两种代理方式\"></a>Spring 中的两种代理方式</h3><p>spring的aop就是通过代理的方式实现方法的织入的，aop的实现方式有两种：</p>\n<ul>\n<li>jdk原生代理：jdk原生包中提供的功能。原生代理只能代理<strong>接口</strong>的实现类，通过反射的方式调用。</li>\n<li>cglib代理：第三方的代理方式，这是一个生成代码的工具包，主要是通过<strong>继承</strong>的方式，<strong>生成</strong>目标对象的子类，从而代理目标方法，通过继承的方式实现。所以因为通过<strong>继承</strong>的方式实现，也就不能使用代理<strong>final class</strong>，其他的类都是能通过这种方式代理。</li>\n</ul>\n<p><strong>源码地址</strong>：<br><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/proxy\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/proxy</a></a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>代理设计模式，代理目标，代替直接操作目标对象。</p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>代理设计模式，在日常开发中，还是很常用的。主要是代理一个类的方法，在代理类做一些其他的逻辑。也可以说是为目标类分担一部分工作。</p>\n<h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-代理【Proxy】/UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><ul>\n<li>Client:调用方，调用目标的方法的类。</li>\n<li>Subject:主体，目标类和代理对象的实现的接口，为<strong>Proxy</strong>和<strong>RealSubject</strong>定义一致性接口。</li>\n<li>Proxy:代理对象，<strong>持有目标类的对象实例</strong>，通过调用<strong>proxy</strong>持有的目标类对象间接调用<strong>RealSubject</strong>中的方法，在代理方法中做一些其他的逻辑，或者分担一些目标方法的任务。</li>\n<li>RealSubject:真正调用被调用，被代理的对象。</li>\n</ul>\n<h3 id=\"Spring-中的两种代理方式\"><a href=\"#Spring-中的两种代理方式\" class=\"headerlink\" title=\"Spring 中的两种代理方式\"></a>Spring 中的两种代理方式</h3><p>spring的aop就是通过代理的方式实现方法的织入的，aop的实现方式有两种：</p>\n<ul>\n<li>jdk原生代理：jdk原生包中提供的功能。原生代理只能代理<strong>接口</strong>的实现类，通过反射的方式调用。</li>\n<li>cglib代理：第三方的代理方式，这是一个生成代码的工具包，主要是通过<strong>继承</strong>的方式，<strong>生成</strong>目标对象的子类，从而代理目标方法，通过继承的方式实现。所以因为通过<strong>继承</strong>的方式实现，也就不能使用代理<strong>final class</strong>，其他的类都是能通过这种方式代理。</li>\n</ul>\n<p><strong>源码地址</strong>：<br><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/proxy\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/proxy</a></a></p>"},{"title":"设计模式-单例【Single】","date":"2018-11-12T11:58:28.000Z","type":"categories","_content":"\n![](img/index-page-img/设计模式.png)\n\n单例，只new一次对象，全局只有一个对象实例。\n\n<!-- more -->\n\n### 介绍\n\n单例，在日常开发中，可以说的最常用的。应用的很广泛，也有很多不同的实现。全局只有一个类实例。\n\n### 特点\n\n1.构造函数私有，不能使用 new 直接创建对象。\n\n2.通过静态方法getInstance()方法，创建对象实例。\n\n3.对象实例引用只对自己可见。\n\n### 单例与静态\n\n* 单例：可以持有状态，可以线程安全，可以实现lazy-load，全局只有一个实例。\n\n* 静态：并不能持有状态，线程安全，并在是类加载的时候，就实例了。\n\n### 写法\n\n#### 饿汉模式(推荐)\n\n1. 静态变量\n{% codeblock %}\npublic class Singleton {\n\n\tprivate static Singleton instance=new Singleton();\n\n\tprivate Singleton(){};\n\n\tpublic static Singleton getInstance(){\n\t\treturn instance;\n\t}\n}\n\n{% endcodeblock %}\n\n2. 静态块\n{% codeblock %}\npublic class Singleton{\n \n\tprivate static Singleton instance = null;\n\t\t\n\tstatic {\n\t\tinstance = new Singleton();\n\t}\n\t \n\tprivate Singleton() {}\n\t \n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n}\n{% endcodeblock %}\n\n**优点**：在类加载的时候，实例化，线程安全。\n\n**缺点**：类加载的时候就实例了。所以这个实例，可能加载了也并不会被使用，会内存浪费。这个种浪费还是能接受的。\n\n#### 懒汉模式\n\n1. 直接创建\n{% codeblock %}\npublic class Singleton {\n\t\t\t \n\tprivate static Singleton instance=null;\n\t\n\tprivate Singleton() {};\n\t\n\tpublic static Singleton getInstance(){\n\t\tif(instance==null){\n\t\t\tinstance=new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n{% endcodeblock %}\n\n**特点**：非线程安全，可能两条线程请求，可能会创建两个实例。\n\n**不可用**\n\n2. 方法加锁\n{% codeblock %}\npublic class Singleton {\n \n\tprivate static Singleton instance=null;\n\t\n\tprivate Singleton() {};\n\t\n\tpublic static synchronized Singleton getInstance(){\n\t\tif(instance==null){\n\t\t\tinstance=new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n{% endcodeblock %}\n\n**特点**：线程安全，但是性能低下，多线程访问，效率低。\n\n**不可用**\n\n3. 创建时加锁\n{% codeblock %}\npublic class Singleton {\n \n\tprivate static Singleton instance=null;\n\n\tprivate Singleton() {};\n\t\n\tpublic static Singleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tinstance = new Singleton();\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n{% endcodeblock %}\n\n**特点**：非线程安全，两条线程进入if判断，进入synchronized执行。两个线程都会执行，并且都会创建对象\n\n**不可用**\n\n4. 加锁双重验证\n{% codeblock %}\npublic class Singleton {\n\t\n\tprivate static Singleton instance=null;\n\t\n\tprivate Singleton() {};\n\t\n\tpublic static Singleton getInstance(){\n\t\t if (instance == null) {  \n\t          synchronized (Singleton.class) {  \n\t              if (instance == null) {  \n\t            \t  instance = new Singleton();  \n\t              }  \n\t          }  \n\t      }  \n\t      return instance;  \n\t}\n}\n{% endcodeblock %}\n**特点**：线程安全。双重校验，保证了线程安全和效率。懒汉中\n\n**推荐**\n\n#### 内部类\n{% codeblock %}\npublic class Singleton{\n\t\t\t\n\tprivate Singleton() {};\n\t\n\tprivate static class SingletonHolder{\n\t\tprivate static Singleton instance=new Singleton();\n\t} \n\t\n\tpublic static Singleton getInstance(){\n\t\treturn SingletonHolder.instance;\n\t}\n}\n{% endcodeblock %}\n**特点**：线程安全，延时加载，在调用的时候才加载。效率高\n\n#### 枚举\n{% codeblock %}\npublic enum SingletonEnum {\n\t\n\t instance; \n\t \n\t private SingletonEnum() {}\n\t \n\t public void method(){\n\n\t }\n}\n{% endcodeblock %}\n**特点**：借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。\n\n### 源码地址：\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/single</a>\n","source":"_posts/设计模式-单例【Single】.md","raw":"---\ntitle: 设计模式-单例【Single】\ndate: 2018-11-12 19:58:28\ntype: \"categories\"\ncategories: 设计模式\ntags: 设计模式\n---\n\n![](img/index-page-img/设计模式.png)\n\n单例，只new一次对象，全局只有一个对象实例。\n\n<!-- more -->\n\n### 介绍\n\n单例，在日常开发中，可以说的最常用的。应用的很广泛，也有很多不同的实现。全局只有一个类实例。\n\n### 特点\n\n1.构造函数私有，不能使用 new 直接创建对象。\n\n2.通过静态方法getInstance()方法，创建对象实例。\n\n3.对象实例引用只对自己可见。\n\n### 单例与静态\n\n* 单例：可以持有状态，可以线程安全，可以实现lazy-load，全局只有一个实例。\n\n* 静态：并不能持有状态，线程安全，并在是类加载的时候，就实例了。\n\n### 写法\n\n#### 饿汉模式(推荐)\n\n1. 静态变量\n{% codeblock %}\npublic class Singleton {\n\n\tprivate static Singleton instance=new Singleton();\n\n\tprivate Singleton(){};\n\n\tpublic static Singleton getInstance(){\n\t\treturn instance;\n\t}\n}\n\n{% endcodeblock %}\n\n2. 静态块\n{% codeblock %}\npublic class Singleton{\n \n\tprivate static Singleton instance = null;\n\t\t\n\tstatic {\n\t\tinstance = new Singleton();\n\t}\n\t \n\tprivate Singleton() {}\n\t \n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n}\n{% endcodeblock %}\n\n**优点**：在类加载的时候，实例化，线程安全。\n\n**缺点**：类加载的时候就实例了。所以这个实例，可能加载了也并不会被使用，会内存浪费。这个种浪费还是能接受的。\n\n#### 懒汉模式\n\n1. 直接创建\n{% codeblock %}\npublic class Singleton {\n\t\t\t \n\tprivate static Singleton instance=null;\n\t\n\tprivate Singleton() {};\n\t\n\tpublic static Singleton getInstance(){\n\t\tif(instance==null){\n\t\t\tinstance=new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n{% endcodeblock %}\n\n**特点**：非线程安全，可能两条线程请求，可能会创建两个实例。\n\n**不可用**\n\n2. 方法加锁\n{% codeblock %}\npublic class Singleton {\n \n\tprivate static Singleton instance=null;\n\t\n\tprivate Singleton() {};\n\t\n\tpublic static synchronized Singleton getInstance(){\n\t\tif(instance==null){\n\t\t\tinstance=new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n{% endcodeblock %}\n\n**特点**：线程安全，但是性能低下，多线程访问，效率低。\n\n**不可用**\n\n3. 创建时加锁\n{% codeblock %}\npublic class Singleton {\n \n\tprivate static Singleton instance=null;\n\n\tprivate Singleton() {};\n\t\n\tpublic static Singleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tinstance = new Singleton();\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n{% endcodeblock %}\n\n**特点**：非线程安全，两条线程进入if判断，进入synchronized执行。两个线程都会执行，并且都会创建对象\n\n**不可用**\n\n4. 加锁双重验证\n{% codeblock %}\npublic class Singleton {\n\t\n\tprivate static Singleton instance=null;\n\t\n\tprivate Singleton() {};\n\t\n\tpublic static Singleton getInstance(){\n\t\t if (instance == null) {  \n\t          synchronized (Singleton.class) {  \n\t              if (instance == null) {  \n\t            \t  instance = new Singleton();  \n\t              }  \n\t          }  \n\t      }  \n\t      return instance;  \n\t}\n}\n{% endcodeblock %}\n**特点**：线程安全。双重校验，保证了线程安全和效率。懒汉中\n\n**推荐**\n\n#### 内部类\n{% codeblock %}\npublic class Singleton{\n\t\t\t\n\tprivate Singleton() {};\n\t\n\tprivate static class SingletonHolder{\n\t\tprivate static Singleton instance=new Singleton();\n\t} \n\t\n\tpublic static Singleton getInstance(){\n\t\treturn SingletonHolder.instance;\n\t}\n}\n{% endcodeblock %}\n**特点**：线程安全，延时加载，在调用的时候才加载。效率高\n\n#### 枚举\n{% codeblock %}\npublic enum SingletonEnum {\n\t\n\t instance; \n\t \n\t private SingletonEnum() {}\n\t \n\t public void method(){\n\n\t }\n}\n{% endcodeblock %}\n**特点**：借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。\n\n### 源码地址：\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/single</a>\n","slug":"设计模式-单例【Single】","published":1,"updated":"2018-11-12T12:38:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syo3000w43xrox6vkk2r","content":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>单例，只new一次对象，全局只有一个对象实例。</p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>单例，在日常开发中，可以说的最常用的。应用的很广泛，也有很多不同的实现。全局只有一个类实例。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>1.构造函数私有，不能使用 new 直接创建对象。</p>\n<p>2.通过静态方法getInstance()方法，创建对象实例。</p>\n<p>3.对象实例引用只对自己可见。</p>\n<h3 id=\"单例与静态\"><a href=\"#单例与静态\" class=\"headerlink\" title=\"单例与静态\"></a>单例与静态</h3><ul>\n<li><p>单例：可以持有状态，可以线程安全，可以实现lazy-load，全局只有一个实例。</p>\n</li>\n<li><p>静态：并不能持有状态，线程安全，并在是类加载的时候，就实例了。</p>\n</li>\n</ul>\n<h3 id=\"写法\"><a href=\"#写法\" class=\"headerlink\" title=\"写法\"></a>写法</h3><h4 id=\"饿汉模式-推荐\"><a href=\"#饿汉模式-推荐\" class=\"headerlink\" title=\"饿汉模式(推荐)\"></a>饿汉模式(推荐)</h4><ol>\n<li><p>静态变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>静态块</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate static Singleton<span class=\"built_in\"> instance </span>= <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\tstatic &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">\tinstance </span>= new Singleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\tpublic static Singleton getInstance() &#123;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>优点</strong>：在类加载的时候，实例化，线程安全。</p>\n<p><strong>缺点</strong>：类加载的时候就实例了。所以这个实例，可能加载了也并不会被使用，会内存浪费。这个种浪费还是能接受的。</p>\n<h4 id=\"懒汉模式\"><a href=\"#懒汉模式\" class=\"headerlink\" title=\"懒汉模式\"></a>懒汉模式</h4><ol>\n<li>直接创建<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\">\t\t\t </span><br><span class=\"line\">\tprivate static Singleton <span class=\"attribute\">instance</span>=<span class=\"literal\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static Singleton getInstance()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"attribute\">instance</span>==null)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">instance</span>=new Singleton();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>特点</strong>：非线程安全，可能两条线程请求，可能会创建两个实例。</p>\n<p><strong>不可用</strong></p>\n<ol start=\"2\">\n<li>方法加锁<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate static Singleton <span class=\"attribute\">instance</span>=<span class=\"literal\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static synchronized Singleton getInstance()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"attribute\">instance</span>==null)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">instance</span>=new Singleton();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>特点</strong>：线程安全，但是性能低下，多线程访问，效率低。</p>\n<p><strong>不可用</strong></p>\n<ol start=\"3\">\n<li>创建时加锁<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate static Singleton <span class=\"attribute\">instance</span>=<span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static Singleton getInstance() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tsynchronized (Singleton.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">\tinstance </span>= new Singleton();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>特点</strong>：非线程安全，两条线程进入if判断，进入synchronized执行。两个线程都会执行，并且都会创建对象</p>\n<p><strong>不可用</strong></p>\n<ol start=\"4\">\n<li>加锁双重验证<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate static Singleton <span class=\"attribute\">instance</span>=<span class=\"literal\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static Singleton getInstance()&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">\t          synchronized (Singleton.class) &#123;  </span><br><span class=\"line\">\t              <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">\t            \t <span class=\"built_in\"> instance </span>= new Singleton();  </span><br><span class=\"line\">\t              &#125;  </span><br><span class=\"line\">\t          &#125;  </span><br><span class=\"line\">\t      &#125;  </span><br><span class=\"line\">\t      return<span class=\"built_in\"> instance; </span> </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<strong>特点</strong>：线程安全。双重校验，保证了线程安全和效率。懒汉中</li>\n</ol>\n<p><strong>推荐</strong></p>\n<h4 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span>&#123;</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span>&#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SingletonHolder.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：线程安全，延时加载，在调用的时候才加载。效率高</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> SingletonEnum <span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t</span></span><br><span class=\"line\"><span class=\"comment\">\t instance; </span></span><br><span class=\"line\"><span class=\"comment\">\t </span></span><br><span class=\"line\"><span class=\"comment\">\t private SingletonEnum() &#123;&#125;</span></span><br><span class=\"line\">\t </span><br><span class=\"line\">\t <span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">\t &#125;</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。</p>\n<h3 id=\"源码地址：\"><a href=\"#源码地址：\" class=\"headerlink\" title=\"源码地址：\"></a>源码地址：</h3><p><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/single\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/single</a></a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>单例，只new一次对象，全局只有一个对象实例。</p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>单例，在日常开发中，可以说的最常用的。应用的很广泛，也有很多不同的实现。全局只有一个类实例。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>1.构造函数私有，不能使用 new 直接创建对象。</p>\n<p>2.通过静态方法getInstance()方法，创建对象实例。</p>\n<p>3.对象实例引用只对自己可见。</p>\n<h3 id=\"单例与静态\"><a href=\"#单例与静态\" class=\"headerlink\" title=\"单例与静态\"></a>单例与静态</h3><ul>\n<li><p>单例：可以持有状态，可以线程安全，可以实现lazy-load，全局只有一个实例。</p>\n</li>\n<li><p>静态：并不能持有状态，线程安全，并在是类加载的时候，就实例了。</p>\n</li>\n</ul>\n<h3 id=\"写法\"><a href=\"#写法\" class=\"headerlink\" title=\"写法\"></a>写法</h3><h4 id=\"饿汉模式-推荐\"><a href=\"#饿汉模式-推荐\" class=\"headerlink\" title=\"饿汉模式(推荐)\"></a>饿汉模式(推荐)</h4><ol>\n<li><p>静态变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>静态块</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate static Singleton<span class=\"built_in\"> instance </span>= <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\tstatic &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">\tinstance </span>= new Singleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\tpublic static Singleton getInstance() &#123;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>优点</strong>：在类加载的时候，实例化，线程安全。</p>\n<p><strong>缺点</strong>：类加载的时候就实例了。所以这个实例，可能加载了也并不会被使用，会内存浪费。这个种浪费还是能接受的。</p>\n<h4 id=\"懒汉模式\"><a href=\"#懒汉模式\" class=\"headerlink\" title=\"懒汉模式\"></a>懒汉模式</h4><ol>\n<li>直接创建<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\">\t\t\t </span><br><span class=\"line\">\tprivate static Singleton <span class=\"attribute\">instance</span>=<span class=\"literal\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static Singleton getInstance()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"attribute\">instance</span>==null)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">instance</span>=new Singleton();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>特点</strong>：非线程安全，可能两条线程请求，可能会创建两个实例。</p>\n<p><strong>不可用</strong></p>\n<ol start=\"2\">\n<li>方法加锁<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate static Singleton <span class=\"attribute\">instance</span>=<span class=\"literal\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static synchronized Singleton getInstance()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"attribute\">instance</span>==null)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">instance</span>=new Singleton();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>特点</strong>：线程安全，但是性能低下，多线程访问，效率低。</p>\n<p><strong>不可用</strong></p>\n<ol start=\"3\">\n<li>创建时加锁<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate static Singleton <span class=\"attribute\">instance</span>=<span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static Singleton getInstance() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tsynchronized (Singleton.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">\tinstance </span>= new Singleton();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>特点</strong>：非线程安全，两条线程进入if判断，进入synchronized执行。两个线程都会执行，并且都会创建对象</p>\n<p><strong>不可用</strong></p>\n<ol start=\"4\">\n<li>加锁双重验证<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate static Singleton <span class=\"attribute\">instance</span>=<span class=\"literal\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tprivate Singleton() &#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static Singleton getInstance()&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">\t          synchronized (Singleton.class) &#123;  </span><br><span class=\"line\">\t              <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">\t            \t <span class=\"built_in\"> instance </span>= new Singleton();  </span><br><span class=\"line\">\t              &#125;  </span><br><span class=\"line\">\t          &#125;  </span><br><span class=\"line\">\t      &#125;  </span><br><span class=\"line\">\t      return<span class=\"built_in\"> instance; </span> </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<strong>特点</strong>：线程安全。双重校验，保证了线程安全和效率。懒汉中</li>\n</ol>\n<p><strong>推荐</strong></p>\n<h4 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span>&#123;</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span>&#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance=<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SingletonHolder.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：线程安全，延时加载，在调用的时候才加载。效率高</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> SingletonEnum <span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t</span></span><br><span class=\"line\"><span class=\"comment\">\t instance; </span></span><br><span class=\"line\"><span class=\"comment\">\t </span></span><br><span class=\"line\"><span class=\"comment\">\t private SingletonEnum() &#123;&#125;</span></span><br><span class=\"line\">\t </span><br><span class=\"line\">\t <span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">\t &#125;</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。</p>\n<h3 id=\"源码地址：\"><a href=\"#源码地址：\" class=\"headerlink\" title=\"源码地址：\"></a>源码地址：</h3><p><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/single\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/single</a></a></p>"},{"title":"设计模式-原型【Prototype】","date":"2018-08-04T12:32:01.000Z","type":"categories","_content":"\n![](img/index-page-img/设计模式.png)\n\n原型设计模式，实现clone接口，复制新对象。\n\n<!-- more -->\n\n### 介绍\n原型设计模式，还是挺重要的，在日常开发中，可能经常用到，但是我们都没有注意，或者是有些应该用原型而没有用。**原型设计模式主要是通过复制的方式生成实力。**\n\n\n### 应用场景\n\n\n### UML\n\n![](img/设计模式-原型Prototype/UML.png)\n\n\n### 方法说明\n\nPrototype(原型接口)：原型接口，用于定义原型类对象，定义clone方法，子类实现clone方法，接口对外提供clone方法。\t\t\nConcretePrototype(具体实现类)：实现Prototype接口，并且**实现**clone方法。\t\nClient(客户端)：client通过接口调用clone，复制生成新的对象。\n\n\n### 优缺点\n* 优点:在复制对象的时候，不需要关系如何复制。\n* 缺点:可能不同业务，实现方式并不满足。\n\n\n### 拓展型\n完全和客户端解耦，client只是调用，并不需要关心，原型类对象的内部实现。并且，都是在单个对象中定义。指责单一。\n\n\n**代码地址**:\n\n\n\n\n\n\n\n","source":"_posts/设计模式-原型【Prototype】.md","raw":"---\ntitle: 设计模式-原型【Prototype】\ndate: 2018-08-04 20:32:01\ntype: \"categories\"\ncategories: 设计模式\ntags: 设计模式\n---\n\n![](img/index-page-img/设计模式.png)\n\n原型设计模式，实现clone接口，复制新对象。\n\n<!-- more -->\n\n### 介绍\n原型设计模式，还是挺重要的，在日常开发中，可能经常用到，但是我们都没有注意，或者是有些应该用原型而没有用。**原型设计模式主要是通过复制的方式生成实力。**\n\n\n### 应用场景\n\n\n### UML\n\n![](img/设计模式-原型Prototype/UML.png)\n\n\n### 方法说明\n\nPrototype(原型接口)：原型接口，用于定义原型类对象，定义clone方法，子类实现clone方法，接口对外提供clone方法。\t\t\nConcretePrototype(具体实现类)：实现Prototype接口，并且**实现**clone方法。\t\nClient(客户端)：client通过接口调用clone，复制生成新的对象。\n\n\n### 优缺点\n* 优点:在复制对象的时候，不需要关系如何复制。\n* 缺点:可能不同业务，实现方式并不满足。\n\n\n### 拓展型\n完全和客户端解耦，client只是调用，并不需要关心，原型类对象的内部实现。并且，都是在单个对象中定义。指责单一。\n\n\n**代码地址**:\n\n\n\n\n\n\n\n","slug":"设计模式-原型【Prototype】","published":1,"updated":"2018-11-11T02:36:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syo6001043xrj0c3i3hh","content":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>原型设计模式，实现clone接口，复制新对象。</p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>原型设计模式，还是挺重要的，在日常开发中，可能经常用到，但是我们都没有注意，或者是有些应该用原型而没有用。<strong>原型设计模式主要是通过复制的方式生成实力。</strong></p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-原型Prototype/UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><p>Prototype(原型接口)：原型接口，用于定义原型类对象，定义clone方法，子类实现clone方法，接口对外提供clone方法。<br>ConcretePrototype(具体实现类)：实现Prototype接口，并且<strong>实现</strong>clone方法。<br>Client(客户端)：client通过接口调用clone，复制生成新的对象。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>优点:在复制对象的时候，不需要关系如何复制。</li>\n<li>缺点:可能不同业务，实现方式并不满足。</li>\n</ul>\n<h3 id=\"拓展型\"><a href=\"#拓展型\" class=\"headerlink\" title=\"拓展型\"></a>拓展型</h3><p>完全和客户端解耦，client只是调用，并不需要关心，原型类对象的内部实现。并且，都是在单个对象中定义。指责单一。</p>\n<p><strong>代码地址</strong>:</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>原型设计模式，实现clone接口，复制新对象。</p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>原型设计模式，还是挺重要的，在日常开发中，可能经常用到，但是我们都没有注意，或者是有些应该用原型而没有用。<strong>原型设计模式主要是通过复制的方式生成实力。</strong></p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-原型Prototype/UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><p>Prototype(原型接口)：原型接口，用于定义原型类对象，定义clone方法，子类实现clone方法，接口对外提供clone方法。<br>ConcretePrototype(具体实现类)：实现Prototype接口，并且<strong>实现</strong>clone方法。<br>Client(客户端)：client通过接口调用clone，复制生成新的对象。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>优点:在复制对象的时候，不需要关系如何复制。</li>\n<li>缺点:可能不同业务，实现方式并不满足。</li>\n</ul>\n<h3 id=\"拓展型\"><a href=\"#拓展型\" class=\"headerlink\" title=\"拓展型\"></a>拓展型</h3><p>完全和客户端解耦，client只是调用，并不需要关心，原型类对象的内部实现。并且，都是在单个对象中定义。指责单一。</p>\n<p><strong>代码地址</strong>:</p>"},{"title":"设计模式-模版【Tempalte Method】","date":"2018-06-09T01:08:35.000Z","type":"categories","_content":"\n![](img/index-page-img/设计模式.png)\n\n模版方法，父类定义模版方法，子类重写抽象和钩子方法。\n\n<!-- more -->\n\n\n### 介绍\n设计模式中，模版设计模式，在日常的开发中，是比较常用的了。很好的复合了**ocp**(Open Closed Principle)，通过继承的方式，客户端重写**抽象方法**和**钩子方法**，实现自己的业务，很好的拓展性。我刚刚开始接触的时候对这个钩子方法也是很迷惑，在下面讲整个结构的时候，会详细的讲解钩子函数。\n\n\n### 应用场景\n\n\n### UML\n\n![](img/设计模式-模版方法Template/模版设计模式UML.png)\n\n\n### 方法说明\t\n\n模版方法(main):模版方法，客户端调用的主要方法。\t\t\n抽象方法(concreteMethod):子类提供具体业务实现。\t\t\n勾子方法(hookMethod):父类中提供默认空实现，并且这个方法会在**模版方法**调用，子类可以重写也可以不用重写。\n\n\n### 使用\t\n\n父类：定义模版方法，并且定义抽象方法和钩子方法。\t\t\n子类：根据具体的业务需要重写抽象方法。也可以根据具体的业务场景，重写钩子方法。当然也不可以重写钩子方法。也可以业务定义新的方法。\t\t\n客户端(client)：调用时候主要是调用**模版方法**。\n\n\n### 优缺点\n* 优点：\n* 缺点：\n\n\n### 拓展性\n具有很好的拓展型，根据不同的业务定义不同的子类。\n\n\n### 实例\n\n\n**源码地址**：\n\n","source":"_posts/设计模式-模版【Tempalte Method】.md","raw":"---\ntitle: 设计模式-模版【Tempalte Method】\ndate: 2018-06-09 09:08:35\ntype: \"categories\"\ncategories: 设计模式\ntags: 设计模式\n---\n\n![](img/index-page-img/设计模式.png)\n\n模版方法，父类定义模版方法，子类重写抽象和钩子方法。\n\n<!-- more -->\n\n\n### 介绍\n设计模式中，模版设计模式，在日常的开发中，是比较常用的了。很好的复合了**ocp**(Open Closed Principle)，通过继承的方式，客户端重写**抽象方法**和**钩子方法**，实现自己的业务，很好的拓展性。我刚刚开始接触的时候对这个钩子方法也是很迷惑，在下面讲整个结构的时候，会详细的讲解钩子函数。\n\n\n### 应用场景\n\n\n### UML\n\n![](img/设计模式-模版方法Template/模版设计模式UML.png)\n\n\n### 方法说明\t\n\n模版方法(main):模版方法，客户端调用的主要方法。\t\t\n抽象方法(concreteMethod):子类提供具体业务实现。\t\t\n勾子方法(hookMethod):父类中提供默认空实现，并且这个方法会在**模版方法**调用，子类可以重写也可以不用重写。\n\n\n### 使用\t\n\n父类：定义模版方法，并且定义抽象方法和钩子方法。\t\t\n子类：根据具体的业务需要重写抽象方法。也可以根据具体的业务场景，重写钩子方法。当然也不可以重写钩子方法。也可以业务定义新的方法。\t\t\n客户端(client)：调用时候主要是调用**模版方法**。\n\n\n### 优缺点\n* 优点：\n* 缺点：\n\n\n### 拓展性\n具有很好的拓展型，根据不同的业务定义不同的子类。\n\n\n### 实例\n\n\n**源码地址**：\n\n","slug":"设计模式-模版【Tempalte Method】","published":1,"updated":"2018-11-11T02:32:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syo8001243xrvpfekg7d","content":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>模版方法，父类定义模版方法，子类重写抽象和钩子方法。</p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>设计模式中，模版设计模式，在日常的开发中，是比较常用的了。很好的复合了<strong>ocp</strong>(Open Closed Principle)，通过继承的方式，客户端重写<strong>抽象方法</strong>和<strong>钩子方法</strong>，实现自己的业务，很好的拓展性。我刚刚开始接触的时候对这个钩子方法也是很迷惑，在下面讲整个结构的时候，会详细的讲解钩子函数。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-模版方法Template/模版设计模式UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><p>模版方法(main):模版方法，客户端调用的主要方法。<br>抽象方法(concreteMethod):子类提供具体业务实现。<br>勾子方法(hookMethod):父类中提供默认空实现，并且这个方法会在<strong>模版方法</strong>调用，子类可以重写也可以不用重写。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>父类：定义模版方法，并且定义抽象方法和钩子方法。<br>子类：根据具体的业务需要重写抽象方法。也可以根据具体的业务场景，重写钩子方法。当然也不可以重写钩子方法。也可以业务定义新的方法。<br>客户端(client)：调用时候主要是调用<strong>模版方法</strong>。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>优点：</li>\n<li>缺点：</li>\n</ul>\n<h3 id=\"拓展性\"><a href=\"#拓展性\" class=\"headerlink\" title=\"拓展性\"></a>拓展性</h3><p>具有很好的拓展型，根据不同的业务定义不同的子类。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p><strong>源码地址</strong>：</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>模版方法，父类定义模版方法，子类重写抽象和钩子方法。</p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>设计模式中，模版设计模式，在日常的开发中，是比较常用的了。很好的复合了<strong>ocp</strong>(Open Closed Principle)，通过继承的方式，客户端重写<strong>抽象方法</strong>和<strong>钩子方法</strong>，实现自己的业务，很好的拓展性。我刚刚开始接触的时候对这个钩子方法也是很迷惑，在下面讲整个结构的时候，会详细的讲解钩子函数。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-模版方法Template/模版设计模式UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><p>模版方法(main):模版方法，客户端调用的主要方法。<br>抽象方法(concreteMethod):子类提供具体业务实现。<br>勾子方法(hookMethod):父类中提供默认空实现，并且这个方法会在<strong>模版方法</strong>调用，子类可以重写也可以不用重写。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>父类：定义模版方法，并且定义抽象方法和钩子方法。<br>子类：根据具体的业务需要重写抽象方法。也可以根据具体的业务场景，重写钩子方法。当然也不可以重写钩子方法。也可以业务定义新的方法。<br>客户端(client)：调用时候主要是调用<strong>模版方法</strong>。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>优点：</li>\n<li>缺点：</li>\n</ul>\n<h3 id=\"拓展性\"><a href=\"#拓展性\" class=\"headerlink\" title=\"拓展性\"></a>拓展性</h3><p>具有很好的拓展型，根据不同的业务定义不同的子类。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p><strong>源码地址</strong>：</p>"},{"title":"设计模式-组合【Composite】","date":"2018-08-18T10:23:40.000Z","type":"categories","_content":"\n![](img/index-page-img/设计模式.png)\n\n组合状态模式，递归组合目标数据结构。\n\n<!-- more -->\n\n### 介绍\n\n**组合设计模式**，主要是使用容器和内容具有一致性，并使用这种一致性，去创建**递归的数据结构**。\n\n\n### 应用场景\n\n根据的结构设计模式的特点：递归的数据机构。可以构建，**树**，**文件夹**，这种迭代的数据结构。\t\t\n还有一些其他的设计模式种，也有使用**组合设计模式**，比如，命令模式，访问者模式，装饰器，都是使用组合设计模式类似的思想。\n\n\n### UML\n\n![](img/设计模式-组合Composite/UML.png)\n\n\n### 方法说明\n\n* Component:抽象类，定义结构的主要方法，定义add和remove，根据业务定义业务方法。\n* Leaf:子类，结构体内的数据节点。\n* Composite:组合体，用于递归存储的机构。\n* Client:使用Leaf和Composite构建递归数据结构。\n\n\n### 优点\n\n一致性，可以构建递归数据结构。\n\n\n源码地址:\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/composite</a>","source":"_posts/设计模式-组合【Composite】.md","raw":"---\ntitle: 设计模式-组合【Composite】\ndate: 2018-08-18 18:23:40\ntype: \"categories\"\ncategories: 设计模式\ntags: 设计模式\n---\n\n![](img/index-page-img/设计模式.png)\n\n组合状态模式，递归组合目标数据结构。\n\n<!-- more -->\n\n### 介绍\n\n**组合设计模式**，主要是使用容器和内容具有一致性，并使用这种一致性，去创建**递归的数据结构**。\n\n\n### 应用场景\n\n根据的结构设计模式的特点：递归的数据机构。可以构建，**树**，**文件夹**，这种迭代的数据结构。\t\t\n还有一些其他的设计模式种，也有使用**组合设计模式**，比如，命令模式，访问者模式，装饰器，都是使用组合设计模式类似的思想。\n\n\n### UML\n\n![](img/设计模式-组合Composite/UML.png)\n\n\n### 方法说明\n\n* Component:抽象类，定义结构的主要方法，定义add和remove，根据业务定义业务方法。\n* Leaf:子类，结构体内的数据节点。\n* Composite:组合体，用于递归存储的机构。\n* Client:使用Leaf和Composite构建递归数据结构。\n\n\n### 优点\n\n一致性，可以构建递归数据结构。\n\n\n源码地址:\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/composite</a>","slug":"设计模式-组合【Composite】","published":1,"updated":"2018-11-11T02:29:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syoa001643xroc1uzafr","content":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>组合状态模式，递归组合目标数据结构。</p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><strong>组合设计模式</strong>，主要是使用容器和内容具有一致性，并使用这种一致性，去创建<strong>递归的数据结构</strong>。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>根据的结构设计模式的特点：递归的数据机构。可以构建，<strong>树</strong>，<strong>文件夹</strong>，这种迭代的数据结构。<br>还有一些其他的设计模式种，也有使用<strong>组合设计模式</strong>，比如，命令模式，访问者模式，装饰器，都是使用组合设计模式类似的思想。</p>\n<h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-组合Composite/UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><ul>\n<li>Component:抽象类，定义结构的主要方法，定义add和remove，根据业务定义业务方法。</li>\n<li>Leaf:子类，结构体内的数据节点。</li>\n<li>Composite:组合体，用于递归存储的机构。</li>\n<li>Client:使用Leaf和Composite构建递归数据结构。</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>一致性，可以构建递归数据结构。</p>\n<p>源码地址:<br><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/composite\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/composite</a></a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>组合状态模式，递归组合目标数据结构。</p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><strong>组合设计模式</strong>，主要是使用容器和内容具有一致性，并使用这种一致性，去创建<strong>递归的数据结构</strong>。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>根据的结构设计模式的特点：递归的数据机构。可以构建，<strong>树</strong>，<strong>文件夹</strong>，这种迭代的数据结构。<br>还有一些其他的设计模式种，也有使用<strong>组合设计模式</strong>，比如，命令模式，访问者模式，装饰器，都是使用组合设计模式类似的思想。</p>\n<h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-组合Composite/UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><ul>\n<li>Component:抽象类，定义结构的主要方法，定义add和remove，根据业务定义业务方法。</li>\n<li>Leaf:子类，结构体内的数据节点。</li>\n<li>Composite:组合体，用于递归存储的机构。</li>\n<li>Client:使用Leaf和Composite构建递归数据结构。</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>一致性，可以构建递归数据结构。</p>\n<p>源码地址:<br><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/composite\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/composite</a></a></p>"},{"title":"设计模式-适配器【Adapter】","date":"2018-08-12T07:20:10.000Z","type":"categories","_content":"\n![](img/index-page-img/设计模式.png)\n\n适配器，兼容两个不能工作的接口或者类。\n\n<!-- more -->\n\n\n### 介绍\n适配器，在日常开发中还是挺常用的。现在的编程都是面上接口编程，所以，在拓展的时候，一个接口调用另外一个接口的时候，可能就会存在不匹配的时候，那就可以使用适配模式，增加一层适配器，去适配两个接口，这样两个就接口就能正常调用了。\n\n适配器模式有三种：类适配器、对象适配器、接口适配器\n\n\n### 应用场景\n\n主要是应用两个接口不兼容，在两个接口之间做一层适配，让两个接口能够正常工作。\n\n\n### UML\n\n![](img/设计模式-适配器Adapter/UML.png)\n\n\n### 方法说明\t\n\n* client：客户端，调用者。\n* target：目标接口。\n* adapter：适配器，适配，target中的方法，和adaptee中的方法。\n* adaptee：被适配的类或对象或接口。\n\n\n### 使用\t\n\n* 类适配器：adapter **继承** adaptee 中的方法和 **实现** target 中的目标方式，实现的方法中调用adaptee中的方法，从而达到适配的效果。\n* 对象适配器：通过 **构造器** 持有 adaptee 的对象实实例，在实现 target 方法中调用实例的方法，实现适配的效果。\n* 接口适配器：通过 **抽象类** 对 adaptee 默认空实现，在 **继承** abstarctAdapter，在实现 target 中要用到的方法，而不是实现全部的方法，从而达到适配，是组件之间解耦。\t\n\n**注**：接口适配器，并不常用，因为正常接口定义应该符合单一职责原则，并且通过组合的方式，实现不同的功能。所以接口这种用的较少。个人理解，比较鸡肋，但是看到别人有做，就也写上了。主要是类的适配和对象的适配。\n\n\n### 优缺点\n\n保证了client不需要做任何修改，被适配的接口，需要不要修改，保证了开闭原则，并且对源码没有入侵。很好的解耦。\n\n### 拓展性\n\n良好\n\n\n### 个人\n\nquestion：前一阵，在开发中就发现，一个方法要调用另外的一个方法的时候，需要异步调用，可以直接在那个被调用的方法上直接用@Async就能搞定，但是有一个问题，所做的业务同样的方法需要同步调用，和异步调用，直接调用的话，就不能用@Async标注的方法，用原有的方式就需要写两套代码，一套同步，一套异步。\n\nsolution：我就在单独抽象了一个方法，加上@Async注解，通过反射的方式调用。很好的实现了解耦。\t\t\n同步调用：直接调用被调用方法即可。\t\t\n异步调用：将要调用目标方法的 **类名** ， **方法名** ，**参数** 传入，通过spring的反射调用被调用方法。\t\t\n\n\t\t\n\n\n**源码地址**：\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/adapter</a>","source":"_posts/设计模式-适配器【Adapter】.md","raw":"---\ntitle: 设计模式-适配器【Adapter】\ndate: 2018-08-12 15:20:10\ntype: \"categories\"\ncategories: 设计模式\ntags: 设计模式\n---\n\n![](img/index-page-img/设计模式.png)\n\n适配器，兼容两个不能工作的接口或者类。\n\n<!-- more -->\n\n\n### 介绍\n适配器，在日常开发中还是挺常用的。现在的编程都是面上接口编程，所以，在拓展的时候，一个接口调用另外一个接口的时候，可能就会存在不匹配的时候，那就可以使用适配模式，增加一层适配器，去适配两个接口，这样两个就接口就能正常调用了。\n\n适配器模式有三种：类适配器、对象适配器、接口适配器\n\n\n### 应用场景\n\n主要是应用两个接口不兼容，在两个接口之间做一层适配，让两个接口能够正常工作。\n\n\n### UML\n\n![](img/设计模式-适配器Adapter/UML.png)\n\n\n### 方法说明\t\n\n* client：客户端，调用者。\n* target：目标接口。\n* adapter：适配器，适配，target中的方法，和adaptee中的方法。\n* adaptee：被适配的类或对象或接口。\n\n\n### 使用\t\n\n* 类适配器：adapter **继承** adaptee 中的方法和 **实现** target 中的目标方式，实现的方法中调用adaptee中的方法，从而达到适配的效果。\n* 对象适配器：通过 **构造器** 持有 adaptee 的对象实实例，在实现 target 方法中调用实例的方法，实现适配的效果。\n* 接口适配器：通过 **抽象类** 对 adaptee 默认空实现，在 **继承** abstarctAdapter，在实现 target 中要用到的方法，而不是实现全部的方法，从而达到适配，是组件之间解耦。\t\n\n**注**：接口适配器，并不常用，因为正常接口定义应该符合单一职责原则，并且通过组合的方式，实现不同的功能。所以接口这种用的较少。个人理解，比较鸡肋，但是看到别人有做，就也写上了。主要是类的适配和对象的适配。\n\n\n### 优缺点\n\n保证了client不需要做任何修改，被适配的接口，需要不要修改，保证了开闭原则，并且对源码没有入侵。很好的解耦。\n\n### 拓展性\n\n良好\n\n\n### 个人\n\nquestion：前一阵，在开发中就发现，一个方法要调用另外的一个方法的时候，需要异步调用，可以直接在那个被调用的方法上直接用@Async就能搞定，但是有一个问题，所做的业务同样的方法需要同步调用，和异步调用，直接调用的话，就不能用@Async标注的方法，用原有的方式就需要写两套代码，一套同步，一套异步。\n\nsolution：我就在单独抽象了一个方法，加上@Async注解，通过反射的方式调用。很好的实现了解耦。\t\t\n同步调用：直接调用被调用方法即可。\t\t\n异步调用：将要调用目标方法的 **类名** ， **方法名** ，**参数** 传入，通过spring的反射调用被调用方法。\t\t\n\n\t\t\n\n\n**源码地址**：\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/adapter</a>","slug":"设计模式-适配器【Adapter】","published":1,"updated":"2018-11-11T02:26:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syob001843xrz7kprnqf","content":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>适配器，兼容两个不能工作的接口或者类。</p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>适配器，在日常开发中还是挺常用的。现在的编程都是面上接口编程，所以，在拓展的时候，一个接口调用另外一个接口的时候，可能就会存在不匹配的时候，那就可以使用适配模式，增加一层适配器，去适配两个接口，这样两个就接口就能正常调用了。</p>\n<p>适配器模式有三种：类适配器、对象适配器、接口适配器</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>主要是应用两个接口不兼容，在两个接口之间做一层适配，让两个接口能够正常工作。</p>\n<h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-适配器Adapter/UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><ul>\n<li>client：客户端，调用者。</li>\n<li>target：目标接口。</li>\n<li>adapter：适配器，适配，target中的方法，和adaptee中的方法。</li>\n<li>adaptee：被适配的类或对象或接口。</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>类适配器：adapter <strong>继承</strong> adaptee 中的方法和 <strong>实现</strong> target 中的目标方式，实现的方法中调用adaptee中的方法，从而达到适配的效果。</li>\n<li>对象适配器：通过 <strong>构造器</strong> 持有 adaptee 的对象实实例，在实现 target 方法中调用实例的方法，实现适配的效果。</li>\n<li>接口适配器：通过 <strong>抽象类</strong> 对 adaptee 默认空实现，在 <strong>继承</strong> abstarctAdapter，在实现 target 中要用到的方法，而不是实现全部的方法，从而达到适配，是组件之间解耦。    </li>\n</ul>\n<p><strong>注</strong>：接口适配器，并不常用，因为正常接口定义应该符合单一职责原则，并且通过组合的方式，实现不同的功能。所以接口这种用的较少。个人理解，比较鸡肋，但是看到别人有做，就也写上了。主要是类的适配和对象的适配。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>保证了client不需要做任何修改，被适配的接口，需要不要修改，保证了开闭原则，并且对源码没有入侵。很好的解耦。</p>\n<h3 id=\"拓展性\"><a href=\"#拓展性\" class=\"headerlink\" title=\"拓展性\"></a>拓展性</h3><p>良好</p>\n<h3 id=\"个人\"><a href=\"#个人\" class=\"headerlink\" title=\"个人\"></a>个人</h3><p>question：前一阵，在开发中就发现，一个方法要调用另外的一个方法的时候，需要异步调用，可以直接在那个被调用的方法上直接用@Async就能搞定，但是有一个问题，所做的业务同样的方法需要同步调用，和异步调用，直接调用的话，就不能用@Async标注的方法，用原有的方式就需要写两套代码，一套同步，一套异步。</p>\n<p>solution：我就在单独抽象了一个方法，加上@Async注解，通过反射的方式调用。很好的实现了解耦。<br>同步调用：直接调用被调用方法即可。<br>异步调用：将要调用目标方法的 <strong>类名</strong> ， <strong>方法名</strong> ，<strong>参数</strong> 传入，通过spring的反射调用被调用方法。        </p>\n<p><strong>源码地址</strong>：<br><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/adapter\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/adapter</a></a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>适配器，兼容两个不能工作的接口或者类。</p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>适配器，在日常开发中还是挺常用的。现在的编程都是面上接口编程，所以，在拓展的时候，一个接口调用另外一个接口的时候，可能就会存在不匹配的时候，那就可以使用适配模式，增加一层适配器，去适配两个接口，这样两个就接口就能正常调用了。</p>\n<p>适配器模式有三种：类适配器、对象适配器、接口适配器</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>主要是应用两个接口不兼容，在两个接口之间做一层适配，让两个接口能够正常工作。</p>\n<h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-适配器Adapter/UML.png\" alt=\"\"></p>\n<h3 id=\"方法说明\"><a href=\"#方法说明\" class=\"headerlink\" title=\"方法说明\"></a>方法说明</h3><ul>\n<li>client：客户端，调用者。</li>\n<li>target：目标接口。</li>\n<li>adapter：适配器，适配，target中的方法，和adaptee中的方法。</li>\n<li>adaptee：被适配的类或对象或接口。</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>类适配器：adapter <strong>继承</strong> adaptee 中的方法和 <strong>实现</strong> target 中的目标方式，实现的方法中调用adaptee中的方法，从而达到适配的效果。</li>\n<li>对象适配器：通过 <strong>构造器</strong> 持有 adaptee 的对象实实例，在实现 target 方法中调用实例的方法，实现适配的效果。</li>\n<li>接口适配器：通过 <strong>抽象类</strong> 对 adaptee 默认空实现，在 <strong>继承</strong> abstarctAdapter，在实现 target 中要用到的方法，而不是实现全部的方法，从而达到适配，是组件之间解耦。    </li>\n</ul>\n<p><strong>注</strong>：接口适配器，并不常用，因为正常接口定义应该符合单一职责原则，并且通过组合的方式，实现不同的功能。所以接口这种用的较少。个人理解，比较鸡肋，但是看到别人有做，就也写上了。主要是类的适配和对象的适配。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>保证了client不需要做任何修改，被适配的接口，需要不要修改，保证了开闭原则，并且对源码没有入侵。很好的解耦。</p>\n<h3 id=\"拓展性\"><a href=\"#拓展性\" class=\"headerlink\" title=\"拓展性\"></a>拓展性</h3><p>良好</p>\n<h3 id=\"个人\"><a href=\"#个人\" class=\"headerlink\" title=\"个人\"></a>个人</h3><p>question：前一阵，在开发中就发现，一个方法要调用另外的一个方法的时候，需要异步调用，可以直接在那个被调用的方法上直接用@Async就能搞定，但是有一个问题，所做的业务同样的方法需要同步调用，和异步调用，直接调用的话，就不能用@Async标注的方法，用原有的方式就需要写两套代码，一套同步，一套异步。</p>\n<p>solution：我就在单独抽象了一个方法，加上@Async注解，通过反射的方式调用。很好的实现了解耦。<br>同步调用：直接调用被调用方法即可。<br>异步调用：将要调用目标方法的 <strong>类名</strong> ， <strong>方法名</strong> ，<strong>参数</strong> 传入，通过spring的反射调用被调用方法。        </p>\n<p><strong>源码地址</strong>：<br><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/adapter\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/adapter</a></a></p>"},{"title":"设计模式-责任链【Chain Of Responsibility】","date":"2018-11-10T03:24:14.000Z","type":"categories","_content":"\n![](img/index-page-img/设计模式.png)\n\n责任链，将多个对象组合成一条责任链，对逻辑进行链式处理。\n\n<!-- more -->\n\n### 介绍\n责任链设计模式，在web开发中，使用可能比较少，但是应用还是比较多，比如，拦截器的实现，过滤器，tomcat 处理请求，mybatis的拦截器。应用的例子很多。这也是一个比较重要的设计模式。\n\n### UML\n\n![](img/设计模式-责任链【Chain Of Responsibility】/UML.png)\n\n\n### 使用说明\n\n* clent:调用方Handler.excute()。调用整个执行链\n* Handler:责任链上的对象的接口类,定义责任链上的类的接口。\t\n\t1. setNext(Handler)：设置责任链上下处理业务handler\t\t\n\t2. excute()：对外报漏的执行方法，触发执行整个责任链。整个链的执行逻辑方法，执行下个节点还是返回。\t\t\t\n\t3. abstract process():抽象方法，业务子类实现该方法，每个业务处理单元实现业务方法\n* AHandler:实现handler抽象process方法，业务处理方法\n* BHandler:实现handler抽象process方法，业务处理方法，还有一些私有的方法。\n\n### 应用\n\n在很多地方都有应用，在tomcat处理请求的时候，对request的处理就使用了责任链的设计模式对，请求惊醒处理，先处理过滤器逻辑，在处理拦截器，在根据url的mapping映射到对应的业务逻辑处理Controller。在做mybatis插件的时候，他的拦截器也是使用的责任的设计模式。\n\n### 优点\n\n举个例子，就拿request请求来说，到达服务的时候，可能对url很多不同的处理，全部的逻辑在一个方法里，或者是一个类，这样，方法，类的职业，并不单一，并且全部耦合在一起，一旦逻辑复杂维护成高会非常高。\n\n使用责任链设计模式，就弱化了请求方和处理方的关联关系，很好的解耦，每一个组件都可以成为一个独立服用的组件，并且可以通过组合的方式，可以处理流程更加灵活。逻辑性更加清晰，可以使用配置的方式，组合不同责任链组件，维护成本也会大大减低。\n\n### 源地址\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/chain-of-responsibility</a>\n\n","source":"_posts/设计模式-责任链【Chain-Of-Responsibility】.md","raw":"---\ntitle: 设计模式-责任链【Chain Of Responsibility】\ndate: 2018-11-10 11:24:14\ntype: \"categories\"\ncategories: 设计模式\ntags: 设计模式\n---\n\n![](img/index-page-img/设计模式.png)\n\n责任链，将多个对象组合成一条责任链，对逻辑进行链式处理。\n\n<!-- more -->\n\n### 介绍\n责任链设计模式，在web开发中，使用可能比较少，但是应用还是比较多，比如，拦截器的实现，过滤器，tomcat 处理请求，mybatis的拦截器。应用的例子很多。这也是一个比较重要的设计模式。\n\n### UML\n\n![](img/设计模式-责任链【Chain Of Responsibility】/UML.png)\n\n\n### 使用说明\n\n* clent:调用方Handler.excute()。调用整个执行链\n* Handler:责任链上的对象的接口类,定义责任链上的类的接口。\t\n\t1. setNext(Handler)：设置责任链上下处理业务handler\t\t\n\t2. excute()：对外报漏的执行方法，触发执行整个责任链。整个链的执行逻辑方法，执行下个节点还是返回。\t\t\t\n\t3. abstract process():抽象方法，业务子类实现该方法，每个业务处理单元实现业务方法\n* AHandler:实现handler抽象process方法，业务处理方法\n* BHandler:实现handler抽象process方法，业务处理方法，还有一些私有的方法。\n\n### 应用\n\n在很多地方都有应用，在tomcat处理请求的时候，对request的处理就使用了责任链的设计模式对，请求惊醒处理，先处理过滤器逻辑，在处理拦截器，在根据url的mapping映射到对应的业务逻辑处理Controller。在做mybatis插件的时候，他的拦截器也是使用的责任的设计模式。\n\n### 优点\n\n举个例子，就拿request请求来说，到达服务的时候，可能对url很多不同的处理，全部的逻辑在一个方法里，或者是一个类，这样，方法，类的职业，并不单一，并且全部耦合在一起，一旦逻辑复杂维护成高会非常高。\n\n使用责任链设计模式，就弱化了请求方和处理方的关联关系，很好的解耦，每一个组件都可以成为一个独立服用的组件，并且可以通过组合的方式，可以处理流程更加灵活。逻辑性更加清晰，可以使用配置的方式，组合不同责任链组件，维护成本也会大大减低。\n\n### 源地址\n<a>https://github.com/wangypeng/java-design-mode-source/tree/master/chain-of-responsibility</a>\n\n","slug":"设计模式-责任链【Chain-Of-Responsibility】","published":1,"updated":"2018-11-10T14:12:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3syod001c43xr8zzwe82b","content":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>责任链，将多个对象组合成一条责任链，对逻辑进行链式处理。</p>\n<a id=\"more\"></a>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>责任链设计模式，在web开发中，使用可能比较少，但是应用还是比较多，比如，拦截器的实现，过滤器，tomcat 处理请求，mybatis的拦截器。应用的例子很多。这也是一个比较重要的设计模式。</p>\n<h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-责任链【Chain Of Responsibility】/UML.png\" alt=\"\"></p>\n<h3 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h3><ul>\n<li>clent:调用方Handler.excute()。调用整个执行链</li>\n<li>Handler:责任链上的对象的接口类,定义责任链上的类的接口。    <ol>\n<li>setNext(Handler)：设置责任链上下处理业务handler        </li>\n<li>excute()：对外报漏的执行方法，触发执行整个责任链。整个链的执行逻辑方法，执行下个节点还是返回。            </li>\n<li>abstract process():抽象方法，业务子类实现该方法，每个业务处理单元实现业务方法</li>\n</ol>\n</li>\n<li>AHandler:实现handler抽象process方法，业务处理方法</li>\n<li>BHandler:实现handler抽象process方法，业务处理方法，还有一些私有的方法。</li>\n</ul>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>在很多地方都有应用，在tomcat处理请求的时候，对request的处理就使用了责任链的设计模式对，请求惊醒处理，先处理过滤器逻辑，在处理拦截器，在根据url的mapping映射到对应的业务逻辑处理Controller。在做mybatis插件的时候，他的拦截器也是使用的责任的设计模式。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>举个例子，就拿request请求来说，到达服务的时候，可能对url很多不同的处理，全部的逻辑在一个方法里，或者是一个类，这样，方法，类的职业，并不单一，并且全部耦合在一起，一旦逻辑复杂维护成高会非常高。</p>\n<p>使用责任链设计模式，就弱化了请求方和处理方的关联关系，很好的解耦，每一个组件都可以成为一个独立服用的组件，并且可以通过组合的方式，可以处理流程更加灵活。逻辑性更加清晰，可以使用配置的方式，组合不同责任链组件，维护成本也会大大减低。</p>\n<h3 id=\"源地址\"><a href=\"#源地址\" class=\"headerlink\" title=\"源地址\"></a>源地址</h3><p><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/chain-of-responsibility\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/chain-of-responsibility</a></a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"img/index-page-img/设计模式.png\" alt=\"\"></p>\n<p>责任链，将多个对象组合成一条责任链，对逻辑进行链式处理。</p>","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>责任链设计模式，在web开发中，使用可能比较少，但是应用还是比较多，比如，拦截器的实现，过滤器，tomcat 处理请求，mybatis的拦截器。应用的例子很多。这也是一个比较重要的设计模式。</p>\n<h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"img/设计模式-责任链【Chain Of Responsibility】/UML.png\" alt=\"\"></p>\n<h3 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h3><ul>\n<li>clent:调用方Handler.excute()。调用整个执行链</li>\n<li>Handler:责任链上的对象的接口类,定义责任链上的类的接口。    <ol>\n<li>setNext(Handler)：设置责任链上下处理业务handler        </li>\n<li>excute()：对外报漏的执行方法，触发执行整个责任链。整个链的执行逻辑方法，执行下个节点还是返回。            </li>\n<li>abstract process():抽象方法，业务子类实现该方法，每个业务处理单元实现业务方法</li>\n</ol>\n</li>\n<li>AHandler:实现handler抽象process方法，业务处理方法</li>\n<li>BHandler:实现handler抽象process方法，业务处理方法，还有一些私有的方法。</li>\n</ul>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>在很多地方都有应用，在tomcat处理请求的时候，对request的处理就使用了责任链的设计模式对，请求惊醒处理，先处理过滤器逻辑，在处理拦截器，在根据url的mapping映射到对应的业务逻辑处理Controller。在做mybatis插件的时候，他的拦截器也是使用的责任的设计模式。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>举个例子，就拿request请求来说，到达服务的时候，可能对url很多不同的处理，全部的逻辑在一个方法里，或者是一个类，这样，方法，类的职业，并不单一，并且全部耦合在一起，一旦逻辑复杂维护成高会非常高。</p>\n<p>使用责任链设计模式，就弱化了请求方和处理方的关联关系，很好的解耦，每一个组件都可以成为一个独立服用的组件，并且可以通过组合的方式，可以处理流程更加灵活。逻辑性更加清晰，可以使用配置的方式，组合不同责任链组件，维护成本也会大大减低。</p>\n<h3 id=\"源地址\"><a href=\"#源地址\" class=\"headerlink\" title=\"源地址\"></a>源地址</h3><p><a><a href=\"https://github.com/wangypeng/java-design-mode-source/tree/master/chain-of-responsibility\" target=\"_blank\" rel=\"noopener\">https://github.com/wangypeng/java-design-mode-source/tree/master/chain-of-responsibility</a></a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjsq3syn3000043xrs6cxqbv4","category_id":"cjsq3synd000343xrmsf8xjfv","_id":"cjsq3synw000f43xrp791d1mt"},{"post_id":"cjsq3synm000743xrd497rjsi","category_id":"cjsq3synd000343xrmsf8xjfv","_id":"cjsq3syny000j43xr1yhwg1et"},{"post_id":"cjsq3syna000243xrf7xqlswi","category_id":"cjsq3synd000343xrmsf8xjfv","_id":"cjsq3synz000m43xrzyd5qyl1"},{"post_id":"cjsq3syng000543xr7f2kr9n4","category_id":"cjsq3synd000343xrmsf8xjfv","_id":"cjsq3syo2000r43xroljcxh6q"},{"post_id":"cjsq3synk000643xrqika771b","category_id":"cjsq3synz000l43xr3o53vdrk","_id":"cjsq3syo5000x43xr7fvfvri3"},{"post_id":"cjsq3syns000b43xr61z2maoh","category_id":"cjsq3syo2000s43xrsksgenah","_id":"cjsq3syo9001343xrdukoo0en"},{"post_id":"cjsq3synv000d43xrfqsamcj8","category_id":"cjsq3syo6000y43xrowy7lf10","_id":"cjsq3syod001a43xrylp1dymj"},{"post_id":"cjsq3synx000i43xrq0hb8pud","category_id":"cjsq3syo2000s43xrsksgenah","_id":"cjsq3syof001e43xr4s7ltv78"},{"post_id":"cjsq3syny000k43xryrqe0o2y","category_id":"cjsq3syod001943xrlormwxrx","_id":"cjsq3syog001j43xrakark9d4"},{"post_id":"cjsq3syo0000p43xru5ecdcro","category_id":"cjsq3syod001943xrlormwxrx","_id":"cjsq3syoh001m43xrah7vlkym"},{"post_id":"cjsq3syo1000q43xrol77ebj7","category_id":"cjsq3syof001i43xrf26xm6oa","_id":"cjsq3syoh001q43xrg2ubv3ay"},{"post_id":"cjsq3syo2000u43xri0yb647b","category_id":"cjsq3syoh001n43xrwbsox0r3","_id":"cjsq3syoj001v43xr74u8hef4"},{"post_id":"cjsq3syo3000w43xrox6vkk2r","category_id":"cjsq3syoh001n43xrwbsox0r3","_id":"cjsq3syol001z43xr4j98y0x2"},{"post_id":"cjsq3syo6001043xrj0c3i3hh","category_id":"cjsq3syoh001n43xrwbsox0r3","_id":"cjsq3syon002343xrrpotyemz"},{"post_id":"cjsq3syo8001243xrvpfekg7d","category_id":"cjsq3syoh001n43xrwbsox0r3","_id":"cjsq3syoo002743xraqm8y3z2"},{"post_id":"cjsq3syoa001643xroc1uzafr","category_id":"cjsq3syoh001n43xrwbsox0r3","_id":"cjsq3syop002b43xrctd6vkfl"},{"post_id":"cjsq3syob001843xrz7kprnqf","category_id":"cjsq3syoh001n43xrwbsox0r3","_id":"cjsq3syop002e43xr4iiyw4ov"},{"post_id":"cjsq3syod001c43xr8zzwe82b","category_id":"cjsq3syoh001n43xrwbsox0r3","_id":"cjsq3syop002g43xr9wx29qyc"}],"PostTag":[{"post_id":"cjsq3syn3000043xrs6cxqbv4","tag_id":"cjsq3syng000443xrfs7jzc4a","_id":"cjsq3syns000a43xr6gzu2pwb"},{"post_id":"cjsq3synm000743xrd497rjsi","tag_id":"cjsq3syng000443xrfs7jzc4a","_id":"cjsq3synu000c43xr1n85n6mt"},{"post_id":"cjsq3syna000243xrf7xqlswi","tag_id":"cjsq3syng000443xrfs7jzc4a","_id":"cjsq3synx000h43xr4izznhii"},{"post_id":"cjsq3syng000543xr7f2kr9n4","tag_id":"cjsq3syng000443xrfs7jzc4a","_id":"cjsq3syo0000o43xrn7zi3jli"},{"post_id":"cjsq3synk000643xrqika771b","tag_id":"cjsq3synz000n43xrr7yf8zkg","_id":"cjsq3syo3000v43xr3h0ne9cg"},{"post_id":"cjsq3syns000b43xr61z2maoh","tag_id":"cjsq3syo2000t43xrnx6m8tah","_id":"cjsq3syo7001143xrue3mnxn3"},{"post_id":"cjsq3synv000d43xrfqsamcj8","tag_id":"cjsq3syo6000z43xr3p98xxzc","_id":"cjsq3syob001743xrof0olqgg"},{"post_id":"cjsq3synx000i43xrq0hb8pud","tag_id":"cjsq3syo2000t43xrnx6m8tah","_id":"cjsq3syoe001d43xrovh9uozt"},{"post_id":"cjsq3syny000k43xryrqe0o2y","tag_id":"cjsq3syod001b43xr2i3v2kjv","_id":"cjsq3syof001h43xrqttirnht"},{"post_id":"cjsq3syo0000p43xru5ecdcro","tag_id":"cjsq3syod001b43xr2i3v2kjv","_id":"cjsq3syog001l43xrurcbtavf"},{"post_id":"cjsq3syo1000q43xrol77ebj7","tag_id":"cjsq3syog001k43xruuqls35l","_id":"cjsq3syoh001p43xrwyl7vvhl"},{"post_id":"cjsq3syo2000u43xri0yb647b","tag_id":"cjsq3syoh001o43xrb92ns18z","_id":"cjsq3syoi001t43xrgh7fmv5k"},{"post_id":"cjsq3syo3000w43xrox6vkk2r","tag_id":"cjsq3syoh001o43xrb92ns18z","_id":"cjsq3syoj001x43xrn072299g"},{"post_id":"cjsq3syo6001043xrj0c3i3hh","tag_id":"cjsq3syoh001o43xrb92ns18z","_id":"cjsq3syon002143xr804xuopt"},{"post_id":"cjsq3syo8001243xrvpfekg7d","tag_id":"cjsq3syoh001o43xrb92ns18z","_id":"cjsq3syoo002543xrhnjl0q1o"},{"post_id":"cjsq3syoa001643xroc1uzafr","tag_id":"cjsq3syoh001o43xrb92ns18z","_id":"cjsq3syoo002943xrbnwtbvza"},{"post_id":"cjsq3syob001843xrz7kprnqf","tag_id":"cjsq3syoh001o43xrb92ns18z","_id":"cjsq3syop002d43xres3ifw34"},{"post_id":"cjsq3syod001c43xr8zzwe82b","tag_id":"cjsq3syoh001o43xrb92ns18z","_id":"cjsq3syop002f43xrcn5ic9u7"}],"Tag":[{"name":"blog","_id":"cjsq3syng000443xrfs7jzc4a"},{"name":"docker","_id":"cjsq3synz000n43xrr7yf8zkg"},{"name":"jvm","_id":"cjsq3syo2000t43xrnx6m8tah"},{"name":"java8","_id":"cjsq3syo6000z43xr3p98xxzc"},{"name":"redis","_id":"cjsq3syod001b43xr2i3v2kjv"},{"name":"spring","_id":"cjsq3syog001k43xruuqls35l"},{"name":"设计模式","_id":"cjsq3syoh001o43xrb92ns18z"}]}}